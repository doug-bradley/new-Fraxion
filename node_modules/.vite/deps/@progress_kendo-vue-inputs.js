import {
  Popup,
  caretAltDownIcon,
  caretAltExpandIcon,
  caretAltLeftIcon,
  caretAltRightIcon,
  caretAltUpIcon,
  checkIcon,
  dropletSlashIcon,
  dropletSliderIcon,
  exclamationCircleIcon,
  hyperlinkOpenIcon,
  paletteIcon,
  provideIntlService,
  provideLocalizationService,
  xIcon
} from "./chunk-AWMTVEKS.js";
import {
  Draggable,
  Icon,
  Keys,
  WatermarkOverlay,
  canUseDOM,
  classNames,
  focusContainer,
  focusFirstFocusableChild,
  getDefaultSlots,
  getIconName,
  getListeners,
  getRef,
  getTabIndex,
  getTemplate,
  guid,
  hasListener,
  isRtl,
  kendoThemeMaps,
  noop,
  setRef,
  shouldShowValidationUI,
  templateDefinition,
  templateRendering,
  validatePackage
} from "./chunk-6VDLL6VR.js";
import {
  __export,
  vue_runtime_esm_bundler_exports
} from "./chunk-6J45UTVV.js";

// node_modules/@progress/kendo-vue-inputs/dist/es/package-metadata.js
var packageMetadata = {
  name: "@progress/kendo-vue-inputs",
  productName: "Kendo UI for Vue",
  productCodes: ["KENDOUIVUE", "KENDOUICOMPLETE"],
  publishDate: 1714476889,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-vue-ui/my-license/?utm_medium=product&utm_source=kendovue&utm_campaign=kendo-ui-vue-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/utils/misc.js
var isPresent = function(value2) {
  return value2 !== null && value2 !== void 0;
};
var fitIntoBounds = function(contender, min, max) {
  if (!isPresent(contender) || isNaN(contender)) {
    return min;
  }
  return contender <= min ? min : contender >= max ? max : contender;
};

// node_modules/@progress/kendo-drawing/dist/es/drawing.js
var drawing_exports = {};
__export(drawing_exports, {
  Animation: () => animation_default,
  AnimationFactory: () => animation_factory_default,
  Arc: () => arc_default2,
  BaseNode: () => base_node_default,
  Circle: () => circle_default2,
  Element: () => element_default,
  Gradient: () => gradient_default,
  GradientStop: () => gradient_stop_default,
  Group: () => group_default,
  HasObservers: () => has_observers_default,
  Image: () => image_default,
  Layout: () => layout_default,
  LinearGradient: () => linear_gradient_default,
  MultiPath: () => MultiPath,
  OptionsStore: () => options_store_default,
  Path: () => Path,
  PathParser: () => path_parser_default,
  Pattern: () => Pattern,
  QuadNode: () => quad_node_default,
  RadialGradient: () => radial_gradient_default,
  Rect: () => rect_default2,
  ShapesQuadTree: () => shapes_quad_tree_default,
  Surface: () => surface_default4,
  SurfaceFactory: () => surface_factory_default,
  Text: () => text_default,
  align: () => align,
  canvas: () => canvas_exports,
  crosshatchPattern: () => crosshatchPattern,
  diagonalStripesPattern: () => diagonalStripesPattern,
  dotsPattern: () => dotsPattern,
  exportImage: () => exportImage,
  exportSVG: () => exportSVG,
  fit: () => fit,
  gridPattern: () => gridPattern,
  parsePath: () => parse_path_default,
  stack: () => stack,
  svg: () => svg_exports,
  util: () => util_exports,
  vAlign: () => vAlign,
  vStack: () => vStack,
  vWrap: () => vWrap,
  verticalStripesPattern: () => verticalStripesPattern,
  wrap: () => wrap
});

// node_modules/@progress/kendo-drawing/dist/es/common/class.js
var Class = class {
  // Empty base class needed for compatibility with Kendo UI for jQuery
};

// node_modules/@progress/kendo-drawing/dist/es/common/observable.js
var Observable = class extends Class {
  constructor() {
    super();
    this._events = {};
  }
  bind(eventName, handlers, one) {
    const eventNames = getArray(eventName);
    const handlersIsFunction = isFunction(handlers);
    const length = eventNames.length;
    if (handlers === void 0) {
      for (let field in eventName) {
        this.bind(field, eventName[field]);
      }
      return this;
    }
    for (let idx = 0; idx < length; idx++) {
      const eventName2 = eventNames[idx];
      let handler = handlersIsFunction ? handlers : handlers[eventName2];
      if (handler) {
        if (one) {
          const original = handler;
          handler = () => {
            this.unbind(eventName2, handler);
            original.apply(this, arguments);
          };
          handler.original = original;
        }
        let events2 = this._events[eventName2] = this._events[eventName2] || [];
        events2.push(handler);
      }
    }
    return this;
  }
  one(eventNames, handlers) {
    return this.bind(eventNames, handlers, true);
  }
  first(eventName, handlers) {
    const eventNames = getArray(eventName);
    const handlersIsFunction = isFunction(handlers);
    for (let idx = 0, length = eventNames.length; idx < length; idx++) {
      const eventName2 = eventNames[idx];
      const handler = handlersIsFunction ? handlers : handlers[eventName2];
      if (handler) {
        const events2 = this._events[eventName2] = this._events[eventName2] || [];
        events2.unshift(handler);
      }
    }
    return this;
  }
  trigger(eventName, e = {}) {
    let events2 = this._events[eventName];
    if (events2) {
      const length = events2.length;
      e.sender = this;
      e._defaultPrevented = false;
      e.preventDefault = preventDefault;
      e.isDefaultPrevented = isDefaultPrevented;
      events2 = events2.slice();
      for (let idx = 0; idx < length; idx++) {
        events2[idx].call(this, e);
      }
      return e._defaultPrevented === true;
    }
    return false;
  }
  unbind(eventName, handler) {
    const events2 = this._events[eventName];
    if (eventName === void 0) {
      this._events = {};
    } else if (events2) {
      if (handler) {
        for (let idx = events2.length - 1; idx >= 0; idx--) {
          if (events2[idx] === handler || events2[idx].original === handler) {
            events2.splice(idx, 1);
          }
        }
      } else {
        this._events[eventName] = [];
      }
    }
    return this;
  }
};
function isFunction(value2) {
  return typeof value2 === "function";
}
function getArray(value2) {
  return typeof value2 === "string" ? [value2] : value2;
}
function preventDefault() {
  this._defaultPrevented = true;
}
function isDefaultPrevented() {
  return this._defaultPrevented === true;
}
var observable_default = Observable;

// node_modules/@progress/kendo-drawing/dist/es/common/animation-frame.js
var animationFrameProxy = (callback) => {
  const wnd = typeof window !== "undefined" ? window : {};
  const animationFrame = wnd.requestAnimationFrame || wnd.webkitRequestAnimationFrame || wnd.mozRequestAnimationFrame || wnd.oRequestAnimationFrame || wnd.msRequestAnimationFrame || function(callback2) {
    setTimeout(callback2, 1e3 / 60);
  };
  animationFrameProxy = (callback2) => animationFrame.call(wnd, callback2);
  animationFrameProxy(callback);
};
var animation_frame_default = animationFrameProxy;

// node_modules/@progress/kendo-drawing/dist/es/common/html-encode.js
var ampRegExp = /&/g;
var ltRegExp = /</g;
var quoteRegExp = /"/g;
var aposRegExp = /'/g;
var gtRegExp = />/g;
function htmlEncode(value2) {
  return String(value2).replace(ampRegExp, "&amp;").replace(ltRegExp, "&lt;").replace(gtRegExp, "&gt;").replace(quoteRegExp, "&quot;").replace(aposRegExp, "&#39;");
}

// node_modules/@progress/kendo-drawing/dist/es/common/log-to-console.js
function logToConsole(message) {
  const console = window.console;
  if (typeof console != "undefined" && console.log) {
    console.log(message);
  }
}

// node_modules/@progress/kendo-drawing/dist/es/common/support.js
function matchUserAgent(userAgent2) {
  const browserRxs = {
    edge: /(edge)[ \/]([\w.]+)/i,
    webkit: /(chrome)[ \/]([\w.]+)/i,
    safari: /(webkit)[ \/]([\w.]+)/i,
    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
    mozilla: /(mozilla)(?:.*? rv:([\w.]+))/i
  };
  let browser6 = {};
  for (let agent in browserRxs) {
    if (browserRxs.hasOwnProperty(agent)) {
      const match = userAgent2.match(browserRxs[agent]);
      if (match) {
        browser6[agent] = true;
        browser6[match[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browser6.version = parseInt(document.documentMode || match[2], 10);
        break;
      }
    }
  }
  return browser6;
}
var browser = null;
var support = {
  get browser() {
    if (typeof window === "undefined" || browser) {
      return browser;
    }
    browser = matchUserAgent(window.navigator.userAgent);
    return browser;
  }
};
var support_default = support;

// node_modules/@progress/kendo-drawing/dist/es/util/now.js
var now = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
var now_default = now;

// node_modules/@progress/kendo-drawing/dist/es/common/throttle.js
function throttle(fn, delay) {
  let lastExecTime = 0;
  let timeout;
  if (!delay || delay <= 0) {
    return fn;
  }
  const throttled = function() {
    const elapsed = now_default() - lastExecTime;
    const args = arguments;
    const exec = function() {
      fn.apply(null, args);
      lastExecTime = now_default();
    };
    if (!lastExecTime) {
      return exec();
    }
    if (timeout) {
      clearTimeout(timeout);
    }
    if (elapsed > delay) {
      exec();
    } else {
      timeout = setTimeout(exec, delay - elapsed);
    }
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
  };
  return throttled;
}

// node_modules/@progress/kendo-drawing/dist/es/common/color/named-colors.js
var namedColors = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgrey: "a9a9a9",
  darkgreen: "006400",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  grey: "808080",
  green: "008000",
  greenyellow: "adff2f",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgrey: "d3d3d3",
  lightgreen: "90ee90",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "778899",
  lightslategrey: "778899",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "00ff00",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "ff00ff",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370d8",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "d87093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  red: "ff0000",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "ffffff",
  whitesmoke: "f5f5f5",
  yellow: "ffff00",
  yellowgreen: "9acd32"
};
var named_colors_default = namedColors;

// node_modules/@progress/kendo-drawing/dist/es/common/color/parse-color.js
var browser2 = support_default.browser;
var matchNamedColor = (color) => {
  const colorNames = Object.keys(named_colors_default);
  colorNames.push("transparent");
  const regexp = new RegExp("^(" + colorNames.join("|") + ")(\\W|$)", "i");
  matchNamedColor = (color2) => regexp.exec(color2);
  return regexp.exec(color);
};
var BaseColor = class extends Class {
  constructor() {
    super();
  }
  toHSV() {
    return this;
  }
  toRGB() {
    return this;
  }
  toHex(options2) {
    return this.toBytes().toHex(options2);
  }
  toBytes() {
    return this;
  }
  toCss(options2) {
    return "#" + this.toHex(options2);
  }
  toCssRgba() {
    const rgb = this.toBytes();
    return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${parseFloat(Number(this.a).toFixed(3))})`;
  }
  toDisplay() {
    if (browser2.msie && browser2.version < 9) {
      return this.toCss();
    }
    return this.toCssRgba();
  }
  equals(c) {
    return c === this || c !== null && c !== void 0 && this.toCssRgba() === parseColor(c).toCssRgba();
  }
  diff(other) {
    if (other === null) {
      return NaN;
    }
    const c1 = this.toBytes();
    const c2 = other.toBytes();
    return Math.sqrt(Math.pow((c1.r - c2.r) * 0.3, 2) + Math.pow((c1.g - c2.g) * 0.59, 2) + Math.pow((c1.b - c2.b) * 0.11, 2));
  }
  clone() {
    let c = this.toBytes();
    if (c === this) {
      c = new Bytes(c.r, c.g, c.b, c.a);
    }
    return c;
  }
};
var RGB = class extends BaseColor {
  constructor(r, g, b, a) {
    super();
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  toHSV() {
    const { r, g, b } = this;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    const v = max;
    let h, s;
    if (delta === 0) {
      return new HSV(0, 0, v, this.a);
    }
    if (max !== 0) {
      s = delta / max;
      if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h *= 60;
      if (h < 0) {
        h += 360;
      }
    } else {
      s = 0;
      h = -1;
    }
    return new HSV(h, s, v, this.a);
  }
  toHSL() {
    const { r, g, b } = this;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
        default:
          break;
      }
    }
    return new HSL(h * 60, s * 100, l * 100, this.a);
  }
  toBytes() {
    return new Bytes(this.r * 255, this.g * 255, this.b * 255, this.a);
  }
};
var Bytes = class extends RGB {
  constructor(r, g, b, a) {
    super(Math.round(r), Math.round(g), Math.round(b), a);
  }
  toRGB() {
    return new RGB(this.r / 255, this.g / 255, this.b / 255, this.a);
  }
  toHSV() {
    return this.toRGB().toHSV();
  }
  toHSL() {
    return this.toRGB().toHSL();
  }
  toHex(options2) {
    let value2 = hex(this.r, 2) + hex(this.g, 2) + hex(this.b, 2);
    if (options2 && options2.alpha) {
      value2 += hex(Math.round(this.a * 255), 2);
    }
    return value2;
  }
  toBytes() {
    return this;
  }
};
function hex(n, width, pad = "0") {
  let result = n.toString(16);
  while (width > result.length) {
    result = pad + result;
  }
  return result;
}
var HSV = class extends BaseColor {
  constructor(h, s, v, a) {
    super();
    this.h = h;
    this.s = s;
    this.v = v;
    this.a = a;
  }
  toRGB() {
    let { h, s, v } = this;
    let r, g, b;
    if (s === 0) {
      r = g = b = v;
    } else {
      h /= 60;
      const i = Math.floor(h);
      const f = h - i;
      const p = v * (1 - s);
      const q = v * (1 - s * f);
      const t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        default:
          r = v;
          g = p;
          b = q;
          break;
      }
    }
    return new RGB(r, g, b, this.a);
  }
  toHSL() {
    return this.toRGB().toHSL();
  }
  toBytes() {
    return this.toRGB().toBytes();
  }
};
var HSL = class extends BaseColor {
  constructor(h, s, l, a) {
    super();
    this.h = h;
    this.s = s;
    this.l = l;
    this.a = a;
  }
  toRGB() {
    let h = this.h / 360;
    let s = this.s / 100;
    let l = this.l / 100;
    let r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return new RGB(r, g, b, this.a);
  }
  toHSV() {
    return this.toRGB().toHSV();
  }
  toBytes() {
    return this.toRGB().toBytes();
  }
};
function hue2rgb(p, q, s) {
  let t = s;
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function alphaFromHex(a) {
  return parseFloat(parseFloat(parseInt(a, 16) / 255).toFixed(3));
}
function parseColor(value2, safe) {
  let m, ret;
  if (!value2 || value2 === "none") {
    return null;
  }
  if (value2 instanceof BaseColor) {
    return value2;
  }
  let color = value2.toLowerCase();
  if (m = matchNamedColor(color)) {
    if (m[1] === "transparent") {
      color = new RGB(1, 1, 1, 0);
    } else {
      color = parseColor(named_colors_default[m[1]], safe);
    }
    color.match = [m[1]];
    return color;
  }
  if (m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m[1], 16),
      parseInt(m[2], 16),
      parseInt(m[3], 16),
      1
    );
  } else if (m = /^#?([0-9a-f])([0-9a-f])([0-9a-f])\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m[1] + m[1], 16),
      parseInt(m[2] + m[2], 16),
      parseInt(m[3] + m[3], 16),
      1
    );
  } else if (m = /^#?([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m[1] + m[1], 16),
      parseInt(m[2] + m[2], 16),
      parseInt(m[3] + m[3], 16),
      alphaFromHex(m[4] + m[4])
    );
  } else if (m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m[1], 16),
      parseInt(m[2], 16),
      parseInt(m[3], 16),
      alphaFromHex(m[4])
    );
  } else if (m = /^rgb\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/.exec(color)) {
    ret = new Bytes(
      parseInt(m[1], 10),
      parseInt(m[2], 10),
      parseInt(m[3], 10),
      1
    );
  } else if (m = /^rgba\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9.]+)\s*\)/.exec(color)) {
    ret = new Bytes(
      parseInt(m[1], 10),
      parseInt(m[2], 10),
      parseInt(m[3], 10),
      parseFloat(m[4])
    );
  } else if (m = /^rgb\(\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*\)/.exec(color)) {
    ret = new RGB(
      parseFloat(m[1]) / 100,
      parseFloat(m[2]) / 100,
      parseFloat(m[3]) / 100,
      1
    );
  } else if (m = /^rgba\(\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9.]+)\s*\)/.exec(color)) {
    ret = new RGB(
      parseFloat(m[1]) / 100,
      parseFloat(m[2]) / 100,
      parseFloat(m[3]) / 100,
      parseFloat(m[4])
    );
  } else if (m = /^color\(\s*srgb\s*([0-9]*\.?[0-9]+)\s+([0-9]*\.?[0-9]+)\s+([0-9]*\.?[0-9]+)\s*(\/\s+([0-9]*\.?[0-9]+))?\)/.exec(color)) {
    ret = new RGB(
      parseFloat(m[1]),
      parseFloat(m[2]),
      parseFloat(m[3]),
      parseFloat(m[5] || "1")
    );
  }
  if (ret) {
    ret.match = m;
  } else if (!safe) {
    throw new Error("Cannot parse color: " + color);
  }
  return ret;
}

// node_modules/@progress/kendo-drawing/dist/es/common/color/color.js
var DARK_TRESHOLD = 180;
var Color = class _Color extends Class {
  constructor(value2) {
    super();
    if (arguments.length === 1) {
      const formats = _Color.formats;
      const resolvedColor = this.resolveColor(value2);
      for (let idx = 0; idx < formats.length; idx++) {
        const formatRegex = formats[idx].re;
        const processor = formats[idx].process;
        const parts = formatRegex.exec(resolvedColor);
        if (parts) {
          const channels = processor(parts);
          this.r = channels[0];
          this.g = channels[1];
          this.b = channels[2];
        }
      }
    } else {
      this.r = arguments[0];
      this.g = arguments[1];
      this.b = arguments[2];
    }
    this.r = this.normalizeByte(this.r);
    this.g = this.normalizeByte(this.g);
    this.b = this.normalizeByte(this.b);
  }
  toHex() {
    const pad = this.padDigit;
    const r = this.r.toString(16);
    const g = this.g.toString(16);
    const b = this.b.toString(16);
    return "#" + pad(r) + pad(g) + pad(b);
  }
  resolveColor(value2) {
    let color = value2 || "black";
    if (color.charAt(0) === "#") {
      color = color.substr(1, 6);
    }
    color = color.replace(/ /g, "");
    color = color.toLowerCase();
    color = _Color.namedColors[color] || color;
    return color;
  }
  normalizeByte(value2) {
    if (value2 < 0 || isNaN(value2)) {
      return 0;
    }
    return value2 > 255 ? 255 : value2;
  }
  padDigit(value2) {
    return value2.length === 1 ? "0" + value2 : value2;
  }
  brightness(value2) {
    const round2 = Math.round;
    this.r = round2(this.normalizeByte(this.r * value2));
    this.g = round2(this.normalizeByte(this.g * value2));
    this.b = round2(this.normalizeByte(this.b * value2));
    return this;
  }
  percBrightness() {
    return Math.sqrt(0.241 * this.r * this.r + 0.691 * this.g * this.g + 0.068 * this.b * this.b);
  }
  isDark() {
    return this.percBrightness() < DARK_TRESHOLD;
  }
  static fromBytes(r, g, b, a) {
    return new Bytes(r, g, b, a != null ? a : 1);
  }
  static fromRGB(r, g, b, a) {
    return new RGB(r, g, b, a != null ? a : 1);
  }
  static fromHSV(h, s, v, a) {
    return new HSV(h, s, v, a != null ? a : 1);
  }
  static fromHSL(h, s, l, a) {
    return new HSL(h, s, l, a != null ? a : 1);
  }
};
Color.formats = [{
  re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
  process: function(parts) {
    return [
      parseInt(parts[1], 10),
      parseInt(parts[2], 10),
      parseInt(parts[3], 10)
    ];
  }
}, {
  re: /^(\w{2})(\w{2})(\w{2})$/,
  process: function(parts) {
    return [
      parseInt(parts[1], 16),
      parseInt(parts[2], 16),
      parseInt(parts[3], 16)
    ];
  }
}, {
  re: /^(\w{1})(\w{1})(\w{1})$/,
  process: function(parts) {
    return [
      parseInt(parts[1] + parts[1], 16),
      parseInt(parts[2] + parts[2], 16),
      parseInt(parts[3] + parts[3], 16)
    ];
  }
}];
Color.namedColors = named_colors_default;
var color_default = Color;

// node_modules/@progress/kendo-drawing/dist/es/core/has-observers.js
var HasObservers = class extends Class {
  observers() {
    this._observers = this._observers || [];
    return this._observers;
  }
  addObserver(element2) {
    if (!this._observers) {
      this._observers = [element2];
    } else {
      this._observers.push(element2);
    }
    return this;
  }
  removeObserver(element2) {
    const observers = this.observers();
    const index = observers.indexOf(element2);
    if (index !== -1) {
      observers.splice(index, 1);
    }
    return this;
  }
  trigger(methodName, event) {
    const observers = this._observers;
    if (observers && !this._suspended) {
      for (let idx = 0; idx < observers.length; idx++) {
        let observer = observers[idx];
        if (observer[methodName]) {
          observer[methodName](event);
        }
      }
    }
    return this;
  }
  optionsChange(e = {}) {
    e.element = this;
    this.trigger("optionsChange", e);
  }
  geometryChange() {
    this.trigger("geometryChange", {
      element: this
    });
  }
  suspend() {
    this._suspended = (this._suspended || 0) + 1;
    return this;
  }
  resume() {
    this._suspended = Math.max((this._suspended || 0) - 1, 0);
    return this;
  }
  _observerField(field, value2) {
    if (this[field]) {
      this[field].removeObserver(this);
    }
    this[field] = value2;
    value2.addObserver(this);
  }
};
var has_observers_default = HasObservers;

// node_modules/@progress/kendo-drawing/dist/es/core/options-store.js
var toString = {}.toString;
var OptionsStore = class _OptionsStore extends has_observers_default {
  constructor(options2, prefix = "") {
    super();
    this.prefix = prefix;
    for (let field in options2) {
      let member = options2[field];
      member = this._wrap(member, field);
      this[field] = member;
    }
  }
  get(field) {
    const parts = field.split(".");
    let result = this;
    while (parts.length && result) {
      let part = parts.shift();
      result = result[part];
    }
    return result;
  }
  set(field, value2) {
    const current = this.get(field);
    if (current !== value2) {
      this._set(field, this._wrap(value2, field));
      this.optionsChange({
        field: this.prefix + field,
        value: value2
      });
    }
  }
  _set(field, value2) {
    const composite = field.indexOf(".") >= 0;
    let parentObj = this;
    let fieldName = field;
    if (composite) {
      const parts = fieldName.split(".");
      let prefix = this.prefix;
      while (parts.length > 1) {
        fieldName = parts.shift();
        prefix += fieldName + ".";
        let obj = parentObj[fieldName];
        if (!obj) {
          obj = new _OptionsStore({}, prefix);
          obj.addObserver(this);
          parentObj[fieldName] = obj;
        }
        parentObj = obj;
      }
      fieldName = parts[0];
    }
    parentObj._clear(fieldName);
    parentObj[fieldName] = value2;
  }
  _clear(field) {
    const current = this[field];
    if (current && current.removeObserver) {
      current.removeObserver(this);
    }
  }
  _wrap(object, field) {
    const type = toString.call(object);
    let wrapped = object;
    if (wrapped !== null && wrapped !== void 0 && type === "[object Object]") {
      if (!(object instanceof _OptionsStore) && !(object instanceof Class)) {
        wrapped = new _OptionsStore(wrapped, this.prefix + field + ".");
      }
      wrapped.addObserver(this);
    }
    return wrapped;
  }
};
var options_store_default = OptionsStore;

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-accessors.js
function setAccessor(field) {
  return function(value2) {
    if (this[field] !== value2) {
      this[field] = value2;
      this.geometryChange();
    }
    return this;
  };
}
function getAccessor(field) {
  return function() {
    return this[field];
  };
}
function defineAccessors(fn, fields) {
  for (let i = 0; i < fields.length; i++) {
    let name3 = fields[i];
    let capitalized = name3.charAt(0).toUpperCase() + name3.substring(1, name3.length);
    fn["set" + capitalized] = setAccessor(name3);
    fn["get" + capitalized] = getAccessor(name3);
  }
}
var withAccessors = (TBase, names) => {
  const result = class extends TBase {
  };
  defineAccessors(result.prototype, names);
  return result;
};
var with_accessors_default = withAccessors;

// node_modules/@progress/kendo-drawing/dist/es/util.js
var util_exports = {};
__export(util_exports, {
  DEG_TO_RAD: () => DEG_TO_RAD,
  LRUCache: () => lru_cache_default,
  MAX_NUM: () => MAX_NUM,
  MIN_NUM: () => MIN_NUM,
  TextMetrics: () => text_metrics_default,
  append: () => append,
  arabicToRoman: () => arabicToRoman,
  bindEvents: () => bindEvents,
  createPromise: () => createPromise,
  defined: () => defined,
  definitionId: () => definitionId,
  deg: () => deg,
  elementOffset: () => elementOffset,
  elementPadding: () => elementPadding,
  elementScale: () => elementScale,
  elementSize: () => elementSize,
  elementStyles: () => elementStyles,
  encodeBase64: () => encodeBase64,
  eventCoordinates: () => eventCoordinates,
  eventElement: () => eventElement,
  hashKey: () => hashKey,
  isTransparent: () => isTransparent,
  last: () => last,
  limitValue: () => limitValue,
  measureText: () => measureText,
  mergeSort: () => mergeSort,
  normalizeText: () => normalizeText,
  now: () => now_default,
  objectKey: () => objectKey,
  promiseAll: () => promiseAll,
  rad: () => rad,
  round: () => round,
  setInnerHTML: () => setInnerHTML,
  unbindEvents: () => unbindEvents,
  valueOrDefault: () => valueOrDefault
});

// node_modules/@progress/kendo-drawing/dist/es/util/append.js
function append(first, second) {
  first.push.apply(first, second);
  return first;
}

// node_modules/@progress/kendo-drawing/dist/es/util/arabic-to-roman.js
var literals = {
  1: "i",
  10: "x",
  100: "c",
  2: "ii",
  20: "xx",
  200: "cc",
  3: "iii",
  30: "xxx",
  300: "ccc",
  4: "iv",
  40: "xl",
  400: "cd",
  5: "v",
  50: "l",
  500: "d",
  6: "vi",
  60: "lx",
  600: "dc",
  7: "vii",
  70: "lxx",
  700: "dcc",
  8: "viii",
  80: "lxxx",
  800: "dccc",
  9: "ix",
  90: "xc",
  900: "cm",
  1e3: "m"
};
function arabicToRoman(n) {
  const values = [
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ];
  let roman = "";
  while (n > 0) {
    if (n < values[0]) {
      values.shift();
    } else {
      roman += literals[values[0]];
      n -= values[0];
    }
  }
  return roman;
}

// node_modules/@progress/kendo-drawing/dist/es/util/create-promise.js
function createPromise() {
  let resolveFn, rejectFn;
  const promise = new Promise((resolve, reject) => {
    resolveFn = (data23) => {
      promise._state = "resolved";
      resolve(data23);
      return promise;
    };
    rejectFn = (data23) => {
      promise._state = "rejected";
      reject(data23);
      return promise;
    };
  });
  promise._state = "pending";
  promise.resolve = resolveFn;
  promise.reject = rejectFn;
  promise.state = () => promise._state;
  return promise;
}

// node_modules/@progress/kendo-drawing/dist/es/util/defined.js
var UNDEFINED = "undefined";
function defined(value2) {
  return typeof value2 !== UNDEFINED;
}

// node_modules/@progress/kendo-drawing/dist/es/util/definition-id.js
var defId = 1;
function definitionId() {
  return "kdef" + defId++;
}

// node_modules/@progress/kendo-drawing/dist/es/util/constants.js
var DEG_TO_RAD = Math.PI / 180;
var MAX_NUM = Number.MAX_VALUE;
var MIN_NUM = -Number.MAX_VALUE;

// node_modules/@progress/kendo-drawing/dist/es/util/deg.js
function deg(radians) {
  return radians / DEG_TO_RAD;
}

// node_modules/@progress/kendo-drawing/dist/es/util/encode-utf.js
var fromCharCode = String.fromCharCode;
function encodeUTF8(input) {
  let output = "";
  for (let i = 0; i < input.length; i++) {
    let code = input.charCodeAt(i);
    if (55296 <= code && code <= 56319) {
      const hi = code;
      const low = input.charCodeAt(++i);
      if (!isNaN(low)) {
        code = (hi - 55296) * 1024 + (low - 56320) + 65536;
      }
    }
    if (code < 128) {
      output += fromCharCode(code);
    } else if (code < 2048) {
      output += fromCharCode(192 | code >>> 6);
      output += fromCharCode(128 | code & 63);
    } else if (code < 65536) {
      output += fromCharCode(224 | code >>> 12);
      output += fromCharCode(128 | code >>> 6 & 63);
      output += fromCharCode(128 | code & 63);
    } else if (code < 1114111) {
      output += fromCharCode(240 | code >>> 18);
      output += fromCharCode(128 | code >>> 12 & 63);
      output += fromCharCode(128 | code >>> 6 & 63);
      output += fromCharCode(128 | code & 63);
    }
  }
  return output;
}

// node_modules/@progress/kendo-drawing/dist/es/util/encode-base64.js
var KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBase64(input) {
  let output = "";
  let i = 0;
  const utfInput = encodeUTF8(input);
  while (i < utfInput.length) {
    let chr1 = utfInput.charCodeAt(i++);
    let chr2 = utfInput.charCodeAt(i++);
    let chr3 = utfInput.charCodeAt(i++);
    let enc1 = chr1 >> 2;
    let enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    let enc3 = (chr2 & 15) << 2 | chr3 >> 6;
    let enc4 = chr3 & 63;
    if (isNaN(chr2)) {
      enc3 = enc4 = 64;
    } else if (isNaN(chr3)) {
      enc4 = 64;
    }
    output = output + KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) + KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);
  }
  return output;
}

// node_modules/@progress/kendo-drawing/dist/es/util/event-coordinates.js
function eventCoordinates(e) {
  if ((e.x || {}).location !== void 0) {
    return {
      x: e.x.location,
      y: e.y.location
    };
  }
  return {
    x: e.pageX || e.clientX || 0,
    y: e.pageY || e.clientY || 0
  };
}

// node_modules/@progress/kendo-drawing/dist/es/util/event-element.js
function eventElement(e = {}) {
  return e.touch ? e.touch.initialTouch : e.target;
}

// node_modules/@progress/kendo-drawing/dist/es/util/is-transparent.js
function isTransparent(color) {
  return color === "" || color === null || color === "none" || color === "transparent" || color === void 0;
}

// node_modules/@progress/kendo-drawing/dist/es/util/last.js
function last(array) {
  if (array) {
    return array[array.length - 1];
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/limit-value.js
function limitValue(value2, min, max) {
  return Math.max(Math.min(value2, max), min);
}

// node_modules/@progress/kendo-drawing/dist/es/util/merge-sort.js
function mergeSort(a, cmp) {
  if (a.length < 2) {
    return a.slice();
  }
  function merge(a2, b) {
    var r = [], ai = 0, bi = 0, i = 0;
    while (ai < a2.length && bi < b.length) {
      if (cmp(a2[ai], b[bi]) <= 0) {
        r[i++] = a2[ai++];
      } else {
        r[i++] = b[bi++];
      }
    }
    if (ai < a2.length) {
      r.push.apply(r, a2.slice(ai));
    }
    if (bi < b.length) {
      r.push.apply(r, b.slice(bi));
    }
    return r;
  }
  return function sort(a2) {
    if (a2.length <= 1) {
      return a2;
    }
    var m = Math.floor(a2.length / 2);
    var left = a2.slice(0, m);
    var right = a2.slice(m);
    left = sort(left);
    right = sort(right);
    return merge(left, right);
  }(a);
}

// node_modules/@progress/kendo-drawing/dist/es/util/promise-all.js
function promiseAll(promises) {
  return Promise.all(promises);
}

// node_modules/@progress/kendo-drawing/dist/es/util/rad.js
function rad(degrees) {
  return degrees * DEG_TO_RAD;
}

// node_modules/@progress/kendo-drawing/dist/es/util/round.js
function pow(p) {
  if (p) {
    return Math.pow(10, p);
  }
  return 1;
}
function round(value2, precision) {
  const power = pow(precision);
  return Math.round(value2 * power) / power;
}

// node_modules/@progress/kendo-drawing/dist/es/util/value-or-default.js
function valueOrDefault(value2, defaultValue) {
  return value2 !== void 0 ? value2 : defaultValue;
}

// node_modules/@progress/kendo-drawing/dist/es/util/bind-events.js
function bindEvents(element2, events2) {
  for (let eventName in events2) {
    const eventNames = eventName.trim().split(" ");
    for (let idx = 0; idx < eventNames.length; idx++) {
      element2.addEventListener(eventNames[idx], events2[eventName], false);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-offset.js
function elementOffset(element2) {
  const box = element2.getBoundingClientRect();
  const documentElement = document.documentElement;
  return {
    top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),
    left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0)
  };
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-styles.js
function elementStyles(element2, styles4) {
  const result = {};
  const style = window.getComputedStyle(element2) || {};
  const stylesArray = Array.isArray(styles4) ? styles4 : [styles4];
  for (let idx = 0; idx < stylesArray.length; idx++) {
    let field = stylesArray[idx];
    result[field] = style[field];
  }
  return result;
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-size.js
function getPixels(value2) {
  if (isNaN(value2)) {
    return value2;
  }
  return value2 + "px";
}
function elementSize(element2, size2) {
  if (size2) {
    const { width, height } = size2;
    if (width !== void 0) {
      element2.style.width = getPixels(width);
    }
    if (height !== void 0) {
      element2.style.height = getPixels(height);
    }
  } else {
    const size3 = elementStyles(element2, ["width", "height"]);
    return {
      width: parseInt(size3.width, 10),
      height: parseInt(size3.height, 10)
    };
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/unbind-events.js
function unbindEvents(element2, events2 = {}) {
  for (let name3 in events2) {
    const eventNames = name3.trim().split(" ");
    for (let idx = 0; idx < eventNames.length; idx++) {
      element2.removeEventListener(eventNames[idx], events2[name3], false);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-padding.js
function elementPadding(element2) {
  const { paddingLeft, paddingTop } = elementStyles(element2, ["paddingLeft", "paddingTop"]);
  return {
    top: parseFloat(paddingTop),
    left: parseFloat(paddingLeft)
  };
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/matrix.js
var Matrix = class _Matrix extends Class {
  constructor(a = 0, b = 0, c = 0, d = 0, e = 0, f = 0) {
    super();
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
  }
  multiplyCopy(matrix) {
    return new _Matrix(
      this.a * matrix.a + this.c * matrix.b,
      this.b * matrix.a + this.d * matrix.b,
      this.a * matrix.c + this.c * matrix.d,
      this.b * matrix.c + this.d * matrix.d,
      this.a * matrix.e + this.c * matrix.f + this.e,
      this.b * matrix.e + this.d * matrix.f + this.f
    );
  }
  invert() {
    const { a, b, c: d, d: e, e: g, f: h } = this;
    const det = a * e - b * d;
    if (det === 0) {
      return null;
    }
    return new _Matrix(
      e / det,
      -b / det,
      -d / det,
      a / det,
      (d * h - e * g) / det,
      (b * g - a * h) / det
    );
  }
  clone() {
    return new _Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  equals(other) {
    if (!other) {
      return false;
    }
    return this.a === other.a && this.b === other.b && this.c === other.c && this.d === other.d && this.e === other.e && this.f === other.f;
  }
  round(precision) {
    this.a = round(this.a, precision);
    this.b = round(this.b, precision);
    this.c = round(this.c, precision);
    this.d = round(this.d, precision);
    this.e = round(this.e, precision);
    this.f = round(this.f, precision);
    return this;
  }
  toArray(precision) {
    const result = [this.a, this.b, this.c, this.d, this.e, this.f];
    if (precision !== void 0) {
      for (let i = 0; i < result.length; i++) {
        result[i] = round(result[i], precision);
      }
    }
    return result;
  }
  toString(precision, separator = ",") {
    return this.toArray(precision).join(separator);
  }
  static translate(x, y) {
    return new _Matrix(1, 0, 0, 1, x, y);
  }
  static unit() {
    return new _Matrix(1, 0, 0, 1, 0, 0);
  }
  static rotate(angle, x, y) {
    const matrix = new _Matrix();
    matrix.a = Math.cos(rad(angle));
    matrix.b = Math.sin(rad(angle));
    matrix.c = -matrix.b;
    matrix.d = matrix.a;
    matrix.e = x - x * matrix.a + y * matrix.b || 0;
    matrix.f = y - y * matrix.a - x * matrix.b || 0;
    return matrix;
  }
  static scale(scaleX, scaleY) {
    return new _Matrix(scaleX, 0, 0, scaleY, 0, 0);
  }
};
Matrix.IDENTITY = Matrix.unit();
var matrix_default = Matrix;

// node_modules/@progress/kendo-drawing/dist/es/util/element-scale.js
var matrixRegexp = /matrix\((.*)\)/;
function parseMatrix(matrixString) {
  const match = matrixString.match(matrixRegexp);
  if (match === null || match.length !== 2) {
    return matrix_default.unit();
  }
  const members = match[1].split(",").map((x) => parseFloat(x));
  return new matrix_default(...members);
}
function transformMatrix(element2) {
  const transform3 = getComputedStyle(element2).transform;
  if (transform3 === "none") {
    return matrix_default.unit();
  }
  return parseMatrix(transform3);
}
function elementScale(element2) {
  if (!element2) {
    return matrix_default.unit();
  }
  let matrix = transformMatrix(element2);
  let parent = element2.parentElement;
  while (parent) {
    const parentMatrix = transformMatrix(parent);
    matrix = matrix.multiplyCopy(parentMatrix);
    parent = parent.parentElement;
  }
  matrix.b = matrix.c = matrix.e = matrix.f = 0;
  return matrix;
}

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/lru-cache.js
var LRUCache = class extends Class {
  constructor(size2) {
    super();
    this._size = size2;
    this._length = 0;
    this._map = {};
  }
  put(key, value2) {
    const map = this._map;
    const entry = { key, value: value2 };
    map[key] = entry;
    if (!this._head) {
      this._head = this._tail = entry;
    } else {
      this._tail.newer = entry;
      entry.older = this._tail;
      this._tail = entry;
    }
    if (this._length >= this._size) {
      map[this._head.key] = null;
      this._head = this._head.newer;
      this._head.older = null;
    } else {
      this._length++;
    }
  }
  get(key) {
    const entry = this._map[key];
    if (entry) {
      if (entry === this._head && entry !== this._tail) {
        this._head = entry.newer;
        this._head.older = null;
      }
      if (entry !== this._tail) {
        if (entry.older) {
          entry.older.newer = entry.newer;
          entry.newer.older = entry.older;
        }
        entry.older = this._tail;
        entry.newer = null;
        this._tail.newer = entry;
        this._tail = entry;
      }
      return entry.value;
    }
  }
};
var lru_cache_default = LRUCache;

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/util.js
var REPLACE_REGEX = /\r?\n|\r|\t/g;
var SPACE = " ";
function normalizeText(text) {
  return String(text).replace(REPLACE_REGEX, SPACE);
}
function objectKey(object) {
  const parts = [];
  for (let key in object) {
    parts.push(key + object[key]);
  }
  return parts.sort().join("");
}
function hashKey(str) {
  let hash = 2166136261;
  for (let i = 0; i < str.length; ++i) {
    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
    hash ^= str.charCodeAt(i);
  }
  return hash >>> 0;
}

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/text-metrics.js
function zeroSize() {
  return { width: 0, height: 0, baseline: 0 };
}
var DEFAULT_OPTIONS = {
  baselineMarkerSize: 1
};
var defaultMeasureBox;
if (typeof document !== "undefined") {
  defaultMeasureBox = document.createElement("div");
  defaultMeasureBox.style.setProperty("position", "absolute", "important");
  defaultMeasureBox.style.setProperty("top", "-4000px", "important");
  defaultMeasureBox.style.setProperty("width", "auto", "important");
  defaultMeasureBox.style.setProperty("height", "auto", "important");
  defaultMeasureBox.style.setProperty("padding", "0", "important");
  defaultMeasureBox.style.setProperty("margin", "0", "important");
  defaultMeasureBox.style.setProperty("border", "0", "important");
  defaultMeasureBox.style.setProperty("line-height", "normal", "important");
  defaultMeasureBox.style.setProperty("visibility", "hidden", "important");
  defaultMeasureBox.style.setProperty("white-space", "pre", "important");
}
var TextMetrics = class extends Class {
  constructor(options2) {
    super();
    this._cache = new lru_cache_default(1e3);
    this.options = Object.assign({}, DEFAULT_OPTIONS, options2);
  }
  measure(text, style, options2 = {}) {
    if (typeof text === "undefined" || text === null) {
      return zeroSize();
    }
    const styleKey = objectKey(style);
    const cacheKey = hashKey(text + styleKey);
    const cachedResult = this._cache.get(cacheKey);
    if (cachedResult) {
      return cachedResult;
    }
    const size2 = zeroSize();
    const measureBox = options2.box || defaultMeasureBox;
    const baselineMarker = this._baselineMarker().cloneNode(false);
    for (let key in style) {
      let value2 = style[key];
      if (typeof value2 !== "undefined") {
        measureBox.style[key] = value2;
      }
    }
    const textStr = options2.normalizeText !== false ? normalizeText(text) : String(text);
    measureBox.textContent = textStr;
    measureBox.appendChild(baselineMarker);
    document.body.appendChild(measureBox);
    if (textStr.length) {
      size2.width = measureBox.offsetWidth - this.options.baselineMarkerSize;
      size2.height = measureBox.offsetHeight;
      size2.baseline = baselineMarker.offsetTop + this.options.baselineMarkerSize;
    }
    if (size2.width > 0 && size2.height > 0) {
      this._cache.put(cacheKey, size2);
    }
    measureBox.parentNode.removeChild(measureBox);
    return size2;
  }
  _baselineMarker() {
    const marker = document.createElement("div");
    marker.style.display = "inline-block";
    marker.style.verticalAlign = "baseline";
    marker.style.width = this.options.baselineMarkerSize + "px";
    marker.style.height = this.options.baselineMarkerSize + "px";
    marker.style.overflow = "hidden";
    return marker;
  }
};
TextMetrics.current = new TextMetrics();
var text_metrics_default = TextMetrics;

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/measure-text.js
function measureText(text, style, measureBox) {
  return text_metrics_default.current.measure(text, style, measureBox);
}

// node_modules/@progress/kendo-common/dist/es/util.js
var isWindowAvailable = function() {
  return typeof window !== "undefined";
};

// node_modules/@progress/kendo-common/dist/es/support.js
var agentRxs = {
  wp: /(Windows Phone(?: OS)?)\s(\d+)\.(\d+(\.\d+)?)/,
  fire: /(Silk)\/(\d+)\.(\d+(\.\d+)?)/,
  android: /(Android|Android.*(?:Opera|Firefox).*?\/)\s*(\d+)(\.(\d+(\.\d+)?))?/,
  iphone: /(iPhone|iPod).*OS\s+(\d+)[\._]([\d\._]+)/,
  ipad: /(iPad).*OS\s+(\d+)[\._]([\d_]+)/,
  meego: /(MeeGo).+NokiaBrowser\/(\d+)\.([\d\._]+)/,
  webos: /(webOS)\/(\d+)\.(\d+(\.\d+)?)/,
  blackberry: /(BlackBerry|BB10).*?Version\/(\d+)\.(\d+(\.\d+)?)/,
  playbook: /(PlayBook).*?Tablet\s*OS\s*(\d+)\.(\d+(\.\d+)?)/,
  windows: /(MSIE)\s+(\d+)\.(\d+(\.\d+)?)/,
  tizen: /(tizen).*?Version\/(\d+)\.(\d+(\.\d+)?)/i,
  sailfish: /(sailfish).*rv:(\d+)\.(\d+(\.\d+)?).*firefox/i,
  ffos: /(Mobile).*rv:(\d+)\.(\d+(\.\d+)?).*Firefox/
};
var osRxs = {
  ios: /^i(phone|pad|pod)$/i,
  android: /^android|fire$/i,
  blackberry: /^blackberry|playbook/i,
  windows: /windows/,
  wp: /wp/,
  flat: /sailfish|ffos|tizen/i,
  meego: /meego/
};
var desktopBrowserRxs = {
  edge: /(edge)[ \/]([\w.]+)/i,
  webkit: /(chrome)[ \/]([\w.]+)/i,
  safari: /(webkit)[ \/]([\w.]+)/i,
  opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
  msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
  mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
};
var mobileBrowserRxs = {
  omini: /Opera\sMini/i,
  omobile: /Opera\sMobi/i,
  firefox: /Firefox|Fennec/i,
  mobilesafari: /version\/.*safari/i,
  ie: /MSIE|Windows\sPhone/i,
  chrome: /chrome|crios/i,
  webkit: /webkit/i
};
var testRx = function(agent, rxs, dflt) {
  for (var rx in rxs) {
    if (rxs.hasOwnProperty(rx) && rxs[rx].test(agent)) {
      return rx;
    }
  }
  return dflt !== void 0 ? dflt : agent;
};
var detectMobileOS = function(ua) {
  var minorVersion;
  var match = [];
  for (var agent in agentRxs) {
    if (agentRxs.hasOwnProperty(agent)) {
      match = ua.match(agentRxs[agent]);
      if (!match) {
        continue;
      }
      if (agent === "windows" && "plugins" in window.navigator) {
        return null;
      }
      var os = {};
      os.device = agent;
      os.browser = testRx(ua, mobileBrowserRxs, "default");
      os.name = testRx(agent, osRxs);
      os[os.name] = true;
      os.majorVersion = match[2];
      os.minorVersion = match[3] ? match[3].replace("_", ".") : ".0";
      minorVersion = os.minorVersion.replace(".", "").substr(0, 2);
      os.flatVersion = os.majorVersion + minorVersion + new Array(3 - (minorVersion.length < 3 ? minorVersion.length : 2)).join("0");
      os.cordova = typeof window.PhoneGap !== void 0 || typeof window.cordova !== void 0;
      os.appMode = window.navigator.standalone || /file|local|wmapp/.test(window.location.protocol) || os.cordova;
      return os;
    }
  }
  return null;
};
var detectDesktopBrowser = function(ua) {
  var browserInfo = null;
  var match = [];
  for (var agent in desktopBrowserRxs) {
    if (desktopBrowserRxs.hasOwnProperty(agent)) {
      match = ua.match(desktopBrowserRxs[agent]);
      if (match) {
        browserInfo = {};
        browserInfo[agent] = true;
        browserInfo[match[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browserInfo.version = parseInt(document.documentMode || match[2], 10);
        break;
      }
    }
  }
  return browserInfo;
};
var userAgent = isWindowAvailable() && window.navigator ? window.navigator.userAgent : null;
var browser3 = userAgent ? detectDesktopBrowser(userAgent) : null;
var mobileOS = userAgent ? detectMobileOS(userAgent) : null;
var touch = isWindowAvailable() && "ontouchstart" in window;
var msPointers = browser3 && !browser3.chrome && window.MSPointerEvent;
var pointers = browser3 && !browser3.chrome && window.PointerEvent;

// node_modules/@progress/kendo-common/dist/es/accessors/getter.js
var getterCache = {};
getterCache["undefined"] = function(obj) {
  return obj;
};

// node_modules/@progress/kendo-common/dist/es/accessors/setter.js
var setterCache = {};
setterCache["undefined"] = function(obj) {
  return obj;
};

// node_modules/@progress/kendo-common/dist/es/parse-style.js
var reComment = /\/\*[\s\S]*?\*\//g;
var reDeclaration = /([^\s:;]+?)\s*:\s*((?:(?:url\(\s*(?:(?:[^"')\\]|\\.)*|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')\s*\)|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|[^;"'])*?)\s*)(?=;|$)/gi;
var reDoubleQuoted = /&quot;|&#34;|&#x22;/gi;
var reSingleQuoted = /&apos;|&#39;|&#x27;/gi;
var doubleQuote = '"';
var singleQuote = "'";
var empty = "";
function replaceQuoteEntities(str) {
  return str.replace(reDoubleQuoted, doubleQuote).replace(reSingleQuoted, singleQuote);
}
function parseInlineStyles(styleString) {
  var styleObject = {};
  var input = replaceQuoteEntities((styleString || empty).replace(reComment, empty));
  var match = reDeclaration.exec(input), property, value2;
  while (match !== null) {
    property = match[1].trim();
    value2 = match[2].trim();
    styleObject[property] = value2;
    match = reDeclaration.exec(input);
  }
  return styleObject;
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-set-styles-safe.js
var setStyle = (element2, styleString) => {
  const styles4 = parseInlineStyles(styleString);
  Object.keys(styles4).forEach((key) => {
    element2.style[key] = styles4[key];
  });
};
var styleAttr = "data-style";
var replaceStyleAttr = (html) => (html || "").replace(/\sstyle=/g, " " + styleAttr + "=");
var restoreStyleAttr = (container) => {
  Array.from(container.querySelectorAll("[" + styleAttr + "]")).forEach((element2) => {
    const styleString = element2.getAttribute(styleAttr);
    element2.removeAttribute(styleAttr);
    setStyle(element2, styleString);
  });
};
var setInnerHTML = (container, html) => {
  container.innerHTML = replaceStyleAttr(html);
  restoreStyleAttr(container);
};

// node_modules/@progress/kendo-drawing/dist/es/geometry/to-matrix.js
function toMatrix(transformation) {
  if (transformation && typeof transformation.matrix === "function") {
    return transformation.matrix();
  }
  return transformation;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/point.js
var Point = class _Point extends with_accessors_default(has_observers_default, ["x", "y"]) {
  constructor(x, y) {
    super();
    this.x = x || 0;
    this.y = y || 0;
  }
  equals(other) {
    return other && other.x === this.x && other.y === this.y;
  }
  clone() {
    return new _Point(this.x, this.y);
  }
  rotate(angle, origin) {
    const originPoint = _Point.create(origin) || _Point.ZERO;
    return this.transform(matrix_default.rotate(angle, originPoint.x, originPoint.y));
  }
  translate(x, y) {
    this.x += x;
    this.y += y;
    this.geometryChange();
    return this;
  }
  translateWith(point2) {
    return this.translate(point2.x, point2.y);
  }
  move(x, y) {
    this.x = this.y = 0;
    return this.translate(x, y);
  }
  scale(scaleX, scaleY = scaleX) {
    this.x *= scaleX;
    this.y *= scaleY;
    this.geometryChange();
    return this;
  }
  scaleCopy(scaleX, scaleY) {
    return this.clone().scale(scaleX, scaleY);
  }
  transform(transformation) {
    const matrix = toMatrix(transformation);
    const { x, y } = this;
    this.x = matrix.a * x + matrix.c * y + matrix.e;
    this.y = matrix.b * x + matrix.d * y + matrix.f;
    this.geometryChange();
    return this;
  }
  transformCopy(transformation) {
    const point2 = this.clone();
    if (transformation) {
      point2.transform(transformation);
    }
    return point2;
  }
  distanceTo(point2) {
    const dx = this.x - point2.x;
    const dy = this.y - point2.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  round(digits) {
    this.x = round(this.x, digits);
    this.y = round(this.y, digits);
    this.geometryChange();
    return this;
  }
  toArray(digits) {
    const doRound = digits !== void 0;
    const x = doRound ? round(this.x, digits) : this.x;
    const y = doRound ? round(this.y, digits) : this.y;
    return [x, y];
  }
  toString(digits, separator = " ") {
    let { x, y } = this;
    if (digits !== void 0) {
      x = round(x, digits);
      y = round(y, digits);
    }
    return x + separator + y;
  }
  static create(arg0, arg1) {
    if (arg0 !== void 0) {
      if (arg0 instanceof _Point) {
        return arg0;
      } else if (arguments.length === 1 && arg0.length === 2) {
        return new _Point(arg0[0], arg0[1]);
      }
      return new _Point(arg0, arg1);
    }
  }
  static min() {
    let minX = MAX_NUM;
    let minY = MAX_NUM;
    for (let i = 0; i < arguments.length; i++) {
      let point2 = arguments[i];
      minX = Math.min(point2.x, minX);
      minY = Math.min(point2.y, minY);
    }
    return new _Point(minX, minY);
  }
  static max() {
    let maxX = MIN_NUM;
    let maxY = MIN_NUM;
    for (let i = 0; i < arguments.length; i++) {
      const point2 = arguments[i];
      maxX = Math.max(point2.x, maxX);
      maxY = Math.max(point2.y, maxY);
    }
    return new _Point(maxX, maxY);
  }
  static minPoint() {
    return new _Point(MIN_NUM, MIN_NUM);
  }
  static maxPoint() {
    return new _Point(MAX_NUM, MAX_NUM);
  }
  static get ZERO() {
    return new _Point(0, 0);
  }
};
var point_default = Point;

// node_modules/@progress/kendo-drawing/dist/es/geometry/size.js
var Size = class _Size extends with_accessors_default(has_observers_default, ["width", "height"]) {
  constructor(width, height) {
    super();
    this.width = width || 0;
    this.height = height || 0;
  }
  equals(other) {
    return other && other.width === this.width && other.height === this.height;
  }
  clone() {
    return new _Size(this.width, this.height);
  }
  toArray(digits) {
    const doRound = digits !== void 0;
    const width = doRound ? round(this.width, digits) : this.width;
    const height = doRound ? round(this.height, digits) : this.height;
    return [width, height];
  }
  static create(arg0, arg1) {
    if (arg0 !== void 0) {
      if (arg0 instanceof _Size) {
        return arg0;
      } else if (arguments.length === 1 && arg0.length === 2) {
        return new _Size(arg0[0], arg0[1]);
      }
      return new _Size(arg0, arg1);
    }
  }
  static get ZERO() {
    return new _Size(0, 0);
  }
};
var size_default = Size;

// node_modules/@progress/kendo-drawing/dist/es/geometry/rect.js
var Rect = class _Rect extends has_observers_default {
  constructor(origin = new point_default(), size2 = new size_default(), cornerRadius = 0) {
    super();
    this.setOrigin(origin);
    this.setSize(size2);
    this.setCornerRadius(cornerRadius);
  }
  clone() {
    return new _Rect(
      this.origin.clone(),
      this.size.clone()
    );
  }
  equals(other) {
    return other && other.origin.equals(this.origin) && other.size.equals(this.size);
  }
  setOrigin(value2) {
    this._observerField("origin", point_default.create(value2));
    this.geometryChange();
    return this;
  }
  getOrigin() {
    return this.origin;
  }
  setCornerRadius(radius) {
    this.cornerRadius = Array.isArray(radius) ? radius : [radius, radius];
    this.geometryChange();
    return this;
  }
  getCornerRadius() {
    return this.cornerRadius;
  }
  setSize(value2) {
    this._observerField("size", size_default.create(value2));
    this.geometryChange();
    return this;
  }
  getSize() {
    return this.size;
  }
  width() {
    return this.size.width;
  }
  height() {
    return this.size.height;
  }
  topLeft() {
    return this.origin.clone();
  }
  bottomRight() {
    return this.origin.clone().translate(this.width(), this.height());
  }
  topRight() {
    return this.origin.clone().translate(this.width(), 0);
  }
  bottomLeft() {
    return this.origin.clone().translate(0, this.height());
  }
  center() {
    return this.origin.clone().translate(this.width() / 2, this.height() / 2);
  }
  bbox(matrix) {
    const tl = this.topLeft().transformCopy(matrix);
    const tr = this.topRight().transformCopy(matrix);
    const br = this.bottomRight().transformCopy(matrix);
    const bl = this.bottomLeft().transformCopy(matrix);
    return _Rect.fromPoints(tl, tr, br, bl);
  }
  transformCopy(m) {
    return _Rect.fromPoints(
      this.topLeft().transform(m),
      this.bottomRight().transform(m)
    );
  }
  expand(x, y = x) {
    this.size.width += 2 * x;
    this.size.height += 2 * y;
    this.origin.translate(-x, -y);
    return this;
  }
  expandCopy(x, y) {
    return this.clone().expand(x, y);
  }
  containsPoint(point2) {
    const origin = this.origin;
    const bottomRight = this.bottomRight();
    return !(point2.x < origin.x || point2.y < origin.y || bottomRight.x < point2.x || bottomRight.y < point2.y);
  }
  _isOnPath(point2, width) {
    const rectOuter = this.expandCopy(width, width);
    const rectInner = this.expandCopy(-width, -width);
    return rectOuter.containsPoint(point2) && !rectInner.containsPoint(point2);
  }
  static fromPoints() {
    const topLeft = point_default.min.apply(null, arguments);
    const bottomRight = point_default.max.apply(null, arguments);
    const size2 = new size_default(
      bottomRight.x - topLeft.x,
      bottomRight.y - topLeft.y
    );
    return new _Rect(topLeft, size2);
  }
  static union(a, b) {
    return _Rect.fromPoints(
      point_default.min(a.topLeft(), b.topLeft()),
      point_default.max(a.bottomRight(), b.bottomRight())
    );
  }
  static intersect(a, b) {
    const rect1 = {
      left: a.topLeft().x,
      top: a.topLeft().y,
      right: a.bottomRight().x,
      bottom: a.bottomRight().y
    };
    const rect2 = {
      left: b.topLeft().x,
      top: b.topLeft().y,
      right: b.bottomRight().x,
      bottom: b.bottomRight().y
    };
    if (rect1.left <= rect2.right && rect2.left <= rect1.right && rect1.top <= rect2.bottom && rect2.top <= rect1.bottom) {
      return _Rect.fromPoints(
        new point_default(Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)),
        new point_default(Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom))
      );
    }
  }
};
var rect_default = Rect;

// node_modules/@progress/kendo-drawing/dist/es/geometry/transformation.js
var Transformation = class _Transformation extends has_observers_default {
  constructor(matrix = matrix_default.unit()) {
    super();
    this._matrix = matrix;
  }
  clone() {
    return new _Transformation(
      this._matrix.clone()
    );
  }
  equals(other) {
    return other && other._matrix.equals(this._matrix);
  }
  translate(x, y) {
    this._matrix = this._matrix.multiplyCopy(matrix_default.translate(x, y));
    this._optionsChange();
    return this;
  }
  scale(scaleX, scaleY = scaleX, origin = null) {
    let originPoint = origin;
    if (originPoint) {
      originPoint = point_default.create(originPoint);
      this._matrix = this._matrix.multiplyCopy(matrix_default.translate(originPoint.x, originPoint.y));
    }
    this._matrix = this._matrix.multiplyCopy(matrix_default.scale(scaleX, scaleY));
    if (originPoint) {
      this._matrix = this._matrix.multiplyCopy(matrix_default.translate(-originPoint.x, -originPoint.y));
    }
    this._optionsChange();
    return this;
  }
  rotate(angle, origin) {
    const originPoint = point_default.create(origin) || point_default.ZERO;
    this._matrix = this._matrix.multiplyCopy(matrix_default.rotate(angle, originPoint.x, originPoint.y));
    this._optionsChange();
    return this;
  }
  multiply(transformation) {
    const matrix = toMatrix(transformation);
    this._matrix = this._matrix.multiplyCopy(matrix);
    this._optionsChange();
    return this;
  }
  matrix(value2) {
    if (value2) {
      this._matrix = value2;
      this._optionsChange();
      return this;
    }
    return this._matrix;
  }
  _optionsChange() {
    this.optionsChange({
      field: "transform",
      value: this
    });
  }
};
var transformation_default = Transformation;

// node_modules/@progress/kendo-drawing/dist/es/geometry/transform.js
function transform(matrix) {
  if (matrix === null) {
    return null;
  }
  if (matrix instanceof transformation_default) {
    return matrix;
  }
  return new transformation_default(matrix);
}

// node_modules/@progress/kendo-drawing/dist/es/core/constants.js
var DASH_ARRAYS = {
  dot: [1.5, 3.5],
  dash: [4, 3.5],
  longdash: [8, 3.5],
  dashdot: [3.5, 3.5, 1.5, 3.5],
  longdashdot: [8, 3.5, 1.5, 3.5],
  longdashdotdot: [8, 3.5, 1.5, 3.5, 1.5, 3.5]
};
var SOLID = "solid";
var BUTT = "butt";
var PATTERN = "Pattern";

// node_modules/@progress/kendo-drawing/dist/es/shapes/element.js
var Element2 = class extends has_observers_default {
  get nodeType() {
    return "Rect";
  }
  constructor(options2) {
    super();
    this._initOptions(options2);
  }
  _initOptions(options2 = {}) {
    const { clip, transform: transform3 } = options2;
    if (transform3) {
      options2.transform = transform(transform3);
    }
    if (clip && !clip.id) {
      clip.id = definitionId();
    }
    this.options = new options_store_default(options2);
    this.options.addObserver(this);
  }
  transform(value2) {
    if (value2 !== void 0) {
      this.options.set("transform", transform(value2));
    } else {
      return this.options.get("transform");
    }
  }
  parentTransform() {
    let element2 = this;
    let parentMatrix;
    while (element2.parent) {
      element2 = element2.parent;
      let transformation = element2.transform();
      if (transformation) {
        parentMatrix = transformation.matrix().multiplyCopy(parentMatrix || matrix_default.unit());
      }
    }
    if (parentMatrix) {
      return transform(parentMatrix);
    }
  }
  currentTransform(parentTransform = this.parentTransform()) {
    const elementTransform = this.transform();
    const elementMatrix = toMatrix(elementTransform);
    let parentMatrix = toMatrix(parentTransform);
    let combinedMatrix;
    if (elementMatrix && parentMatrix) {
      combinedMatrix = parentMatrix.multiplyCopy(elementMatrix);
    } else {
      combinedMatrix = elementMatrix || parentMatrix;
    }
    if (combinedMatrix) {
      return transform(combinedMatrix);
    }
  }
  visible(value2) {
    if (value2 !== void 0) {
      this.options.set("visible", value2);
      return this;
    }
    return this.options.get("visible") !== false;
  }
  clip(value2) {
    const options2 = this.options;
    if (value2 !== void 0) {
      if (value2 && !value2.id) {
        value2.id = definitionId();
      }
      options2.set("clip", value2);
      return this;
    }
    return options2.get("clip");
  }
  opacity(value2) {
    if (value2 !== void 0) {
      this.options.set("opacity", value2);
      return this;
    }
    return valueOrDefault(this.options.get("opacity"), 1);
  }
  className(value2) {
    if (value2 !== void 0) {
      this.options.set("className", value2);
      return this;
    }
    return this.options.get("className");
  }
  clippedBBox(transformation) {
    const bbox = this._clippedBBox(transformation);
    if (bbox) {
      const clip = this.clip();
      return clip ? rect_default.intersect(bbox, clip.bbox(transformation)) : bbox;
    }
  }
  containsPoint(point2, parentTransform) {
    if (this.visible()) {
      const transform3 = this.currentTransform(parentTransform);
      let transformedPoint = point2;
      if (transform3) {
        transformedPoint = point2.transformCopy(transform3.matrix().invert());
      }
      return this._hasFill() && this._containsPoint(transformedPoint) || this._isOnPath && this._hasStroke() && this._isOnPath(transformedPoint);
    }
    return false;
  }
  _hasFill() {
    const fill = this.options.fill;
    return fill && (fill.nodeType === PATTERN || !isTransparent(fill.color));
  }
  _hasStroke() {
    const stroke = this.options.stroke;
    return stroke && stroke.width > 0 && !isTransparent(stroke.color);
  }
  _clippedBBox(transformation) {
    return this.bbox(transformation);
  }
};
var element_default = Element2;

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/ellipse-extreme-angles.js
function ellipseExtremeAngles(center, rx, ry, matrix) {
  let extremeX = 0;
  let extremeY = 0;
  if (matrix) {
    extremeX = Math.atan2(matrix.c * ry, matrix.a * rx);
    if (matrix.b !== 0) {
      extremeY = Math.atan2(matrix.d * ry, matrix.b * rx);
    }
  }
  return {
    x: extremeX,
    y: extremeY
  };
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/circle.js
var PI_DIV_2 = Math.PI / 2;
var Circle = class _Circle extends with_accessors_default(has_observers_default, ["radius"]) {
  constructor(center = new point_default(), radius = 0) {
    super();
    this.setCenter(center);
    this.setRadius(radius);
  }
  setCenter(value2) {
    this._observerField("center", point_default.create(value2));
    this.geometryChange();
    return this;
  }
  getCenter() {
    return this.center;
  }
  equals(other) {
    return other && other.center.equals(this.center) && other.radius === this.radius;
  }
  clone() {
    return new _Circle(this.center.clone(), this.radius);
  }
  pointAt(angle) {
    return this._pointAt(rad(angle));
  }
  bbox(matrix) {
    const extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);
    let minPoint = point_default.maxPoint();
    let maxPoint = point_default.minPoint();
    for (let i = 0; i < 4; i++) {
      let currentPointX = this._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);
      let currentPointY = this._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);
      let currentPoint = new point_default(currentPointX.x, currentPointY.y);
      minPoint = point_default.min(minPoint, currentPoint);
      maxPoint = point_default.max(maxPoint, currentPoint);
    }
    return rect_default.fromPoints(minPoint, maxPoint);
  }
  _pointAt(angle) {
    const { center, radius } = this;
    return new point_default(
      center.x + radius * Math.cos(angle),
      center.y + radius * Math.sin(angle)
    );
  }
  containsPoint(point2) {
    const { center, radius } = this;
    const inCircle = Math.pow(point2.x - center.x, 2) + Math.pow(point2.y - center.y, 2) <= Math.pow(radius, 2);
    return inCircle;
  }
  _isOnPath(point2, width) {
    const { center, radius } = this;
    const pointDistance = center.distanceTo(point2);
    return radius - width <= pointDistance && pointDistance <= radius + width;
  }
};
var circle_default = Circle;

// node_modules/@progress/kendo-drawing/dist/es/mixins/paintable.js
var GRADIENT = "Gradient";
var paintable = (TBase) => class extends TBase {
  fill(color, opacity) {
    const options2 = this.options;
    if (color !== void 0) {
      if (color && color.nodeType !== GRADIENT) {
        const newFill = {
          color
        };
        if (opacity !== void 0) {
          newFill.opacity = opacity;
        }
        options2.set("fill", newFill);
      } else {
        options2.set("fill", color);
      }
      return this;
    }
    return options2.get("fill");
  }
  stroke(color, width, opacity) {
    if (color !== void 0) {
      this.options.set("stroke.color", color);
      if (width !== void 0) {
        this.options.set("stroke.width", width);
      }
      if (opacity !== void 0) {
        this.options.set("stroke.opacity", opacity);
      }
      return this;
    }
    return this.options.get("stroke");
  }
};
var paintable_default = paintable;

// node_modules/@progress/kendo-drawing/dist/es/mixins/measurable.js
var IDENTITY_MATRIX_HASH = matrix_default.IDENTITY.toString();
var measurable = (TBase) => class extends TBase {
  bbox(transformation) {
    const combinedMatrix = toMatrix(this.currentTransform(transformation));
    const matrixHash = combinedMatrix ? combinedMatrix.toString() : IDENTITY_MATRIX_HASH;
    let bbox;
    if (this._bboxCache && this._matrixHash === matrixHash) {
      bbox = this._bboxCache.clone();
    } else {
      bbox = this._bbox(combinedMatrix);
      this._bboxCache = bbox ? bbox.clone() : null;
      this._matrixHash = matrixHash;
    }
    const strokeWidth = this.options.get("stroke.width");
    if (strokeWidth && bbox) {
      bbox.expand(strokeWidth / 2);
    }
    return bbox;
  }
  geometryChange() {
    delete this._bboxCache;
    this.trigger("geometryChange", {
      element: this
    });
  }
};
var measurable_default = measurable;

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-geometry.js
function geometryAccessor(name3) {
  const fieldName = "_" + name3;
  return function(value2) {
    if (value2 !== void 0) {
      this._observerField(fieldName, value2);
      this.geometryChange();
      return this;
    }
    return this[fieldName];
  };
}
function defineGeometryAccessors(fn, names) {
  for (let i = 0; i < names.length; i++) {
    fn[names[i]] = geometryAccessor(names[i]);
  }
}
var withGeometry = (TBase, names = ["geometry"]) => {
  const result = class extends TBase {
  };
  defineGeometryAccessors(result.prototype, names);
  return result;
};
var with_geometry_default = withGeometry;

// node_modules/@progress/kendo-drawing/dist/es/shapes/circle.js
var DEFAULT_STROKE = "#000";
var Circle2 = class extends paintable_default(measurable_default(with_geometry_default(element_default))) {
  get nodeType() {
    return "Circle";
  }
  constructor(geometry = new circle_default(), options2 = {}) {
    super(options2);
    this.geometry(geometry);
    if (this.options.stroke === void 0) {
      this.stroke(DEFAULT_STROKE);
    }
  }
  rawBBox() {
    return this._geometry.bbox();
  }
  _bbox(matrix) {
    return this._geometry.bbox(matrix);
  }
  _containsPoint(point2) {
    return this.geometry().containsPoint(point2);
  }
  _isOnPath(point2) {
    return this.geometry()._isOnPath(point2, this.options.stroke.width / 2);
  }
};
var circle_default2 = Circle2;

// node_modules/@progress/kendo-drawing/dist/es/geometry/constants.js
var PRECISION = 10;

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/close.js
function close(a, b, tolerance = PRECISION) {
  return round(Math.abs(a - b), tolerance) === 0;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/close-or-less.js
function closeOrLess(a, b, tolerance) {
  return a < b || close(a, b, tolerance);
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/line-intersection.js
function lineIntersection(p0, p1, p2, p3) {
  const s1x = p1.x - p0.x;
  const s2x = p3.x - p2.x;
  const s1y = p1.y - p0.y;
  const s2y = p3.y - p2.y;
  const nx = p0.x - p2.x;
  const ny = p0.y - p2.y;
  const d = s1x * s2y - s2x * s1y;
  const s = (s1x * ny - s1y * nx) / d;
  const t = (s2x * ny - s2y * nx) / d;
  if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
    return new point_default(p0.x + t * s1x, p0.y + t * s1y);
  }
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/arc.js
var MAX_INTERVAL = 45;
var pow2 = Math.pow;
var accessors = ["radiusX", "radiusY", "startAngle", "endAngle", "anticlockwise"];
var Arc = class _Arc extends with_accessors_default(has_observers_default, accessors) {
  constructor(center = new point_default(), options2 = {}) {
    super();
    this.setCenter(center);
    this.radiusX = options2.radiusX;
    this.radiusY = options2.radiusY || options2.radiusX;
    this.startAngle = options2.startAngle;
    this.endAngle = options2.endAngle;
    this.anticlockwise = options2.anticlockwise || false;
    this.xRotation = options2.xRotation;
  }
  clone() {
    return new _Arc(this.center, {
      radiusX: this.radiusX,
      radiusY: this.radiusY,
      startAngle: this.startAngle,
      endAngle: this.endAngle,
      anticlockwise: this.anticlockwise
    });
  }
  setCenter(value2) {
    this._observerField("center", point_default.create(value2));
    this.geometryChange();
    return this;
  }
  getCenter() {
    return this.center;
  }
  pointAt(angle) {
    const center = this.center;
    const radian = rad(angle);
    return new point_default(
      center.x + this.radiusX * Math.cos(radian),
      center.y + this.radiusY * Math.sin(radian)
    );
  }
  curvePoints() {
    const startAngle = this.startAngle;
    const dir = this.anticlockwise ? -1 : 1;
    const curvePoints = [this.pointAt(startAngle)];
    const interval = this._arcInterval();
    const intervalAngle = interval.endAngle - interval.startAngle;
    const subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);
    const subIntervalAngle = intervalAngle / subIntervalsCount;
    let currentAngle = startAngle;
    let transformation;
    if (this.xRotation) {
      transformation = transform().rotate(this.xRotation, this.center);
    }
    for (let i = 1; i <= subIntervalsCount; i++) {
      const nextAngle = currentAngle + dir * subIntervalAngle;
      const points3 = this._intervalCurvePoints(currentAngle, nextAngle, transformation);
      curvePoints.push(points3.cp1, points3.cp2, points3.p2);
      currentAngle = nextAngle;
    }
    return curvePoints;
  }
  bbox(matrix) {
    const interval = this._arcInterval();
    const startAngle = interval.startAngle;
    const endAngle = interval.endAngle;
    const extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);
    const extremeX = deg(extremeAngles.x);
    const extremeY = deg(extremeAngles.y);
    const endPoint = this.pointAt(endAngle).transformCopy(matrix);
    let currentAngleX = bboxStartAngle(extremeX, startAngle);
    let currentAngleY = bboxStartAngle(extremeY, startAngle);
    let currentPoint = this.pointAt(startAngle).transformCopy(matrix);
    let minPoint = point_default.min(currentPoint, endPoint);
    let maxPoint = point_default.max(currentPoint, endPoint);
    while (currentAngleX < endAngle || currentAngleY < endAngle) {
      let currentPointX;
      if (currentAngleX < endAngle) {
        currentPointX = this.pointAt(currentAngleX).transformCopy(matrix);
        currentAngleX += 90;
      }
      let currentPointY;
      if (currentAngleY < endAngle) {
        currentPointY = this.pointAt(currentAngleY).transformCopy(matrix);
        currentAngleY += 90;
      }
      currentPoint = new point_default(currentPointX.x, currentPointY.y);
      minPoint = point_default.min(minPoint, currentPoint);
      maxPoint = point_default.max(maxPoint, currentPoint);
    }
    return rect_default.fromPoints(minPoint, maxPoint);
  }
  _arcInterval() {
    let { startAngle, endAngle, anticlockwise } = this;
    if (anticlockwise) {
      let oldStart = startAngle;
      startAngle = endAngle;
      endAngle = oldStart;
    }
    if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {
      endAngle += 360;
    }
    return {
      startAngle,
      endAngle
    };
  }
  _intervalCurvePoints(startAngle, endAngle, transformation) {
    const p1 = this.pointAt(startAngle);
    const p2 = this.pointAt(endAngle);
    const p1Derivative = this._derivativeAt(startAngle);
    const p2Derivative = this._derivativeAt(endAngle);
    const t = (rad(endAngle) - rad(startAngle)) / 3;
    const cp1 = new point_default(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);
    const cp2 = new point_default(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);
    if (transformation) {
      p1.transform(transformation);
      p2.transform(transformation);
      cp1.transform(transformation);
      cp2.transform(transformation);
    }
    return {
      p1,
      cp1,
      cp2,
      p2
    };
  }
  _derivativeAt(angle) {
    const radian = rad(angle);
    return new point_default(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));
  }
  containsPoint(point2) {
    const interval = this._arcInterval();
    const intervalAngle = interval.endAngle - interval.startAngle;
    const { center, radiusX, radiusY } = this;
    const distance = center.distanceTo(point2);
    const angleRad = Math.atan2(point2.y - center.y, point2.x - center.x);
    const pointRadius = radiusX * radiusY / Math.sqrt(pow2(radiusX, 2) * pow2(Math.sin(angleRad), 2) + pow2(radiusY, 2) * pow2(Math.cos(angleRad), 2));
    const startPoint = this.pointAt(this.startAngle).round(PRECISION);
    const endPoint = this.pointAt(this.endAngle).round(PRECISION);
    const intersection = lineIntersection(center, point2.round(PRECISION), startPoint, endPoint);
    let containsPoint;
    if (intervalAngle < 180) {
      containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);
    } else {
      let angle = calculateAngle(center.x, center.y, radiusX, radiusY, point2.x, point2.y);
      if (angle !== 360) {
        angle = (360 + angle) % 360;
      }
      let inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;
      containsPoint = inAngleRange && closeOrLess(distance, pointRadius) || !inAngleRange && (!intersection || intersection.equals(point2));
    }
    return containsPoint;
  }
  _isOnPath(point2, width) {
    const interval = this._arcInterval();
    const center = this.center;
    let angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point2.x, point2.y);
    if (angle !== 360) {
      angle = (360 + angle) % 360;
    }
    const inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;
    return inAngleRange && this.pointAt(angle).distanceTo(point2) <= width;
  }
  static fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {
    const arcParameters = normalizeArcParameters({
      x1: start.x,
      y1: start.y,
      x2: end.x,
      y2: end.y,
      rx,
      ry,
      largeArc,
      swipe,
      rotation
    });
    return new _Arc(arcParameters.center, {
      startAngle: arcParameters.startAngle,
      endAngle: arcParameters.endAngle,
      radiusX: arcParameters.radiusX,
      radiusY: arcParameters.radiusY,
      xRotation: arcParameters.xRotation,
      anticlockwise: swipe === 0
    });
  }
};
function calculateAngle(cx, cy, rx, ry, x, y) {
  const cos = round((x - cx) / rx, 3);
  const sin = round((y - cy) / ry, 3);
  return round(deg(Math.atan2(sin, cos)));
}
function normalizeArcParameters(parameters) {
  let { x1, y1, x2, y2, rx, ry, largeArc, swipe, rotation = 0 } = parameters;
  const radians = rad(rotation);
  const cosine = Math.cos(radians);
  const sine = Math.sin(radians);
  const xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;
  const yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;
  const sign = largeArc !== swipe ? 1 : -1;
  const xt2 = Math.pow(xT, 2);
  const yt2 = Math.pow(yT, 2);
  let rx2 = Math.pow(rx, 2);
  let ry2 = Math.pow(ry, 2);
  let delta = xt2 / rx2 + yt2 / ry2;
  if (delta > 1) {
    delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);
    rx = delta * rx;
    rx2 = Math.pow(rx, 2);
    ry = delta * ry;
    ry2 = Math.pow(ry, 2);
  }
  let constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));
  if (isNaN(constT)) {
    constT = 0;
  }
  const cxT = constT * (rx * yT) / ry;
  const cyT = -constT * (ry * xT) / rx;
  const cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;
  const cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;
  const uX = (xT - cxT) / rx;
  const uY = (yT - cyT) / ry;
  const vX = -(xT + cxT) / rx;
  const vY = -(yT + cyT) / ry;
  const startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));
  const angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);
  let angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));
  if (!swipe && angle > 0) {
    angle -= 360;
  }
  if (swipe && angle < 0) {
    angle += 360;
  }
  let endAngle = startAngle + angle;
  const signEndAngle = endAngle >= 0 ? 1 : -1;
  endAngle = Math.abs(endAngle) % 360 * signEndAngle;
  return {
    center: new point_default(cx, cy),
    startAngle,
    endAngle,
    radiusX: rx,
    radiusY: ry,
    xRotation: rotation
  };
}
function bboxStartAngle(angle, start) {
  let startAngle = angle;
  while (startAngle < start) {
    startAngle += 90;
  }
  return startAngle;
}
var arc_default = Arc;

// node_modules/@progress/kendo-drawing/dist/es/shapes/elements-array.js
var splice = [].splice;
var slice = [].slice;
var ElementsArray = class extends has_observers_default {
  constructor(array = []) {
    super();
    this.length = 0;
    this._splice(0, array.length, array);
  }
  elements(value2) {
    if (value2) {
      this._splice(0, this.length, value2);
      this._change();
      return this;
    }
    return this.slice(0);
  }
  push(...elements) {
    let len = this.length;
    const count = elements.length;
    for (let i = 0; i < count; i++) {
      this[len + i] = elements[i];
      elements[i].addObserver(this);
    }
    this.length = len + count;
    this._change();
    return this.length;
  }
  slice() {
    return slice.call(this);
  }
  pop() {
    if (this.length > 0) {
      const result = this[this.length - 1];
      this.length--;
      result.removeObserver(this);
      this._change();
      return result;
    }
  }
  splice(index, howMany, ...elements) {
    const result = this._splice(index, howMany, elements);
    this._change();
    return result;
  }
  shift() {
    if (this.length > 0) {
      const result = this[0];
      for (let i = 1; i < this.length; i++) {
        this[i - 1] = this[i];
      }
      this.length--;
      result.removeObserver(this);
      this._change();
      return result;
    }
  }
  unshift(...elements) {
    const count = elements.length;
    for (let i = this.length - 1; i >= 0; i--) {
      this[i + count] = this[i];
    }
    for (let i = 0; i < count; i++) {
      this[i] = elements[i];
      elements[i].addObserver(this);
    }
    this.length += count;
    this._change();
    return this.length;
  }
  indexOf(element2) {
    const length = this.length;
    for (let idx = 0; idx < length; idx++) {
      if (this[idx] === element2) {
        return idx;
      }
    }
    return -1;
  }
  _splice(index, howMany, elements) {
    const result = splice.apply(this, [index, howMany].concat(elements));
    this._clearObserver(result);
    this._setObserver(elements);
    return result;
  }
  _add(elements) {
    this._setObserver(elements);
    this._change();
  }
  _remove(elements) {
    this._clearObserver(elements);
    this._change();
  }
  _setObserver(elements) {
    for (let idx = 0; idx < elements.length; idx++) {
      elements[idx].addObserver(this);
    }
  }
  _clearObserver(elements) {
    for (let idx = 0; idx < elements.length; idx++) {
      elements[idx].removeObserver(this);
    }
  }
  _change() {
  }
};
var elements_array_default = ElementsArray;

// node_modules/@progress/kendo-drawing/dist/es/shapes/geometry-elements-array.js
var GeometryElementsArray = class extends elements_array_default {
  _change() {
    this.geometryChange();
  }
};
var geometry_elements_array_default = GeometryElementsArray;

// node_modules/@progress/kendo-drawing/dist/es/geometry.js
var geometry_exports = {};
__export(geometry_exports, {
  Arc: () => arc_default,
  Circle: () => circle_default,
  Matrix: () => matrix_default,
  Point: () => point_default,
  Rect: () => rect_default,
  Segment: () => segment_default,
  Size: () => size_default,
  Transformation: () => transformation_default,
  toMatrix: () => toMatrix,
  transform: () => transform
});

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/is-out-of-end-point.js
function isOutOfEndPoint(endPoint, controlPoint2, point2) {
  const angle = deg(Math.atan2(controlPoint2.y - endPoint.y, controlPoint2.x - endPoint.x));
  const rotatedPoint = point2.transformCopy(transform().rotate(-angle, endPoint));
  return rotatedPoint.x < endPoint.x;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/calculate-curve-at.js
function calculateCurveAt(t, field, points3) {
  const t1 = 1 - t;
  return Math.pow(t1, 3) * points3[0][field] + 3 * Math.pow(t1, 2) * t * points3[1][field] + 3 * Math.pow(t, 2) * t1 * points3[2][field] + Math.pow(t, 3) * points3[3][field];
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/to-cubic-polynomial.js
function toCubicPolynomial(points3, field) {
  return [
    -points3[0][field] + 3 * points3[1][field] - 3 * points3[2][field] + points3[3][field],
    3 * (points3[0][field] - 2 * points3[1][field] + points3[2][field]),
    3 * (-points3[0][field] + points3[1][field]),
    points3[0][field]
  ];
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/complex-number.js
var ComplexNumber = class _ComplexNumber extends Class {
  constructor(real = 0, img = 0) {
    super();
    this.real = real;
    this.img = img;
  }
  add(cNumber) {
    return new _ComplexNumber(round(this.real + cNumber.real, PRECISION), round(this.img + cNumber.img, PRECISION));
  }
  addConstant(value2) {
    return new _ComplexNumber(this.real + value2, this.img);
  }
  negate() {
    return new _ComplexNumber(-this.real, -this.img);
  }
  multiply(cNumber) {
    return new _ComplexNumber(
      this.real * cNumber.real - this.img * cNumber.img,
      this.real * cNumber.img + this.img * cNumber.real
    );
  }
  multiplyConstant(value2) {
    return new _ComplexNumber(this.real * value2, this.img * value2);
  }
  nthRoot(n) {
    const rad2 = Math.atan2(this.img, this.real);
    const r = Math.sqrt(Math.pow(this.img, 2) + Math.pow(this.real, 2));
    const nthR = Math.pow(r, 1 / n);
    return new _ComplexNumber(nthR * Math.cos(rad2 / n), nthR * Math.sin(rad2 / n));
  }
  equals(cNumber) {
    return this.real === cNumber.real && this.img === cNumber.img;
  }
  isReal() {
    return this.img === 0;
  }
};
var complex_number_default = ComplexNumber;

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/solve-cubic-equation.js
function numberSign(x) {
  return x < 0 ? -1 : 1;
}
function solveQuadraticEquation(a, b, c) {
  const squareRoot = Math.sqrt(Math.pow(b, 2) - 4 * a * c);
  return [
    (-b + squareRoot) / (2 * a),
    (-b - squareRoot) / (2 * a)
  ];
}
function solveCubicEquation(a, b, c, d) {
  if (a === 0) {
    return solveQuadraticEquation(b, c, d);
  }
  const p = (3 * a * c - Math.pow(b, 2)) / (3 * Math.pow(a, 2));
  const q = (2 * Math.pow(b, 3) - 9 * a * b * c + 27 * Math.pow(a, 2) * d) / (27 * Math.pow(a, 3));
  const Q = Math.pow(p / 3, 3) + Math.pow(q / 2, 2);
  const i = new complex_number_default(0, 1);
  const b3a = -b / (3 * a);
  let x1, x2, y1, y2, y3, z1, z2;
  if (Q < 0) {
    x1 = new complex_number_default(-q / 2, Math.sqrt(-Q)).nthRoot(3);
    x2 = new complex_number_default(-q / 2, -Math.sqrt(-Q)).nthRoot(3);
  } else {
    x1 = -q / 2 + Math.sqrt(Q);
    x1 = new complex_number_default(numberSign(x1) * Math.pow(Math.abs(x1), 1 / 3));
    x2 = -q / 2 - Math.sqrt(Q);
    x2 = new complex_number_default(numberSign(x2) * Math.pow(Math.abs(x2), 1 / 3));
  }
  y1 = x1.add(x2);
  z1 = x1.add(x2).multiplyConstant(-1 / 2);
  z2 = x1.add(x2.negate()).multiplyConstant(Math.sqrt(3) / 2);
  y2 = z1.add(i.multiply(z2));
  y3 = z1.add(i.negate().multiply(z2));
  const result = [];
  if (y1.isReal()) {
    result.push(round(y1.real + b3a, PRECISION));
  }
  if (y2.isReal()) {
    result.push(round(y2.real + b3a, PRECISION));
  }
  if (y3.isReal()) {
    result.push(round(y3.real + b3a, PRECISION));
  }
  return result;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/has-roots-in-range.js
function hasRootsInRange(points3, point2, field, rootField, range) {
  const polynomial = toCubicPolynomial(points3, rootField);
  const roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point2[rootField]);
  let intersection;
  for (let idx = 0; idx < roots.length; idx++) {
    if (0 <= roots[idx] && roots[idx] <= 1) {
      intersection = calculateCurveAt(roots[idx], field, points3);
      if (Math.abs(intersection - point2[field]) <= range) {
        return true;
      }
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/curve-intersections-count.js
function curveIntersectionsCount(points3, point2, bbox) {
  const polynomial = toCubicPolynomial(points3, "x");
  const roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point2.x);
  let rayIntersection, intersectsRay;
  let count = 0;
  for (let i = 0; i < roots.length; i++) {
    rayIntersection = calculateCurveAt(roots[i], "y", points3);
    intersectsRay = close(rayIntersection, point2.y) || rayIntersection > point2.y;
    if (intersectsRay && ((roots[i] === 0 || roots[i] === 1) && bbox.bottomRight().x > point2.x || 0 < roots[i] && roots[i] < 1)) {
      count++;
    }
  }
  return count;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/line-intersections-count.js
function lineIntersectionsCount(a, b, point2) {
  let intersects;
  if (a.x !== b.x) {
    const minX = Math.min(a.x, b.x);
    const maxX = Math.max(a.x, b.x);
    const minY = Math.min(a.y, b.y);
    const maxY = Math.max(a.y, b.y);
    const inRange = minX <= point2.x && point2.x < maxX;
    if (minY === maxY) {
      intersects = point2.y <= minY && inRange;
    } else {
      intersects = inRange && (maxY - minY) * ((a.x - b.x) * (a.y - b.y) > 0 ? point2.x - minX : maxX - point2.x) / (maxX - minX) + minY - point2.y >= 0;
    }
  }
  return intersects ? 1 : 0;
}

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-points.js
function pointAccessor(name3) {
  const fieldName = "_" + name3;
  return function(value2) {
    if (value2 !== void 0) {
      this._observerField(fieldName, point_default.create(value2));
      this.geometryChange();
      return this;
    }
    return this[fieldName];
  };
}
function definePointAccessors(fn, names) {
  for (let i = 0; i < names.length; i++) {
    fn[names[i]] = pointAccessor(names[i]);
  }
}
var withPoints = (TBase, names) => {
  const result = class extends TBase {
  };
  definePointAccessors(result.prototype, names);
  return result;
};
var with_points_default = withPoints;

// node_modules/@progress/kendo-drawing/dist/es/geometry/segment.js
var points = ["anchor", "controlIn", "controlOut"];
var Segment = class extends with_points_default(has_observers_default, points) {
  constructor(anchor, controlIn, controlOut) {
    super();
    this.anchor(anchor || new point_default());
    this.controlIn(controlIn);
    this.controlOut(controlOut);
  }
  bboxTo(toSegment, matrix) {
    const segmentAnchor = this.anchor().transformCopy(matrix);
    const toSegmentAnchor = toSegment.anchor().transformCopy(matrix);
    let rect;
    if (this.controlOut() && toSegment.controlIn()) {
      rect = this._curveBoundingBox(
        segmentAnchor,
        this.controlOut().transformCopy(matrix),
        toSegment.controlIn().transformCopy(matrix),
        toSegmentAnchor
      );
    } else {
      rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);
    }
    return rect;
  }
  _lineBoundingBox(p1, p2) {
    return rect_default.fromPoints(p1, p2);
  }
  _curveBoundingBox(p1, cp1, cp2, p2) {
    const points3 = [p1, cp1, cp2, p2];
    const extremesX = this._curveExtremesFor(points3, "x");
    const extremesY = this._curveExtremesFor(points3, "y");
    const xLimits = arrayLimits([extremesX.min, extremesX.max, p1.x, p2.x]);
    const yLimits = arrayLimits([extremesY.min, extremesY.max, p1.y, p2.y]);
    return rect_default.fromPoints(new point_default(xLimits.min, yLimits.min), new point_default(xLimits.max, yLimits.max));
  }
  _curveExtremesFor(points3, field) {
    const extremes = this._curveExtremes(
      points3[0][field],
      points3[1][field],
      points3[2][field],
      points3[3][field]
    );
    return {
      min: calculateCurveAt(extremes.min, field, points3),
      max: calculateCurveAt(extremes.max, field, points3)
    };
  }
  _curveExtremes(x1, x2, x3, x4) {
    const a = x1 - 3 * x2 + 3 * x3 - x4;
    const b = -2 * (x1 - 2 * x2 + x3);
    const c = x1 - x2;
    const sqrt = Math.sqrt(b * b - 4 * a * c);
    let t1 = 0;
    let t2 = 1;
    if (a === 0) {
      if (b !== 0) {
        t1 = t2 = -c / b;
      }
    } else if (!isNaN(sqrt)) {
      t1 = (-b + sqrt) / (2 * a);
      t2 = (-b - sqrt) / (2 * a);
    }
    let min = Math.max(Math.min(t1, t2), 0);
    if (min < 0 || min > 1) {
      min = 0;
    }
    let max = Math.min(Math.max(t1, t2), 1);
    if (max > 1 || max < 0) {
      max = 1;
    }
    return {
      min,
      max
    };
  }
  _intersectionsTo(segment, point2) {
    let intersectionsCount;
    if (this.controlOut() && segment.controlIn()) {
      intersectionsCount = curveIntersectionsCount([this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor()], point2, this.bboxTo(segment));
    } else {
      intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point2);
    }
    return intersectionsCount;
  }
  _isOnCurveTo(segment, point2, width, endSegment) {
    const bbox = this.bboxTo(segment).expand(width, width);
    if (bbox.containsPoint(point2)) {
      const p1 = this.anchor();
      const p2 = this.controlOut();
      const p3 = segment.controlIn();
      const p4 = segment.anchor();
      if (endSegment === "start" && p1.distanceTo(point2) <= width) {
        return !isOutOfEndPoint(p1, p2, point2);
      } else if (endSegment === "end" && p4.distanceTo(point2) <= width) {
        return !isOutOfEndPoint(p4, p3, point2);
      }
      const points3 = [p1, p2, p3, p4];
      if (hasRootsInRange(points3, point2, "x", "y", width) || hasRootsInRange(points3, point2, "y", "x", width)) {
        return true;
      }
      const rotation = transform().rotate(45, point2);
      const rotatedPoints = [p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation)];
      return hasRootsInRange(rotatedPoints, point2, "x", "y", width) || hasRootsInRange(rotatedPoints, point2, "y", "x", width);
    }
  }
  _isOnLineTo(segment, point2, width) {
    const p1 = this.anchor();
    const p2 = segment.anchor();
    const angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));
    const rect = new rect_default([p1.x, p1.y - width / 2], [p1.distanceTo(p2), width]);
    return rect.containsPoint(point2.transformCopy(transform().rotate(-angle, p1)));
  }
  _isOnPathTo(segment, point2, width, endSegment) {
    let isOnPath;
    if (this.controlOut() && segment.controlIn()) {
      isOnPath = this._isOnCurveTo(segment, point2, width / 2, endSegment);
    } else {
      isOnPath = this._isOnLineTo(segment, point2, width);
    }
    return isOnPath;
  }
};
function arrayLimits(arr) {
  let length = arr.length;
  let min = MAX_NUM;
  let max = MIN_NUM;
  for (let i = 0; i < length; i++) {
    max = Math.max(max, arr[i]);
    min = Math.min(min, arr[i]);
  }
  return {
    min,
    max
  };
}
var segment_default = Segment;

// node_modules/@progress/kendo-drawing/dist/es/shapes/utils/points-to-curve.js
var WEIGHT = 0.333;
var EXTREMUM_ALLOWED_DEVIATION = 0.01;
var X = "x";
var Y = "y";
function pointsToCurve(pointsIn, closed) {
  const points3 = pointsIn.slice(0);
  const segments = [];
  let length = points3.length;
  if (length > 2) {
    removeDuplicates(0, points3);
    length = points3.length;
  }
  if (length < 2 || length === 2 && points3[0].equals(points3[1])) {
    return segments;
  }
  let p0 = points3[0];
  let p1 = points3[1];
  let p2 = points3[2];
  segments.push(new segment_default(p0));
  while (p0.equals(points3[length - 1])) {
    closed = true;
    points3.pop();
    length--;
  }
  if (length === 2) {
    const tangent = getTangent(p0, p1, X, Y);
    last(segments).controlOut(
      firstControlPoint(tangent, p0, p1, X, Y)
    );
    segments.push(new segment_default(
      p1,
      secondControlPoint(tangent, p0, p1, X, Y)
    ));
    return segments;
  }
  let initialControlPoint, lastControlPoint;
  if (closed) {
    p0 = points3[length - 1];
    p1 = points3[0];
    p2 = points3[1];
    const controlPoints = getControlPoints(p0, p1, p2);
    initialControlPoint = controlPoints[1];
    lastControlPoint = controlPoints[0];
  } else {
    const tangent = getTangent(p0, p1, X, Y);
    initialControlPoint = firstControlPoint(tangent, p0, p1, X, Y);
  }
  let cp0 = initialControlPoint;
  for (let idx = 0; idx <= length - 3; idx++) {
    removeDuplicates(idx, points3);
    length = points3.length;
    if (idx + 3 <= length) {
      p0 = points3[idx];
      p1 = points3[idx + 1];
      p2 = points3[idx + 2];
      const controlPoints = getControlPoints(p0, p1, p2);
      last(segments).controlOut(cp0);
      cp0 = controlPoints[1];
      const cp1 = controlPoints[0];
      segments.push(new segment_default(p1, cp1));
    }
  }
  if (closed) {
    p0 = points3[length - 2];
    p1 = points3[length - 1];
    p2 = points3[0];
    const controlPoints = getControlPoints(p0, p1, p2);
    last(segments).controlOut(cp0);
    segments.push(new segment_default(
      p1,
      controlPoints[0]
    ));
    last(segments).controlOut(controlPoints[1]);
    segments.push(new segment_default(
      p2,
      lastControlPoint
    ));
  } else {
    const tangent = getTangent(p1, p2, X, Y);
    last(segments).controlOut(cp0);
    segments.push(new segment_default(
      p2,
      secondControlPoint(tangent, p1, p2, X, Y)
    ));
  }
  return segments;
}
function removeDuplicates(idx, points3) {
  while (points3[idx + 1] && (points3[idx].equals(points3[idx + 1]) || points3[idx + 1].equals(points3[idx + 2]))) {
    points3.splice(idx + 1, 1);
  }
}
function invertAxis(p0, p1, p2) {
  let invertAxis2 = false;
  if (p0.x === p1.x) {
    invertAxis2 = true;
  } else if (p1.x === p2.x) {
    if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {
      invertAxis2 = true;
    }
  } else {
    const fn = lineFunction(p0, p1);
    const y2 = calculateFunction(fn, p2.x);
    if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {
      invertAxis2 = true;
    }
  }
  return invertAxis2;
}
function isLine(p0, p1, p2) {
  const fn = lineFunction(p0, p1);
  const y2 = calculateFunction(fn, p2.x);
  return p0.x === p1.x && p1.x === p2.x || round(y2, 1) === round(p2.y, 1);
}
function lineFunction(p1, p2) {
  const a = (p2.y - p1.y) / (p2.x - p1.x);
  const b = p1.y - a * p1.x;
  return [b, a];
}
function getControlPoints(p0, p1, p2) {
  let xField = X;
  let yField = Y;
  let restrict = false;
  let switchOrientation = false;
  let tangent;
  if (isLine(p0, p1, p2)) {
    tangent = getTangent(p0, p1, X, Y);
  } else {
    const monotonic = {
      x: isMonotonicByField(p0, p1, p2, X),
      y: isMonotonicByField(p0, p1, p2, Y)
    };
    if (monotonic.x && monotonic.y) {
      tangent = getTangent(p0, p2, X, Y);
      restrict = true;
    } else {
      if (invertAxis(p0, p1, p2)) {
        xField = Y;
        yField = X;
      }
      if (monotonic[xField]) {
        tangent = 0;
      } else {
        let sign;
        if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {
          sign = numberSign2((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));
        } else {
          sign = -numberSign2((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));
        }
        tangent = EXTREMUM_ALLOWED_DEVIATION * sign;
        switchOrientation = true;
      }
    }
  }
  const secondCP = secondControlPoint(tangent, p0, p1, xField, yField);
  if (switchOrientation) {
    const oldXField = xField;
    xField = yField;
    yField = oldXField;
  }
  const firstCP = firstControlPoint(tangent, p1, p2, xField, yField);
  if (restrict) {
    restrictControlPoint(p0, p1, secondCP, tangent);
    restrictControlPoint(p1, p2, firstCP, tangent);
  }
  return [secondCP, firstCP];
}
function restrictControlPoint(p1, p2, cp, tangent) {
  if (p1.y < p2.y) {
    if (p2.y < cp.y) {
      cp.x = p1.x + (p2.y - p1.y) / tangent;
      cp.y = p2.y;
    } else if (cp.y < p1.y) {
      cp.x = p2.x - (p2.y - p1.y) / tangent;
      cp.y = p1.y;
    }
  } else {
    if (cp.y < p2.y) {
      cp.x = p1.x - (p1.y - p2.y) / tangent;
      cp.y = p2.y;
    } else if (p1.y < cp.y) {
      cp.x = p2.x + (p1.y - p2.y) / tangent;
      cp.y = p1.y;
    }
  }
}
function getTangent(p0, p1, xField, yField) {
  const x = p1[xField] - p0[xField];
  const y = p1[yField] - p0[yField];
  let tangent;
  if (x === 0) {
    tangent = 0;
  } else {
    tangent = y / x;
  }
  return tangent;
}
function isMonotonicByField(p0, p1, p2, field) {
  return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];
}
function firstControlPoint(tangent, p0, p3, xField, yField) {
  const t1 = p0[xField];
  const t2 = p3[xField];
  const distance = (t2 - t1) * WEIGHT;
  return point(t1 + distance, p0[yField] + distance * tangent, xField, yField);
}
function secondControlPoint(tangent, p0, p3, xField, yField) {
  const t1 = p0[xField];
  const t2 = p3[xField];
  const distance = (t2 - t1) * WEIGHT;
  return point(t2 - distance, p3[yField] - distance * tangent, xField, yField);
}
function point(xValue, yValue, xField, yField) {
  const controlPoint2 = new point_default();
  controlPoint2[xField] = xValue;
  controlPoint2[yField] = yValue;
  return controlPoint2;
}
function calculateFunction(fn, x) {
  const length = fn.length;
  let result = 0;
  for (let i = 0; i < length; i++) {
    result += Math.pow(x, i) * fn[i];
  }
  return result;
}
function numberSign2(value2) {
  return value2 <= 0 ? -1 : 1;
}

// node_modules/@progress/kendo-drawing/dist/es/parsing/shape-map.js
var ShapeMap = {
  l: function(path, options2) {
    const { parameters, position: position2 } = options2;
    for (let i = 0; i < parameters.length; i += 2) {
      let point2 = new point_default(parameters[i], parameters[i + 1]);
      if (options2.isRelative) {
        point2.translateWith(position2);
      }
      path.lineTo(point2.x, point2.y);
      position2.x = point2.x;
      position2.y = point2.y;
    }
  },
  c: function(path, options2) {
    const { parameters, position: position2 } = options2;
    for (let i = 0; i < parameters.length; i += 6) {
      let controlOut = new point_default(parameters[i], parameters[i + 1]);
      let controlIn = new point_default(parameters[i + 2], parameters[i + 3]);
      let point2 = new point_default(parameters[i + 4], parameters[i + 5]);
      if (options2.isRelative) {
        controlIn.translateWith(position2);
        controlOut.translateWith(position2);
        point2.translateWith(position2);
      }
      path.curveTo(controlOut, controlIn, point2);
      position2.x = point2.x;
      position2.y = point2.y;
    }
  },
  v: function(path, options2) {
    const value2 = options2.isRelative ? 0 : options2.position.x;
    toLineParamaters(options2.parameters, true, value2);
    this.l(path, options2);
  },
  h: function(path, options2) {
    const value2 = options2.isRelative ? 0 : options2.position.y;
    toLineParamaters(options2.parameters, false, value2);
    this.l(path, options2);
  },
  a: function(path, options2) {
    const { parameters, position: position2 } = options2;
    for (let i = 0; i < parameters.length; i += 7) {
      const radiusX = parameters[i];
      const radiusY = parameters[i + 1];
      const rotation = parameters[i + 2];
      const largeArc = parameters[i + 3];
      const swipe = parameters[i + 4];
      const endPoint = new point_default(parameters[i + 5], parameters[i + 6]);
      if (options2.isRelative) {
        endPoint.translateWith(position2);
      }
      if (position2.x !== endPoint.x || position2.y !== endPoint.y) {
        path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);
        position2.x = endPoint.x;
        position2.y = endPoint.y;
      }
    }
  },
  s: function(path, options2) {
    const { parameters, position: position2, previousCommand } = options2;
    let lastControlIn;
    if (previousCommand === "s" || previousCommand === "c") {
      lastControlIn = last(last(path.paths).segments).controlIn();
    }
    for (let i = 0; i < parameters.length; i += 4) {
      let controlIn = new point_default(parameters[i], parameters[i + 1]);
      let endPoint = new point_default(parameters[i + 2], parameters[i + 3]);
      let controlOut;
      if (options2.isRelative) {
        controlIn.translateWith(position2);
        endPoint.translateWith(position2);
      }
      if (lastControlIn) {
        controlOut = reflectionPoint(lastControlIn, position2);
      } else {
        controlOut = position2.clone();
      }
      lastControlIn = controlIn;
      path.curveTo(controlOut, controlIn, endPoint);
      position2.x = endPoint.x;
      position2.y = endPoint.y;
    }
  },
  q: function(path, options2) {
    const { parameters, position: position2 } = options2;
    for (let i = 0; i < parameters.length; i += 4) {
      let controlPoint2 = new point_default(parameters[i], parameters[i + 1]);
      let endPoint = new point_default(parameters[i + 2], parameters[i + 3]);
      if (options2.isRelative) {
        controlPoint2.translateWith(position2);
        endPoint.translateWith(position2);
      }
      let cubicControlPoints = quadraticToCubicControlPoints(position2, controlPoint2, endPoint);
      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);
      position2.x = endPoint.x;
      position2.y = endPoint.y;
    }
  },
  t: function(path, options2) {
    const { parameters, position: position2, previousCommand } = options2;
    let controlPoint2;
    if (previousCommand === "q" || previousCommand === "t") {
      let lastSegment = last(last(path.paths).segments);
      controlPoint2 = lastSegment.controlIn().clone().translateWith(position2.scaleCopy(-1 / 3)).scale(3 / 2);
    }
    for (let i = 0; i < parameters.length; i += 2) {
      let endPoint = new point_default(parameters[i], parameters[i + 1]);
      if (options2.isRelative) {
        endPoint.translateWith(position2);
      }
      if (controlPoint2) {
        controlPoint2 = reflectionPoint(controlPoint2, position2);
      } else {
        controlPoint2 = position2.clone();
      }
      let cubicControlPoints = quadraticToCubicControlPoints(position2, controlPoint2, endPoint);
      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);
      position2.x = endPoint.x;
      position2.y = endPoint.y;
    }
  }
};
function toLineParamaters(parameters, isVertical, value2) {
  const insertPosition = isVertical ? 0 : 1;
  for (let i = 0; i < parameters.length; i += 2) {
    parameters.splice(i + insertPosition, 0, value2);
  }
}
function reflectionPoint(point2, center) {
  if (point2 && center) {
    return center.scaleCopy(2).translate(-point2.x, -point2.y);
  }
}
var third = 1 / 3;
function quadraticToCubicControlPoints(position2, controlPoint2, endPoint) {
  const scaledPoint = controlPoint2.clone().scale(2 / 3);
  return {
    controlOut: scaledPoint.clone().translateWith(position2.scaleCopy(third)),
    controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))
  };
}
var shape_map_default = ShapeMap;

// node_modules/@progress/kendo-drawing/dist/es/parsing/parse-path.js
var SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi;
var SPLIT_REGEX = /[,\s]?([+\-]?(?:\d*\.\d+|\d+)(?:[eE][+\-]?\d+)?)/g;
var MOVE = "m";
var CLOSE = "z";
function parseParameters(str) {
  const parameters = [];
  str.replace(SPLIT_REGEX, function(match, number) {
    parameters.push(parseFloat(number));
  });
  return parameters;
}
function parsePath(pathInstance, str) {
  const position2 = new point_default();
  let previousCommand;
  str.replace(SEGMENT_REGEX, (match, element2, params, closePath) => {
    let command = element2.toLowerCase();
    const isRelative = command === element2;
    const parameters = parseParameters(params.trim());
    if (command === MOVE) {
      if (isRelative) {
        position2.x += parameters[0];
        position2.y += parameters[1];
      } else {
        position2.x = parameters[0];
        position2.y = parameters[1];
      }
      pathInstance.moveTo(position2.x, position2.y);
      if (parameters.length > 2) {
        command = "l";
        parameters.splice(0, 2);
      }
    }
    if (shape_map_default[command]) {
      shape_map_default[command](
        pathInstance,
        {
          parameters,
          position: position2,
          isRelative,
          previousCommand
        }
      );
      if (closePath && closePath.toLowerCase() === CLOSE) {
        pathInstance.close();
      }
    } else if (command !== MOVE) {
      throw new Error("Error while parsing SVG path. Unsupported command: " + command);
    }
    previousCommand = command;
  });
  return pathInstance;
}
var parse_path_default = parsePath;

// node_modules/@progress/kendo-drawing/dist/es/shapes/utils/elements-bounding-box.js
function elementsBoundingBox(elements, applyTransform, transformation) {
  let boundingBox;
  for (let i = 0; i < elements.length; i++) {
    let element2 = elements[i];
    if (element2.visible()) {
      let elementBoundingBox = applyTransform ? element2.bbox(transformation) : element2.rawBBox();
      if (elementBoundingBox) {
        if (boundingBox) {
          boundingBox = rect_default.union(boundingBox, elementBoundingBox);
        } else {
          boundingBox = elementBoundingBox;
        }
      }
    }
  }
  return boundingBox;
}

// node_modules/@progress/kendo-drawing/dist/es/shapes/utils/elements-clippend-bounding-box.js
function elementsClippedBoundingBox(elements, transformation) {
  let boundingBox;
  for (let i = 0; i < elements.length; i++) {
    let element2 = elements[i];
    if (element2.visible()) {
      let elementBoundingBox = element2.clippedBBox(transformation);
      if (elementBoundingBox) {
        if (boundingBox) {
          boundingBox = rect_default.union(boundingBox, elementBoundingBox);
        } else {
          boundingBox = elementBoundingBox;
        }
      }
    }
  }
  return boundingBox;
}

// node_modules/@progress/kendo-drawing/dist/es/shapes/path.js
var SPACE2 = " ";
var printPoints = (precision) => (...points3) => points3.map((p) => p.toString(precision)).join(SPACE2);
var segmentType = (segmentStart, segmentEnd) => segmentStart.controlOut() && segmentEnd.controlIn() ? "C" : "L";
var Path = class _Path extends paintable_default(measurable_default(element_default)) {
  get nodeType() {
    return "Path";
  }
  constructor(options2) {
    super(options2);
    this.segments = new geometry_elements_array_default();
    this.segments.addObserver(this);
    if (this.options.stroke === void 0) {
      this.stroke("#000");
      if (this.options.stroke.lineJoin === void 0) {
        this.options.set("stroke.lineJoin", "miter");
      }
    }
  }
  moveTo(x, y) {
    this.suspend();
    this.segments.elements([]);
    this.resume();
    this.lineTo(x, y);
    return this;
  }
  lineTo(x, y) {
    const point2 = y !== void 0 ? new point_default(x, y) : x;
    const segment = new segment_default(point2);
    this.segments.push(segment);
    return this;
  }
  curveTo(controlOut, controlIn, point2) {
    if (this.segments.length > 0) {
      const lastSegment = last(this.segments);
      const segment = new segment_default(point2, controlIn);
      this.suspend();
      lastSegment.controlOut(controlOut);
      this.resume();
      this.segments.push(segment);
    }
    return this;
  }
  arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {
    if (this.segments.length > 0) {
      const lastSegment = last(this.segments);
      const anchor = lastSegment.anchor();
      const start = rad(startAngle);
      const center = new point_default(
        anchor.x - radiusX * Math.cos(start),
        anchor.y - radiusY * Math.sin(start)
      );
      const arc = new arc_default(center, {
        startAngle,
        endAngle,
        radiusX,
        radiusY,
        anticlockwise
      });
      this._addArcSegments(arc);
    }
    return this;
  }
  arcTo(end, rx, ry, largeArc, swipe, rotation) {
    if (this.segments.length > 0) {
      const lastSegment = last(this.segments);
      const anchor = lastSegment.anchor();
      const arc = arc_default.fromPoints(anchor, point_default.create(end), rx, ry, largeArc, swipe, rotation);
      this._addArcSegments(arc);
    }
    return this;
  }
  _addArcSegments(arc) {
    this.suspend();
    const curvePoints = arc.curvePoints();
    for (let i = 1; i < curvePoints.length; i += 3) {
      this.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);
    }
    this.resume();
    this.geometryChange();
  }
  close() {
    this.options.closed = true;
    this.geometryChange();
    return this;
  }
  rawBBox() {
    return this._bbox();
  }
  toString(digits) {
    let output = "";
    const segments = this.segments;
    const length = segments.length;
    if (length > 0) {
      const parts = [];
      const print = printPoints(digits);
      let currentType;
      for (let i = 1; i < length; i++) {
        let type = segmentType(segments[i - 1], segments[i]);
        if (type !== currentType) {
          currentType = type;
          parts.push(type);
        }
        if (type === "L") {
          parts.push(print(segments[i].anchor()));
        } else {
          parts.push(print(
            segments[i - 1].controlOut(),
            segments[i].controlIn(),
            segments[i].anchor()
          ));
        }
      }
      output = "M" + print(segments[0].anchor()) + SPACE2 + parts.join(SPACE2);
      if (this.options.closed) {
        output += "Z";
      }
    }
    return output;
  }
  _containsPoint(point2) {
    const segments = this.segments;
    const length = segments.length;
    let intersectionsCount = 0;
    let previous, current;
    for (let idx = 1; idx < length; idx++) {
      previous = segments[idx - 1];
      current = segments[idx];
      intersectionsCount += previous._intersectionsTo(current, point2);
    }
    if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {
      intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point2);
    }
    return intersectionsCount % 2 !== 0;
  }
  _isOnPath(point2, width) {
    const segments = this.segments;
    const length = segments.length;
    const pathWidth = width || this.options.stroke.width;
    if (length > 1) {
      if (segments[0]._isOnPathTo(segments[1], point2, pathWidth, "start")) {
        return true;
      }
      for (let idx = 2; idx <= length - 2; idx++) {
        if (segments[idx - 1]._isOnPathTo(segments[idx], point2, pathWidth)) {
          return true;
        }
      }
      if (segments[length - 2]._isOnPathTo(segments[length - 1], point2, pathWidth, "end")) {
        return true;
      }
    }
    return false;
  }
  _bbox(matrix) {
    const segments = this.segments;
    const length = segments.length;
    let boundingBox;
    if (length === 1) {
      let anchor = segments[0].anchor().transformCopy(matrix);
      boundingBox = new rect_default(anchor, size_default.ZERO);
    } else if (length > 0) {
      for (let i = 1; i < length; i++) {
        let segmentBox = segments[i - 1].bboxTo(segments[i], matrix);
        if (boundingBox) {
          boundingBox = rect_default.union(boundingBox, segmentBox);
        } else {
          boundingBox = segmentBox;
        }
      }
    }
    return boundingBox;
  }
  static parse(str, options2) {
    return MultiPath.parse(str, options2);
  }
  static fromRect(rect, options2) {
    const path = new _Path(options2);
    let [rx, ry] = rect.cornerRadius;
    if (rx === 0 && ry === 0) {
      path.moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close();
    } else {
      const origin = rect.origin;
      const { x, y } = origin;
      const width = rect.width();
      const height = rect.height();
      rx = limitValue(rx, 0, width / 2);
      ry = limitValue(ry, 0, height / 2);
      path.moveTo(x + rx, y).lineTo(x + width - rx, y).arcTo([x + width, y + ry], rx, ry, false).lineTo(x + width, y + height - ry).arcTo([x + width - rx, y + height], rx, ry, false).lineTo(x + rx, y + height).arcTo([x, y + height - ry], rx, ry, false).lineTo(x, y + ry).arcTo([x + rx, y], rx, ry, false);
    }
    return path;
  }
  static fromPoints(points3, options2) {
    if (points3) {
      const path = new _Path(options2);
      for (let i = 0; i < points3.length; i++) {
        let point2 = point_default.create(points3[i]);
        if (point2) {
          if (i === 0) {
            path.moveTo(point2);
          } else {
            path.lineTo(point2);
          }
        }
      }
      return path;
    }
  }
  static curveFromPoints(points3, options2) {
    if (points3) {
      const segments = pointsToCurve(points3);
      const path = new _Path(options2);
      path.segments.push.apply(path.segments, segments);
      return path;
    }
  }
  static fromArc(arc, options2) {
    const path = new _Path(options2);
    const startAngle = arc.startAngle;
    const start = arc.pointAt(startAngle);
    path.moveTo(start.x, start.y);
    path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);
    return path;
  }
};
var MultiPath = class _MultiPath extends paintable_default(measurable_default(element_default)) {
  static parse(str, options2) {
    const instance4 = new _MultiPath(options2);
    return parse_path_default(instance4, str);
  }
  toString(digits) {
    const paths = this.paths;
    let output = "";
    if (paths.length > 0) {
      const result = [];
      for (let i = 0; i < paths.length; i++) {
        result.push(paths[i].toString(digits));
      }
      output = result.join(SPACE2);
    }
    return output;
  }
  get nodeType() {
    return "MultiPath";
  }
  constructor(options2) {
    super(options2);
    this.paths = new geometry_elements_array_default();
    this.paths.addObserver(this);
    if (this.options.stroke === void 0) {
      this.stroke("#000");
    }
  }
  moveTo(x, y) {
    const path = new Path();
    path.moveTo(x, y);
    this.paths.push(path);
    return this;
  }
  lineTo(x, y) {
    if (this.paths.length > 0) {
      last(this.paths).lineTo(x, y);
    }
    return this;
  }
  curveTo(controlOut, controlIn, point2) {
    if (this.paths.length > 0) {
      last(this.paths).curveTo(controlOut, controlIn, point2);
    }
    return this;
  }
  arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {
    if (this.paths.length > 0) {
      last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);
    }
    return this;
  }
  arcTo(end, rx, ry, largeArc, swipe, rotation) {
    if (this.paths.length > 0) {
      last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);
    }
    return this;
  }
  close() {
    if (this.paths.length > 0) {
      last(this.paths).close();
    }
    return this;
  }
  _bbox(matrix) {
    return elementsBoundingBox(this.paths, true, matrix);
  }
  rawBBox() {
    return elementsBoundingBox(this.paths, false);
  }
  _containsPoint(point2) {
    const paths = this.paths;
    for (let idx = 0; idx < paths.length; idx++) {
      if (paths[idx]._containsPoint(point2)) {
        return true;
      }
    }
    return false;
  }
  _isOnPath(point2) {
    const paths = this.paths;
    const width = this.options.stroke.width;
    for (let idx = 0; idx < paths.length; idx++) {
      if (paths[idx]._isOnPath(point2, width)) {
        return true;
      }
    }
    return false;
  }
  _clippedBBox(transformation) {
    return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));
  }
};

// node_modules/@progress/kendo-drawing/dist/es/shapes/arc.js
var DEFAULT_STROKE2 = "#000";
var Arc2 = class extends paintable_default(measurable_default(with_geometry_default(element_default))) {
  get nodeType() {
    return "Arc";
  }
  constructor(geometry = new arc_default(), options2 = {}) {
    super(options2);
    this.geometry(geometry);
    if (this.options.stroke === void 0) {
      this.stroke(DEFAULT_STROKE2);
    }
  }
  _bbox(matrix) {
    return this._geometry.bbox(matrix);
  }
  rawBBox() {
    return this.geometry().bbox();
  }
  toPath() {
    const path = new Path();
    const curvePoints = this.geometry().curvePoints();
    if (curvePoints.length > 0) {
      path.moveTo(curvePoints[0].x, curvePoints[0].y);
      for (let i = 1; i < curvePoints.length; i += 3) {
        path.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);
      }
    }
    return path;
  }
  _containsPoint(point2) {
    return this.geometry().containsPoint(point2);
  }
  _isOnPath(point2) {
    return this.geometry()._isOnPath(point2, this.options.stroke.width / 2);
  }
};
var arc_default2 = Arc2;

// node_modules/@progress/kendo-drawing/dist/es/shapes/text.js
var DEFAULT_FONT = "12px sans-serif";
var DEFAULT_FILL = "#000";
var Text = class extends paintable_default(with_points_default(element_default, ["position"])) {
  get nodeType() {
    return "Text";
  }
  constructor(content, position2 = new point_default(), options2 = {}) {
    super(options2);
    this.content(content);
    this.position(position2);
    if (!this.options.font) {
      this.options.font = DEFAULT_FONT;
    }
    if (this.options.fill === void 0) {
      this.fill(DEFAULT_FILL);
    }
  }
  content(value2) {
    if (value2 !== void 0) {
      this.options.set("content", value2);
      return this;
    }
    return this.options.get("content");
  }
  measure() {
    const metrics = measureText(this.content(), {
      font: this.options.get("font")
    });
    return metrics;
  }
  rect() {
    const size2 = this.measure();
    const pos = this.position().clone();
    return new rect_default(pos, [size2.width, size2.height]);
  }
  bbox(transformation) {
    const combinedMatrix = toMatrix(this.currentTransform(transformation));
    return this.rect().bbox(combinedMatrix);
  }
  rawBBox() {
    return this.rect().bbox();
  }
  _containsPoint(point2) {
    return this.rect().containsPoint(point2);
  }
};
var text_default = Text;

// node_modules/@progress/kendo-drawing/dist/es/shapes/image.js
var Image2 = class extends with_geometry_default(element_default, ["rect"]) {
  get nodeType() {
    return "Image";
  }
  constructor(src, rect = new rect_default(), options2 = {}) {
    super(options2);
    this.src(src);
    this.rect(rect);
  }
  src(value2) {
    if (value2 !== void 0) {
      this.options.set("src", value2);
      return this;
    }
    return this.options.get("src");
  }
  bbox(transformation) {
    const combinedMatrix = toMatrix(this.currentTransform(transformation));
    return this._rect.bbox(combinedMatrix);
  }
  rawBBox() {
    return this._rect.bbox();
  }
  _containsPoint(point2) {
    return this._rect.containsPoint(point2);
  }
  _hasFill() {
    return this.src();
  }
};
var image_default = Image2;

// node_modules/@progress/kendo-drawing/dist/es/mixins/traversable.js
var traversable = (TBase, childrenField) => class extends TBase {
  traverse(callback) {
    const children = this[childrenField];
    for (let i = 0; i < children.length; i++) {
      let child = children[i];
      if (child.traverse) {
        child.traverse(callback);
      } else {
        callback(child);
      }
    }
    return this;
  }
};
var traversable_default = traversable;

// node_modules/@progress/kendo-drawing/dist/es/shapes/group.js
var Group = class extends traversable_default(element_default, "children") {
  get nodeType() {
    return "Group";
  }
  constructor(options2) {
    super(options2);
    this.children = [];
  }
  childrenChange(action, items, index) {
    this.trigger("childrenChange", {
      action,
      items,
      index
    });
  }
  append() {
    append(this.children, arguments);
    this._reparent(arguments, this);
    this.childrenChange("add", arguments);
    return this;
  }
  insert(index, element2) {
    this.children.splice(index, 0, element2);
    element2.parent = this;
    this.childrenChange("add", [element2], index);
    return this;
  }
  insertAt(element2, index) {
    return this.insert(index, element2);
  }
  remove(element2) {
    const index = this.children.indexOf(element2);
    if (index >= 0) {
      this.children.splice(index, 1);
      element2.parent = null;
      this.childrenChange("remove", [element2], index);
    }
    return this;
  }
  removeAt(index) {
    if (0 <= index && index < this.children.length) {
      let element2 = this.children[index];
      this.children.splice(index, 1);
      element2.parent = null;
      this.childrenChange("remove", [element2], index);
    }
    return this;
  }
  clear() {
    const items = this.children;
    this.children = [];
    this._reparent(items, null);
    this.childrenChange("remove", items, 0);
    return this;
  }
  bbox(transformation) {
    return elementsBoundingBox(this.children, true, this.currentTransform(transformation));
  }
  rawBBox() {
    return elementsBoundingBox(this.children, false);
  }
  _clippedBBox(transformation) {
    return elementsClippedBoundingBox(this.children, this.currentTransform(transformation));
  }
  currentTransform(transformation) {
    return element_default.prototype.currentTransform.call(this, transformation) || null;
  }
  containsPoint(point2, parentTransform) {
    if (this.visible()) {
      const children = this.children;
      const transform3 = this.currentTransform(parentTransform);
      for (let idx = 0; idx < children.length; idx++) {
        if (children[idx].containsPoint(point2, transform3)) {
          return true;
        }
      }
    }
    return false;
  }
  _reparent(elements, newParent) {
    for (let i = 0; i < elements.length; i++) {
      const child = elements[i];
      const parent = child.parent;
      if (parent && parent !== this && parent.remove) {
        parent.remove(child);
      }
      child.parent = newParent;
    }
  }
};
var group_default = Group;

// node_modules/@progress/kendo-drawing/dist/es/alignment/translate-to-point.js
function translateToPoint(point2, bbox, element2) {
  const transofrm = element2.transform() || transform();
  const matrix = transofrm.matrix();
  matrix.e += point2.x - bbox.origin.x;
  matrix.f += point2.y - bbox.origin.y;
  transofrm.matrix(matrix);
  element2.transform(transofrm);
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/align-start.js
function alignStart(size2, rect, align2, axis, sizeField) {
  let start;
  if (align2 === "start") {
    start = rect.origin[axis];
  } else if (align2 === "end") {
    start = rect.origin[axis] + rect.size[sizeField] - size2;
  } else {
    start = rect.origin[axis] + (rect.size[sizeField] - size2) / 2;
  }
  return start;
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/align-start-reverse.js
function alignStartReverse(size2, rect, align2, axis, sizeField) {
  let start;
  if (align2 === "start") {
    start = rect.origin[axis] + rect.size[sizeField] - size2;
  } else if (align2 === "end") {
    start = rect.origin[axis];
  } else {
    start = rect.origin[axis] + (rect.size[sizeField] - size2) / 2;
  }
  return start;
}

// node_modules/@progress/kendo-drawing/dist/es/shapes/layout.js
var DEFAULT_OPTIONS2 = {
  alignContent: "start",
  justifyContent: "start",
  alignItems: "start",
  spacing: 0,
  orientation: "horizontal",
  lineSpacing: 0,
  wrap: true,
  revers: false
};
var forEach = (elements, callback) => {
  elements.forEach(callback);
};
var forEachReverse = (elements, callback) => {
  const length = elements.length;
  for (let idx = length - 1; idx >= 0; idx--) {
    callback(elements[idx], idx);
  }
};
var Layout = class extends group_default {
  constructor(rect, options2) {
    super(Object.assign({}, DEFAULT_OPTIONS2, options2));
    this._rect = rect;
    this._fieldMap = {};
  }
  rect(value2) {
    if (value2) {
      this._rect = value2;
      return this;
    }
    return this._rect;
  }
  appendBreak() {
    const breakMarker = new group_default();
    breakMarker._isBreakMarker = true;
    this.append(breakMarker);
    return this;
  }
  _initMap() {
    const options2 = this.options;
    const fieldMap = this._fieldMap;
    if (options2.orientation === "horizontal") {
      fieldMap.sizeField = "width";
      fieldMap.groupsSizeField = "height";
      fieldMap.groupAxis = "x";
      fieldMap.groupsAxis = "y";
    } else {
      fieldMap.sizeField = "height";
      fieldMap.groupsSizeField = "width";
      fieldMap.groupAxis = "y";
      fieldMap.groupsAxis = "x";
    }
    if (options2.reverse) {
      this.forEach = forEachReverse;
      this.justifyAlign = alignStartReverse;
    } else {
      this.forEach = forEach;
      this.justifyAlign = alignStart;
    }
  }
  reflow() {
    if (!this._rect || this.children.length === 0) {
      return;
    }
    this._initMap();
    if (this.options.transform) {
      this.transform(null);
    }
    const options2 = this.options;
    const rect = this._rect;
    const { groups, groupsSize } = this._initGroups();
    const { sizeField, groupsSizeField, groupAxis, groupsAxis } = this._fieldMap;
    const groupOrigin = new point_default();
    const elementOrigin = new point_default();
    const size2 = new size_default();
    let groupStart = alignStart(groupsSize, rect, options2.alignContent, groupsAxis, groupsSizeField);
    let elementStart, group, groupBox;
    const arrangeElements = (bbox, idx) => {
      const element2 = group.elements[idx];
      elementOrigin[groupAxis] = elementStart;
      elementOrigin[groupsAxis] = alignStart(bbox.size[groupsSizeField], groupBox, options2.alignItems, groupsAxis, groupsSizeField);
      translateToPoint(elementOrigin, bbox, element2);
      elementStart += bbox.size[sizeField] + options2.spacing;
    };
    for (let groupIdx = 0; groupIdx < groups.length; groupIdx++) {
      group = groups[groupIdx];
      groupOrigin[groupAxis] = elementStart = this.justifyAlign(group.size, rect, options2.justifyContent, groupAxis, sizeField);
      groupOrigin[groupsAxis] = groupStart;
      size2[sizeField] = group.size;
      size2[groupsSizeField] = group.lineSize;
      groupBox = new rect_default(groupOrigin, size2);
      this.forEach(group.bboxes, arrangeElements);
      groupStart += group.lineSize + options2.lineSpacing;
    }
    if (!options2.wrap && group.size > rect.size[sizeField]) {
      const scale = rect.size[sizeField] / groupBox.size[sizeField];
      const scaledStart = groupBox.topLeft().scale(scale, scale);
      const scaledSize = groupBox.size[groupsSizeField] * scale;
      const newStart = alignStart(scaledSize, rect, options2.alignContent, groupsAxis, groupsSizeField);
      const transform3 = transform();
      if (groupAxis === "x") {
        transform3.translate(rect.origin.x - scaledStart.x, newStart - scaledStart.y);
      } else {
        transform3.translate(newStart - scaledStart.x, rect.origin.y - scaledStart.y);
      }
      transform3.scale(scale, scale);
      this.transform(transform3);
    }
  }
  _initGroups() {
    const { options: options2, children } = this;
    const { lineSpacing, wrap: wrap2, spacing } = options2;
    const sizeField = this._fieldMap.sizeField;
    let group = this._newGroup();
    const groups = [];
    const addGroup = function() {
      groups.push(group);
      groupsSize += group.lineSize + lineSpacing;
    };
    let groupsSize = -lineSpacing;
    for (let idx = 0; idx < children.length; idx++) {
      let element2 = children[idx];
      let bbox = children[idx].clippedBBox();
      if (element2._isBreakMarker) {
        if (group.bboxes.length > 0) {
          addGroup();
          group = this._newGroup();
        }
        continue;
      }
      if (element2.visible() && bbox) {
        if (wrap2 && group.size + bbox.size[sizeField] + spacing > this._rect.size[sizeField]) {
          if (group.bboxes.length === 0) {
            this._addToGroup(group, bbox, element2);
            addGroup();
            group = this._newGroup();
          } else {
            addGroup();
            group = this._newGroup();
            this._addToGroup(group, bbox, element2);
          }
        } else {
          this._addToGroup(group, bbox, element2);
        }
      }
    }
    if (group.bboxes.length) {
      addGroup();
    }
    return {
      groups,
      groupsSize
    };
  }
  _addToGroup(group, bbox, element2) {
    group.size += bbox.size[this._fieldMap.sizeField] + this.options.spacing;
    group.lineSize = Math.max(bbox.size[this._fieldMap.groupsSizeField], group.lineSize);
    group.bboxes.push(bbox);
    group.elements.push(element2);
  }
  _newGroup() {
    return {
      lineSize: 0,
      size: -this.options.spacing,
      bboxes: [],
      elements: []
    };
  }
};
var layout_default = Layout;

// node_modules/@progress/kendo-drawing/dist/es/shapes/rect.js
var Rect2 = class extends paintable_default(measurable_default(with_geometry_default(element_default))) {
  get nodeType() {
    return "Rect";
  }
  constructor(geometry = new rect_default(), options2 = {}) {
    super(options2);
    this.geometry(geometry);
    if (this.options.stroke === void 0) {
      this.stroke("#000");
    }
  }
  _bbox(matrix) {
    return this._geometry.bbox(matrix);
  }
  rawBBox() {
    return this._geometry.bbox();
  }
  _containsPoint(point2) {
    return this._geometry.containsPoint(point2);
  }
  _isOnPath(point2) {
    return this.geometry()._isOnPath(point2, this.options.stroke.width / 2);
  }
};
var rect_default2 = Rect2;

// node_modules/@progress/kendo-drawing/dist/es/alignment/align-elements.js
function alignElements(elements, rect, alignment, axis, sizeField) {
  for (let idx = 0; idx < elements.length; idx++) {
    const bbox = elements[idx].clippedBBox();
    if (bbox) {
      const point2 = bbox.origin.clone();
      point2[axis] = alignStart(bbox.size[sizeField], rect, alignment || "start", axis, sizeField);
      translateToPoint(point2, bbox, elements[idx]);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/align.js
function align(elements, rect, alignment) {
  alignElements(elements, rect, alignment, "x", "width");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/v-align.js
function vAlign(elements, rect, alignment) {
  alignElements(elements, rect, alignment, "y", "height");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/stack-elements.js
function stackElements(elements, stackAxis, otherAxis, sizeField) {
  if (elements.length > 1) {
    const origin = new point_default();
    let previousBBox = elements[0].bbox;
    for (let idx = 1; idx < elements.length; idx++) {
      let element2 = elements[idx].element;
      let bbox = elements[idx].bbox;
      origin[stackAxis] = previousBBox.origin[stackAxis] + previousBBox.size[sizeField];
      origin[otherAxis] = bbox.origin[otherAxis];
      translateToPoint(origin, bbox, element2);
      bbox.origin[stackAxis] = origin[stackAxis];
      previousBBox = bbox;
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/create-stack-elements.js
function createStackElements(elements) {
  const stackElements2 = [];
  for (let idx = 0; idx < elements.length; idx++) {
    let element2 = elements[idx];
    let bbox = element2.clippedBBox();
    if (bbox) {
      stackElements2.push({
        element: element2,
        bbox
      });
    }
  }
  return stackElements2;
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/stack.js
function stack(elements) {
  stackElements(createStackElements(elements), "x", "y", "width");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/v-stack.js
function vStack(elements) {
  stackElements(createStackElements(elements), "y", "x", "height");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/wrap-elements.js
function getStacks(elements, rect, sizeField) {
  const maxSize = rect.size[sizeField];
  const stacks = [];
  let stack2 = [];
  let stackSize = 0;
  let element2, bbox;
  const addElementToStack = function() {
    stack2.push({
      element: element2,
      bbox
    });
  };
  for (let idx = 0; idx < elements.length; idx++) {
    element2 = elements[idx];
    bbox = element2.clippedBBox();
    if (bbox) {
      let size2 = bbox.size[sizeField];
      if (stackSize + size2 > maxSize) {
        if (stack2.length) {
          stacks.push(stack2);
          stack2 = [];
          addElementToStack();
          stackSize = size2;
        } else {
          addElementToStack();
          stacks.push(stack2);
          stack2 = [];
          stackSize = 0;
        }
      } else {
        addElementToStack();
        stackSize += size2;
      }
    }
  }
  if (stack2.length) {
    stacks.push(stack2);
  }
  return stacks;
}
function wrapElements(elements, rect, axis, otherAxis, sizeField) {
  const stacks = getStacks(elements, rect, sizeField);
  const origin = rect.origin.clone();
  const result = [];
  for (let idx = 0; idx < stacks.length; idx++) {
    let stack2 = stacks[idx];
    let startElement = stack2[0];
    origin[otherAxis] = startElement.bbox.origin[otherAxis];
    translateToPoint(origin, startElement.bbox, startElement.element);
    startElement.bbox.origin[axis] = origin[axis];
    stackElements(stack2, axis, otherAxis, sizeField);
    result.push([]);
    for (let elementIdx = 0; elementIdx < stack2.length; elementIdx++) {
      result[idx].push(stack2[elementIdx].element);
    }
  }
  return result;
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/wrap.js
function wrap(elements, rect) {
  return wrapElements(elements, rect, "x", "y", "width");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/v-wrap.js
function vWrap(elements, rect) {
  return wrapElements(elements, rect, "y", "x", "height");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/fit.js
function fit(element2, rect) {
  const bbox = element2.clippedBBox();
  if (bbox) {
    const elementSize3 = bbox.size;
    const rectSize = rect.size;
    if (rectSize.width < elementSize3.width || rectSize.height < elementSize3.height) {
      const scale = Math.min(rectSize.width / elementSize3.width, rectSize.height / elementSize3.height);
      const transform3 = element2.transform() || transform();
      transform3.scale(scale, scale);
      element2.transform(transform3);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/gradients/stops-array.js
var StopsArray = class extends elements_array_default {
  _change() {
    this.optionsChange({
      field: "stops"
    });
  }
};
var stops_array_default = StopsArray;

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-options.js
function optionsAccessor(name3) {
  return function(value2) {
    if (value2 !== void 0) {
      this.options.set(name3, value2);
      return this;
    }
    return this.options.get(name3);
  };
}
function defineOptionsAccessors(fn, names) {
  for (let i = 0; i < names.length; i++) {
    fn[names[i]] = optionsAccessor(names[i]);
  }
}
var withOptions = (TBase, names) => {
  const result = class extends TBase {
  };
  defineOptionsAccessors(result.prototype, names);
  return result;
};
var with_options_default = withOptions;

// node_modules/@progress/kendo-drawing/dist/es/gradients/gradient-stop.js
var options = ["offset", "color", "opacity"];
var GradientStop = class _GradientStop extends with_options_default(has_observers_default, options) {
  constructor(offset, color, opacity) {
    super();
    this.options = new options_store_default({
      offset,
      color,
      opacity: opacity !== void 0 ? opacity : 1
    });
    this.options.addObserver(this);
  }
  static create(arg) {
    if (arg !== void 0) {
      let stop;
      if (arg instanceof _GradientStop) {
        stop = arg;
      } else if (arg.length > 1) {
        stop = new _GradientStop(arg[0], arg[1], arg[2]);
      } else {
        stop = new _GradientStop(arg.offset, arg.color, arg.opacity);
      }
      return stop;
    }
  }
};
var gradient_stop_default = GradientStop;

// node_modules/@progress/kendo-drawing/dist/es/gradients/gradient.js
var Gradient = class extends has_observers_default {
  get nodeType() {
    return "Gradient";
  }
  constructor(options2 = {}) {
    super();
    this.stops = new stops_array_default(this._createStops(options2.stops));
    this.stops.addObserver(this);
    this._userSpace = options2.userSpace;
    this.id = definitionId();
  }
  userSpace(value2) {
    if (value2 !== void 0) {
      this._userSpace = value2;
      this.optionsChange();
      return this;
    }
    return this._userSpace;
  }
  _createStops(stops = []) {
    const result = [];
    for (let idx = 0; idx < stops.length; idx++) {
      result.push(gradient_stop_default.create(stops[idx]));
    }
    return result;
  }
  addStop(offset, color, opacity) {
    this.stops.push(new gradient_stop_default(offset, color, opacity));
  }
  removeStop(stop) {
    const index = this.stops.indexOf(stop);
    if (index >= 0) {
      this.stops.splice(index, 1);
    }
  }
  optionsChange(e) {
    this.trigger("optionsChange", {
      field: "gradient" + (e ? "." + e.field : ""),
      value: this
    });
  }
  geometryChange() {
    this.optionsChange();
  }
};
var gradient_default = Gradient;

// node_modules/@progress/kendo-drawing/dist/es/gradients/linear-gradient.js
var points2 = ["start", "end"];
var LinearGradient = class extends with_points_default(gradient_default, points2) {
  constructor(options2 = {}) {
    super(options2);
    this.start(options2.start || new point_default());
    this.end(options2.end || new point_default(1, 0));
  }
};
var linear_gradient_default = LinearGradient;

// node_modules/@progress/kendo-drawing/dist/es/gradients/radial-gradient.js
var RadialGradient = class extends with_points_default(gradient_default, ["center"]) {
  constructor(options2 = {}) {
    super(options2);
    this.center(options2.center || new point_default());
    this._radius = options2.radius !== void 0 ? options2.radius : 1;
    this._fallbackFill = options2.fallbackFill;
  }
  radius(value2) {
    if (value2 !== void 0) {
      this._radius = value2;
      this.geometryChange();
      return this;
    }
    return this._radius;
  }
  fallbackFill(value2) {
    if (value2 !== void 0) {
      this._fallbackFill = value2;
      this.optionsChange();
      return this;
    }
    return this._fallbackFill;
  }
};
var radial_gradient_default = RadialGradient;

// node_modules/@progress/kendo-drawing/dist/es/patterns/pattern.js
var defaultColor = "#aba4a6";
var defaultLine = { width: 2, gap: 18 };
var defaultDot = { radius: 10, gap: 10 };
var defaultGrid = { size: 18, gap: 2 };
var Pattern = class extends group_default {
  get nodeType() {
    return PATTERN;
  }
  constructor(options2) {
    super();
    const { width, height } = options2;
    this._size = size_default.create([width, height]);
    this.id = definitionId();
  }
  size(value2) {
    if (value2) {
      this._size = size_default.create(value2);
      return this;
    }
    return this._size;
  }
};
var drawBackground = (pattern, color, size2) => {
  if (color) {
    pattern.append(
      new rect_default2(new rect_default([0, 0], size2), { fill: { color }, stroke: null })
    );
  }
};
function dotsPattern(options2 = {}) {
  const { gap = defaultDot.gap, radius = defaultDot.radius, color = defaultColor, background } = options2;
  const shapeOptions = { fill: { color }, stroke: null };
  const size2 = 4 * radius + 2 * gap;
  const yC2 = 3 * radius + 1.5 * gap;
  const center1 = [size2 / 2, radius + 1 / 2 * gap];
  const center2 = [0, yC2];
  const center3 = [size2, yC2];
  const pattern = new Pattern({ width: size2, height: size2 });
  drawBackground(pattern, background, [size2, size2]);
  pattern.append(
    new circle_default2(new circle_default(center1, radius), shapeOptions),
    new circle_default2(new circle_default(center2, radius), shapeOptions),
    new circle_default2(new circle_default(center3, radius), shapeOptions)
  );
  return pattern;
}
function verticalStripesPattern(options2 = {}) {
  const { gap = defaultLine.gap, width = defaultLine.width, color = defaultColor, background } = options2;
  const size2 = width + gap;
  const shapeOptions = { fill: null, stroke: { color, width: width / 2 } };
  const pattern = new Pattern({ width: size2, height: size2 });
  drawBackground(pattern, background, [size2, size2]);
  const xStart = width / 4;
  const xEnd = size2 - width / 4;
  const startLine = new Path(shapeOptions);
  startLine.moveTo(xStart, 0).lineTo(xStart, size2);
  const endLine = new Path(shapeOptions);
  endLine.moveTo(xEnd, 0).lineTo(xEnd, size2);
  pattern.append(startLine, endLine);
  return pattern;
}
function crosshatchPattern(options2 = {}) {
  const { gap = defaultLine.gap, width = defaultLine.width, color = defaultColor, background } = options2;
  const size2 = Math.sqrt(2) * (width + gap);
  const shapeOptions = { fill: null, stroke: { color, width } };
  const pattern = new Pattern({ width: size2, height: size2 });
  drawBackground(pattern, background, [size2, size2]);
  const line1 = new Path(shapeOptions);
  line1.moveTo(0, 0).lineTo(size2, size2);
  const line2 = new Path(shapeOptions);
  line2.moveTo(size2, 0).lineTo(0, size2);
  pattern.append(line1, line2);
  return pattern;
}
function diagonalStripesPattern(options2 = {}) {
  const { gap = defaultLine.gap, width = defaultLine.width, color = defaultColor, background } = options2;
  const size2 = Math.sqrt(2) * (width + gap);
  const shapeOptions = { fill: null, stroke: { color, width, lineCap: "square" } };
  const pattern = new Pattern({ width: size2, height: size2 });
  drawBackground(pattern, background, [size2, size2]);
  const line1 = new Path(shapeOptions);
  line1.moveTo(0, size2 / 2).lineTo(size2 / 2, 0);
  const line2 = new Path(shapeOptions);
  line2.moveTo(size2 / 2, size2).lineTo(size2, size2 / 2);
  pattern.append(line1, line2);
  return pattern;
}
function gridPattern(options2 = {}) {
  const { gap = defaultGrid.gap, size: squareSize = defaultGrid.size, color = defaultColor, background } = options2;
  const size2 = squareSize + gap;
  const halfGap = gap / 2;
  const shapeOptions = { fill: { color }, stroke: null };
  const pattern = new Pattern({ width: size2, height: size2 });
  drawBackground(pattern, background, [size2, size2]);
  const rect = new rect_default2(new rect_default([halfGap, halfGap], [squareSize, squareSize]), shapeOptions);
  pattern.append(rect);
  return pattern;
}

// node_modules/@progress/kendo-drawing/dist/es/animations/easing-functions.js
var easing_functions_exports = {};
__export(easing_functions_exports, {
  easeInOutBack: () => easeInOutBack,
  easeInOutCubic: () => easeInOutCubic,
  easeInOutExpo: () => easeInOutExpo,
  easeInOutQuad: () => easeInOutQuad,
  easeInOutQuint: () => easeInOutQuint,
  easeInOutSine: () => easeInOutSine,
  easeOutBack: () => easeOutBack,
  easeOutCirc: () => easeOutCirc,
  easeOutCubic: () => easeOutCubic,
  easeOutElastic: () => easeOutElastic,
  easeOutExpo: () => easeOutExpo,
  easeOutQuad: () => easeOutQuad,
  easeOutQuint: () => easeOutQuint,
  linear: () => linear,
  swing: () => swing
});
function swing(x) {
  return 0.5 - Math.cos(x * Math.PI) / 2;
}
function linear(x) {
  return x;
}
function easeOutElastic(x) {
  if (x === 0 || x === 1) {
    return x;
  }
  const p = 0.5;
  const s = p / 4;
  return Math.pow(2, -10 * x) * Math.sin((x - s) * (1.1 * Math.PI) / p) + 1;
}
function easeOutCubic(x) {
  return 1 - Math.pow(1 - x, 3);
}
function easeInOutCubic(x) {
  return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
}
function easeOutQuad(x) {
  return 1 - Math.pow(1 - x, 2);
}
function easeInOutQuad(x) {
  return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
}
function easeOutCirc(x) {
  return Math.sqrt(1 - Math.pow(x - 1, 2));
}
function easeInOutSine(x) {
  return -(Math.cos(Math.PI * x) - 1) / 2;
}
function easeOutExpo(x) {
  return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
}
function easeInOutExpo(x) {
  if (x === 0 || x === 1) {
    return x;
  }
  return x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2;
}
function easeOutBack(x) {
  const c1 = 1.70158;
  const c3 = c1 + 1;
  return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
}
function easeInOutBack(x) {
  const c1 = 1.70158;
  const c2 = c1 * 1.525;
  return x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;
}
function easeOutQuint(x) {
  return 1 - Math.pow(1 - x, 5);
}
function easeInOutQuint(x) {
  return x < 0.5 ? 16 * Math.pow(x, 5) : 1 - Math.pow(-2 * x + 2, 5) / 2;
}

// node_modules/@progress/kendo-drawing/dist/es/animations/animation-factory.js
var instance;
var AnimationFactory = class _AnimationFactory extends Class {
  static get current() {
    if (!instance) {
      instance = new _AnimationFactory();
    }
    return instance;
  }
  constructor() {
    super();
    this._items = [];
  }
  register(name3, type) {
    this._items.push({
      name: name3,
      type
    });
  }
  create(element2, options2) {
    const items = this._items;
    let match;
    if (options2 && options2.type) {
      const type = options2.type.toLowerCase();
      for (let i = 0; i < items.length; i++) {
        if (items[i].name.toLowerCase() === type) {
          match = items[i];
          break;
        }
      }
    }
    if (match) {
      return new match.type(element2, options2);
    }
  }
};
var animation_factory_default = AnimationFactory;

// node_modules/@progress/kendo-drawing/dist/es/animations/animation.js
var Animation = class extends Class {
  static create(type, element2, options2) {
    return animation_factory_default.current.create(type, element2, options2);
  }
  get options() {
    return this._options || {
      duration: 500,
      easing: "swing"
    };
  }
  set options(value2) {
    this._options = value2;
  }
  constructor(element2, options2) {
    super();
    this.options = Object.assign({}, this.options, options2);
    this.element = element2;
  }
  setup() {
  }
  step() {
  }
  play() {
    const options2 = this.options;
    const { duration, delay = 0 } = options2;
    const easing = easing_functions_exports[options2.easing];
    const start = now_default() + delay;
    const finish = start + duration;
    if (duration === 0) {
      this.step(1);
      this.abort();
    } else {
      setTimeout(() => {
        const loop = () => {
          if (this._stopped) {
            return;
          }
          const wallTime = now_default();
          const time = limitValue(wallTime - start, 0, duration);
          const eased = easing(time / duration);
          this.step(eased);
          if (wallTime < finish) {
            animation_frame_default(loop);
          } else {
            this.abort();
          }
        };
        loop();
      }, delay);
    }
  }
  abort() {
    this._stopped = true;
  }
  destroy() {
    this.abort();
  }
};
var animation_default = Animation;

// node_modules/@progress/kendo-drawing/dist/es/parsing/path-parser.js
var instance2;
var PathParser = class _PathParser extends Class {
  static get current() {
    if (!instance2) {
      instance2 = new _PathParser();
    }
    return instance2;
  }
  parse(str, options2) {
    const multiPath = new MultiPath(options2);
    return parse_path_default(multiPath, str);
  }
};
var path_parser_default = PathParser;

// node_modules/@progress/kendo-drawing/dist/es/core/base-node.js
var BaseNode = class extends Class {
  constructor(srcElement) {
    super();
    this.childNodes = [];
    this.parent = null;
    if (srcElement) {
      this.srcElement = srcElement;
      this.observe();
    }
  }
  destroy() {
    if (this.srcElement) {
      this.srcElement.removeObserver(this);
    }
    const children = this.childNodes;
    for (let i = 0; i < children.length; i++) {
      this.childNodes[i].destroy();
    }
    this.parent = null;
  }
  load() {
  }
  observe() {
    if (this.srcElement) {
      this.srcElement.addObserver(this);
    }
  }
  append(node) {
    this.childNodes.push(node);
    node.parent = this;
  }
  insertAt(node, pos) {
    this.childNodes.splice(pos, 0, node);
    node.parent = this;
  }
  remove(index, count) {
    const end = index + count;
    for (let i = index; i < end; i++) {
      this.childNodes[i].removeSelf();
    }
    this.childNodes.splice(index, count);
  }
  removeSelf() {
    this.clear();
    this.destroy();
  }
  clear() {
    this.remove(0, this.childNodes.length);
  }
  invalidate() {
    if (this.parent) {
      this.parent.invalidate();
    }
  }
  geometryChange() {
    this.invalidate();
  }
  optionsChange() {
    this.invalidate();
  }
  childrenChange(e) {
    if (e.action === "add") {
      this.load(e.items, e.index);
    } else if (e.action === "remove") {
      this.remove(e.index, e.items.length);
    }
    this.invalidate();
  }
};
var base_node_default = BaseNode;

// node_modules/@progress/kendo-drawing/dist/es/core/surface.js
var events = [
  "click",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "resize"
];
var Surface = class extends observable_default {
  constructor(element2, options2) {
    super();
    this.options = Object.assign({}, options2);
    this.element = element2;
    this.element._kendoExportVisual = this.exportVisual.bind(this);
    this._click = this._handler("click");
    this._mouseenter = this._handler("mouseenter");
    this._mouseleave = this._handler("mouseleave");
    this._mousemove = this._handler("mousemove");
    this._visual = new group_default();
    elementSize(element2, this.options);
    this.bind(events, this.options);
    this._enableTracking();
  }
  draw(element2) {
    this._visual.children.push(element2);
  }
  clear() {
    this._visual.children = [];
  }
  destroy() {
    this._visual = null;
    this.element._kendoExportVisual = null;
    this.unbind();
  }
  eventTarget(e) {
    let domNode = eventElement(e);
    let node;
    while (!node && domNode) {
      node = domNode._kendoNode;
      if (domNode === this.element) {
        break;
      }
      domNode = domNode.parentElement;
    }
    if (node) {
      return node.srcElement;
    }
  }
  exportVisual() {
    return this._visual;
  }
  getSize() {
    return elementSize(this.element);
  }
  currentSize(size2) {
    if (size2) {
      this._size = size2;
    } else {
      return this._size;
    }
  }
  setSize(size2) {
    elementSize(this.element, size2);
    this.currentSize(size2);
    this._resize();
  }
  resize(force) {
    const size2 = this.getSize();
    const currentSize = this.currentSize();
    if (force || (size2.width > 0 || size2.height > 0) && (!currentSize || size2.width !== currentSize.width || size2.height !== currentSize.height)) {
      this.currentSize(size2);
      this._resize(size2, force);
      this.trigger("resize", size2);
    }
  }
  size(value2) {
    if (!value2) {
      return this.getSize();
    }
    this.setSize(value2);
  }
  suspendTracking() {
    this._suspendedTracking = true;
  }
  resumeTracking() {
    this._suspendedTracking = false;
  }
  _enableTracking() {
  }
  _resize() {
  }
  _handler(eventName) {
    return (e) => {
      const node = this.eventTarget(e);
      if (node && !this._suspendedTracking) {
        this.trigger(eventName, {
          element: node,
          originalEvent: e,
          type: eventName
        });
      }
    };
  }
  _elementOffset() {
    const element2 = this.element;
    const padding = elementPadding(element2);
    const { left, top } = elementOffset(element2);
    return {
      left: left + padding.left,
      top: top + padding.top
    };
  }
  _surfacePoint(e) {
    const offset = this._elementOffset();
    const coord = eventCoordinates(e);
    const x = coord.x - offset.left;
    const y = coord.y - offset.top;
    const inverseTransform = elementScale(this.element).invert();
    const point2 = new point_default(
      x,
      y
    ).transform(inverseTransform);
    return point2;
  }
};
var surface_default = Surface;

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-attribute.js
function renderAttr(name3, value2) {
  return value2 !== void 0 && value2 !== null ? ` ${name3}="${value2}" ` : "";
}

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-all-attributes.js
function renderAllAttr(attrs) {
  let output = "";
  for (let i = 0; i < attrs.length; i++) {
    output += renderAttr(attrs[i][0], attrs[i][1]);
  }
  return output;
}

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-style.js
function renderStyle(attrs) {
  let output = "";
  for (let i = 0; i < attrs.length; i++) {
    let value2 = attrs[i][1];
    if (value2 !== void 0) {
      output += attrs[i][0] + ":" + value2 + ";";
    }
  }
  if (output !== "") {
    return output;
  }
}

// node_modules/@progress/kendo-drawing/dist/es/svg/node-map.js
var NODE_MAP = {};
var node_map_default = NODE_MAP;

// node_modules/@progress/kendo-drawing/dist/es/svg/constants.js
var SVG_NS = "http://www.w3.org/2000/svg";
var NONE = "none";
var POINT_DIGITS = 3;

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-svg.js
var renderUsingInnerHTML = (container, svg) => {
  setInnerHTML(container, svg);
};
var renderUsingDOMParser = (container, svg) => {
  const parser = new DOMParser();
  const chartDoc = parser.parseFromString(replaceStyleAttr(svg), "text/xml");
  restoreStyleAttr(chartDoc);
  const importedDoc = document.adoptNode(chartDoc.documentElement);
  container.innerHTML = "";
  container.appendChild(importedDoc);
};
var implementation;
var renderSVG = (container, svg) => {
  if (implementation) {
    return implementation(container, svg);
  }
  implementation = renderUsingInnerHTML;
  if (typeof document !== "undefined") {
    const testFragment = "<svg xmlns='" + SVG_NS + "'></svg>";
    const testContainer = document.createElement("div");
    const hasParser = typeof DOMParser !== "undefined";
    testContainer.innerHTML = testFragment;
    if (hasParser && testContainer.firstChild.namespaceURI !== SVG_NS) {
      implementation = renderUsingDOMParser;
    }
  }
  return implementation(container, svg);
};
var render_svg_default = renderSVG;

// node_modules/@progress/kendo-drawing/dist/es/svg/node.js
var TRANSFORM = "transform";
var DefinitionMap = {
  clip: "clip-path",
  fill: "fill"
};
function isDefinition(type, value2) {
  return type === "clip" || type === "fill" && (!value2 || value2.nodeType === "Gradient" || value2.nodeType === PATTERN);
}
var Node = class extends base_node_default {
  constructor(srcElement, options2) {
    super(srcElement);
    this.definitions = {};
    this.options = options2;
  }
  destroy() {
    if (this.element) {
      this.element._kendoNode = null;
      this.element = null;
    }
    this.clearDefinitions();
    super.destroy();
  }
  load(elements, pos) {
    for (let i = 0; i < elements.length; i++) {
      const srcElement = elements[i];
      const children = srcElement.children;
      const childNode = new node_map_default[srcElement.nodeType](srcElement, this.options);
      if (pos !== void 0) {
        this.insertAt(childNode, pos);
      } else {
        this.append(childNode);
      }
      childNode.createDefinitions();
      if (children && children.length > 0) {
        childNode.load(children);
      }
      const element2 = this.element;
      if (element2) {
        childNode.attachTo(element2, pos);
      }
    }
  }
  root() {
    let root = this;
    while (root.parent) {
      root = root.parent;
    }
    return root;
  }
  attachTo(domElement, pos) {
    const container = document.createElement("div");
    render_svg_default(
      container,
      "<svg xmlns='" + SVG_NS + "' version='1.1'>" + this.render() + "</svg>"
    );
    const element2 = container.firstChild.firstChild;
    if (element2) {
      if (pos !== void 0) {
        domElement.insertBefore(element2, domElement.childNodes[pos] || null);
      } else {
        domElement.appendChild(element2);
      }
      this.setElement(element2);
    }
  }
  setElement(element2) {
    if (this.element) {
      this.element._kendoNode = null;
    }
    this.element = element2;
    this.element._kendoNode = this;
    const nodes = this.childNodes;
    for (let i = 0; i < nodes.length; i++) {
      let childElement = element2.childNodes[i];
      nodes[i].setElement(childElement);
    }
  }
  clear() {
    this.clearDefinitions();
    if (this.element) {
      this.element.innerHTML = "";
    }
    const children = this.childNodes;
    for (let i = 0; i < children.length; i++) {
      children[i].destroy();
    }
    this.childNodes = [];
  }
  removeSelf() {
    if (this.element) {
      const parentNode = this.element.parentNode;
      if (parentNode) {
        parentNode.removeChild(this.element);
      }
      this.element = null;
    }
    super.removeSelf();
  }
  template() {
    return this.renderChildren();
  }
  render() {
    return this.template();
  }
  renderChildren() {
    const nodes = this.childNodes;
    let output = "";
    for (let i = 0; i < nodes.length; i++) {
      output += nodes[i].render();
    }
    return output;
  }
  optionsChange(e) {
    const { field, value: value2 } = e;
    if (field === "visible") {
      this.css("display", value2 ? "" : NONE);
    } else if (DefinitionMap[field] && isDefinition(field, value2)) {
      this.updateDefinition(field, value2);
    } else if (field === "opacity") {
      this.attr("opacity", value2);
    } else if (field === "cursor") {
      this.css("cursor", value2);
    } else if (field === "id") {
      if (value2) {
        this.attr("id", value2);
      } else {
        this.removeAttr("id");
      }
    }
    super.optionsChange(e);
  }
  accessibilityOptionsChange(e) {
    const { field, value: value2 } = e;
    if (field === "role") {
      if (value2) {
        this.attr("role", value2);
      } else {
        this.removeAttr("role");
      }
    } else if (field === "ariaLabel") {
      if (value2) {
        this.attr("aria-label", htmlEncode(value2));
      } else {
        this.removeAttr("aria-label");
      }
    } else if (field === "ariaRoleDescription") {
      if (value2) {
        this.attr("aria-roledescription", htmlEncode(value2));
      } else {
        this.removeAttr("aria-roledescription");
      }
    } else if (field === "ariaChecked") {
      if (value2 !== void 0) {
        this.attr("aria-checked", value2);
      } else {
        this.removeAttr("aria-checked");
      }
    } else if (field === "className") {
      this.className(value2);
    }
  }
  attr(name3, value2) {
    if (this.element) {
      this.element.setAttribute(name3, value2);
    }
  }
  allAttr(attrs) {
    for (let i = 0; i < attrs.length; i++) {
      this.attr(attrs[i][0], attrs[i][1]);
    }
  }
  toggleAttr(name3, value2) {
    if (value2) {
      this.attr(name3, value2);
    } else {
      this.removeAttr(name3);
    }
  }
  css(name3, value2) {
    if (this.element) {
      this.element.style[name3] = value2;
    }
  }
  allCss(styles4) {
    for (let i = 0; i < styles4.length; i++) {
      this.css(styles4[i][0], styles4[i][1]);
    }
  }
  className(value2) {
    if (this.element) {
      this.element.classList.remove(...this.element.classList);
      value2.split(" ").forEach((item) => {
        this.element.classList.add(item);
      });
    }
  }
  removeAttr(name3) {
    if (this.element) {
      this.element.removeAttribute(name3);
    }
  }
  mapTransform(transform3) {
    const attrs = [];
    if (transform3) {
      attrs.push([
        TRANSFORM,
        "matrix(" + transform3.matrix().toString(6) + ")"
      ]);
    }
    return attrs;
  }
  renderTransform() {
    return renderAllAttr(
      this.mapTransform(this.srcElement.transform())
    );
  }
  transformChange(value2) {
    if (value2) {
      this.allAttr(this.mapTransform(value2));
    } else {
      this.removeAttr(TRANSFORM);
    }
  }
  mapStyle() {
    const options2 = this.srcElement.options;
    const style = [["cursor", options2.cursor]];
    if (options2.visible === false) {
      style.push(["display", NONE]);
    }
    return style;
  }
  renderStyle() {
    return renderAttr("style", renderStyle(this.mapStyle(true)));
  }
  renderOpacity() {
    return renderAttr("opacity", this.srcElement.options.opacity);
  }
  renderId() {
    return renderAttr("id", this.srcElement.options.id);
  }
  renderClassName() {
    return renderAttr("class", this.srcElement.options.className);
  }
  renderRole() {
    return renderAttr("role", this.srcElement.options.role);
  }
  renderAriaLabel() {
    let value2 = this.srcElement.options.ariaLabel;
    if (value2) {
      value2 = htmlEncode(value2);
    }
    return renderAttr("aria-label", value2);
  }
  renderAriaRoleDescription() {
    let value2 = this.srcElement.options.ariaRoleDescription;
    if (value2) {
      value2 = htmlEncode(value2);
    }
    return renderAttr("aria-roledescription", value2);
  }
  renderAriaChecked() {
    return renderAttr("aria-checked", this.srcElement.options.ariaChecked);
  }
  createDefinitions() {
    const srcElement = this.srcElement;
    const definitions = this.definitions;
    if (srcElement) {
      const options2 = srcElement.options;
      let hasDefinitions;
      for (let field in DefinitionMap) {
        let definition = options2.get(field);
        if (definition && isDefinition(field, definition)) {
          definitions[field] = definition;
          hasDefinitions = true;
        }
      }
      if (hasDefinitions) {
        this.definitionChange({
          action: "add",
          definitions
        });
      }
    }
  }
  definitionChange(e) {
    if (this.parent) {
      this.parent.definitionChange(e);
    }
  }
  updateDefinition(type, value2) {
    const definitions = this.definitions;
    const current = definitions[type];
    const attr = DefinitionMap[type];
    const definition = {};
    if (current) {
      definition[type] = current;
      this.definitionChange({
        action: "remove",
        definitions: definition
      });
      delete definitions[type];
    }
    if (!value2) {
      if (current) {
        this.removeAttr(attr);
      }
    } else {
      definition[type] = value2;
      this.definitionChange({
        action: "add",
        definitions: definition
      });
      definitions[type] = value2;
      this.attr(attr, this.refUrl(value2.id));
    }
  }
  clearDefinitions() {
    const definitions = this.definitions;
    this.definitionChange({
      action: "remove",
      definitions
    });
    this.definitions = {};
  }
  renderDefinitions() {
    return renderAllAttr(this.mapDefinitions());
  }
  mapDefinitions() {
    const definitions = this.definitions;
    const attrs = [];
    for (let field in definitions) {
      const value2 = definitions[field];
      attrs.push([DefinitionMap[field], this.refUrl(value2.id)]);
    }
    return attrs;
  }
  refUrl(id) {
    return `url(#${id})`;
  }
};
var node_default = Node;

// node_modules/@progress/kendo-drawing/dist/es/svg/gradient-stop-node.js
var GradientStopNode = class extends node_default {
  template() {
    return `<stop ${this.renderOffset()} ${this.renderStyle()} />`;
  }
  renderOffset() {
    return renderAttr("offset", this.srcElement.offset());
  }
  mapStyle() {
    const srcElement = this.srcElement;
    return [
      ["stop-color", srcElement.color()],
      ["stop-opacity", srcElement.opacity()]
    ];
  }
  optionsChange(e) {
    if (e.field === "offset") {
      this.attr(e.field, e.value);
    } else if (e.field === "color" || e.field === "opacity") {
      this.css("stop-" + e.field, e.value);
    }
  }
};
var gradient_stop_node_default = GradientStopNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/gradient-node.js
var GradientNode = class extends node_default {
  constructor(srcElement) {
    super(srcElement);
    this.id = srcElement.id;
    this.loadStops();
  }
  loadStops() {
    const stops = this.srcElement.stops;
    const element2 = this.element;
    for (let idx = 0; idx < stops.length; idx++) {
      let stopNode = new gradient_stop_node_default(stops[idx]);
      this.append(stopNode);
      if (element2) {
        stopNode.attachTo(element2);
      }
    }
  }
  optionsChange(e) {
    if (e.field === "gradient.stops") {
      base_node_default.prototype.clear.call(this);
      this.loadStops();
    } else if (e.field === "gradient") {
      this.allAttr(this.mapCoordinates());
    }
  }
  renderCoordinates() {
    return renderAllAttr(this.mapCoordinates());
  }
  mapSpace() {
    return ["gradientUnits", this.srcElement.userSpace() ? "userSpaceOnUse" : "objectBoundingBox"];
  }
};
var gradient_node_default = GradientNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/linear-gradient-node.js
var LinearGradientNode = class extends gradient_node_default {
  template() {
    return `<linearGradient id='${this.id}' ${this.renderCoordinates()}>${this.renderChildren()}</linearGradient>`;
  }
  mapCoordinates() {
    const srcElement = this.srcElement;
    const start = srcElement.start();
    const end = srcElement.end();
    const attrs = [
      ["x1", start.x],
      ["y1", start.y],
      ["x2", end.x],
      ["y2", end.y],
      this.mapSpace()
    ];
    return attrs;
  }
};
var linear_gradient_node_default = LinearGradientNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/radial-gradient-node.js
var RadialGradientNode = class extends gradient_node_default {
  template() {
    return `<radialGradient id='${this.id}' ${this.renderCoordinates()}>${this.renderChildren()}</radialGradient>`;
  }
  mapCoordinates() {
    const srcElement = this.srcElement;
    const center = srcElement.center();
    const radius = srcElement.radius();
    const attrs = [
      ["cx", center.x],
      ["cy", center.y],
      ["r", radius],
      this.mapSpace()
    ];
    return attrs;
  }
};
var radial_gradient_node_default = RadialGradientNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/pattern-node.js
var PatternNode = class extends node_default {
  constructor(pattern) {
    super(pattern);
    this.id = pattern.id;
    this.load(pattern.children);
  }
  template() {
    const width = this.srcElement.size().getWidth();
    const height = this.srcElement.size().getHeight();
    return `<pattern id='${this.srcElement.id}' width='${width}' height='${height}' patternUnits='userSpaceOnUse'>${this.renderChildren()}</pattern>`;
  }
};

// node_modules/@progress/kendo-drawing/dist/es/svg/clip-node.js
var ClipNode = class extends node_default {
  constructor(srcElement) {
    super();
    this.srcElement = srcElement;
    this.id = srcElement.id;
    this.load([srcElement]);
  }
  renderClipRule() {
    return renderAttr("clip-rule", "evenodd");
  }
  template() {
    return `<clipPath ${this.renderClipRule()} id='${this.id}'>${this.renderChildren()}</clipPath>`;
  }
};
var clip_node_default = ClipNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/definition-node.js
var DefinitionNode = class extends node_default {
  constructor() {
    super();
    this.definitionMap = {};
  }
  attachTo(domElement) {
    this.element = domElement;
  }
  template() {
    return `<defs>${this.renderChildren()}</defs>`;
  }
  definitionChange(e) {
    const { definitions, action } = e;
    if (action === "add") {
      this.addDefinitions(definitions);
    } else if (action === "remove") {
      this.removeDefinitions(definitions);
    }
  }
  createDefinition(type, item) {
    let nodeType;
    if (type === "clip") {
      nodeType = clip_node_default;
    } else if (type === "fill") {
      if (item instanceof linear_gradient_default) {
        nodeType = linear_gradient_node_default;
      } else if (item instanceof radial_gradient_default) {
        nodeType = radial_gradient_node_default;
      } else if (item.nodeType === PATTERN) {
        nodeType = PatternNode;
      }
    }
    return new nodeType(item);
  }
  addDefinitions(definitions) {
    for (let field in definitions) {
      this.addDefinition(field, definitions[field]);
    }
  }
  addDefinition(type, srcElement) {
    const { element: element2, definitionMap } = this;
    const id = srcElement.id;
    const mapItem = definitionMap[id];
    if (!mapItem) {
      const node = this.createDefinition(type, srcElement);
      definitionMap[id] = {
        element: node,
        count: 1
      };
      this.append(node);
      if (element2) {
        node.attachTo(this.element);
      }
    } else {
      mapItem.count++;
    }
  }
  removeDefinitions(definitions) {
    for (let field in definitions) {
      this.removeDefinition(definitions[field]);
    }
  }
  removeDefinition(srcElement) {
    const definitionMap = this.definitionMap;
    const id = srcElement.id;
    const mapItem = definitionMap[id];
    if (mapItem) {
      mapItem.count--;
      if (mapItem.count === 0) {
        this.remove(this.childNodes.indexOf(mapItem.element), 1);
        delete definitionMap[id];
      }
    }
  }
};
var definition_node_default = DefinitionNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/root-node.js
var RootNode = class extends node_default {
  constructor(options2) {
    super();
    this.options = options2;
    this.defs = new definition_node_default();
  }
  attachTo(domElement) {
    this.element = domElement;
    this.defs.attachTo(domElement.firstElementChild);
  }
  clear() {
    base_node_default.prototype.clear.call(this);
  }
  template() {
    return this.defs.render() + this.renderChildren();
  }
  definitionChange(e) {
    this.defs.definitionChange(e);
  }
};
var root_node_default = RootNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/path-node.js
var ATTRIBUTE_MAP = {
  "fill.opacity": "fill-opacity",
  "stroke.color": "stroke",
  "stroke.width": "stroke-width",
  "stroke.opacity": "stroke-opacity"
};
var PathNode = class extends node_default {
  geometryChange() {
    this.attr("d", this.renderData());
    this.invalidate();
  }
  optionsChange(e) {
    switch (e.field) {
      case "fill":
        if (e.value) {
          this.allAttr(this.mapFill(e.value));
        } else {
          this.removeAttr("fill");
        }
        break;
      case "fill.color":
        this.allAttr(this.mapFill({ color: e.value }));
        break;
      case "stroke":
        if (e.value) {
          this.allAttr(this.mapStroke(e.value));
        } else {
          this.removeAttr("stroke");
        }
        break;
      case "transform":
        this.transformChange(e.value);
        break;
      default: {
        const name3 = ATTRIBUTE_MAP[e.field];
        if (name3) {
          this.attr(name3, e.value);
        }
        break;
      }
    }
    this.accessibilityOptionsChange(e);
    super.optionsChange(e);
  }
  content() {
    if (this.element) {
      this.element.textContent = this.srcElement.content();
    }
  }
  renderData() {
    return this.srcElement.toString(POINT_DIGITS) || void 0;
  }
  mapStroke(stroke) {
    const attrs = [];
    if (stroke && !isTransparent(stroke.color)) {
      attrs.push(["stroke", stroke.color]);
      attrs.push(["stroke-width", stroke.width]);
      attrs.push(["stroke-linecap", this.renderLinecap(stroke)]);
      attrs.push(["stroke-linejoin", stroke.lineJoin]);
      if (stroke.opacity !== void 0) {
        attrs.push(["stroke-opacity", stroke.opacity]);
      }
      if (stroke.dashType !== void 0) {
        attrs.push(["stroke-dasharray", this.renderDashType(stroke)]);
      }
    } else {
      attrs.push(["stroke", NONE]);
    }
    return attrs;
  }
  renderStroke() {
    return renderAllAttr(
      this.mapStroke(this.srcElement.options.stroke)
    );
  }
  renderDashType(stroke) {
    const { dashType, width = 1 } = stroke;
    if (dashType && dashType !== SOLID) {
      const dashArray = DASH_ARRAYS[dashType.toLowerCase()];
      const result = [];
      for (let i = 0; i < dashArray.length; i++) {
        result.push(dashArray[i] * width);
      }
      return result.join(" ");
    }
  }
  renderLinecap(stroke) {
    const { dashType, lineCap } = stroke;
    return dashType && dashType !== SOLID ? BUTT : lineCap;
  }
  mapFill(fill) {
    const attrs = [];
    if (!(fill && (fill.nodeType === "Gradient" || fill.nodeType === PATTERN))) {
      if (fill && !isTransparent(fill.color)) {
        attrs.push(["fill", fill.color]);
        if (fill.opacity !== void 0) {
          attrs.push(["fill-opacity", fill.opacity]);
        }
      } else {
        attrs.push(["fill", NONE]);
      }
    }
    return attrs;
  }
  renderFill() {
    return renderAllAttr(
      this.mapFill(this.srcElement.options.fill)
    );
  }
  template() {
    return `<path ${this.renderId()} ${this.renderStyle()} ${this.renderOpacity()} ${renderAttr("d", this.renderData())}${this.renderStroke()}${this.renderFill()}${this.renderDefinitions()}${this.renderTransform()}${this.renderClassName()} ${this.renderRole()}${this.renderAriaLabel()} ${this.renderAriaRoleDescription()}${this.renderAriaChecked()} ></path>`;
  }
};
var path_node_default = PathNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/arc-node.js
var ArcNode = class extends path_node_default {
  renderData() {
    return this.srcElement.toPath().toString(POINT_DIGITS);
  }
};
var arc_node_default = ArcNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/circle-node.js
var CircleNode = class extends path_node_default {
  geometryChange() {
    const center = this.center();
    this.attr("cx", center.x);
    this.attr("cy", center.y);
    this.attr("r", this.radius());
    this.invalidate();
  }
  center() {
    return this.srcElement.geometry().center;
  }
  radius() {
    return this.srcElement.geometry().radius;
  }
  template() {
    return `<circle ${this.renderId()} ${this.renderStyle()} ${this.renderOpacity()}cx='${this.center().x}' cy='${this.center().y}' r='${this.radius()}'${this.renderStroke()} ${this.renderFill()} ${this.renderDefinitions()}${this.renderClassName()} ${this.renderRole()}${this.renderAriaLabel()} ${this.renderAriaRoleDescription()}${this.renderAriaChecked()} ${this.renderTransform()} ></circle>`;
  }
};
var circle_node_default = CircleNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/group-node.js
var GroupNode = class extends node_default {
  template() {
    return `<g${this.renderId() + this.renderTransform() + this.renderClassName() + this.renderStyle() + this.renderOpacity() + this.renderRole() + this.renderAriaLabel() + this.renderAriaRoleDescription() + this.renderAriaChecked() + this.renderDefinitions()}>${this.renderChildren()}</g>`;
  }
  optionsChange(e) {
    const { field, value: value2 } = e;
    if (field === "transform") {
      this.transformChange(value2);
    }
    this.accessibilityOptionsChange(e);
    super.optionsChange(e);
  }
};
var group_node_default = GroupNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/image-node.js
var ImageNode = class extends path_node_default {
  geometryChange() {
    this.allAttr(this.mapPosition());
    this.invalidate();
  }
  optionsChange(e) {
    if (e.field === "src") {
      this.allAttr(this.mapSource());
    }
    super.optionsChange(e);
  }
  mapPosition() {
    const rect = this.srcElement.rect();
    const tl = rect.topLeft();
    return [
      ["x", tl.x],
      ["y", tl.y],
      ["width", rect.width() + "px"],
      ["height", rect.height() + "px"]
    ];
  }
  renderPosition() {
    return renderAllAttr(this.mapPosition());
  }
  mapSource(encode) {
    let src = this.srcElement.src();
    if (encode) {
      src = htmlEncode(src);
    }
    return [["xlink:href", src]];
  }
  renderSource() {
    return renderAllAttr(this.mapSource(true));
  }
  template() {
    return `<image preserveAspectRatio='none' ${this.renderId()} ${this.renderStyle()} ${this.renderTransform()} ${this.renderOpacity()}${this.renderPosition()} ${this.renderSource()} ${this.renderDefinitions()}${this.renderClassName()} ${this.renderRole()}${this.renderAriaLabel()} ${this.renderAriaRoleDescription()}${this.renderAriaChecked()} ></image>`;
  }
};
var image_node_default = ImageNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/multi-path-node.js
var MultiPathNode = class extends path_node_default {
  renderData() {
    return this.srcElement.toString(POINT_DIGITS) || "undefined";
  }
};
var multi_path_node_default = MultiPathNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/rect-node.js
var RectNode = class extends path_node_default {
  geometryChange() {
    const geometry = this.srcElement.geometry();
    this.attr("x", geometry.origin.x);
    this.attr("y", geometry.origin.y);
    this.attr("width", geometry.size.width);
    this.attr("height", geometry.size.height);
    this.attr("rx", geometry.cornerRadius[0]);
    this.attr("ry", geometry.cornerRadius[1]);
    this.invalidate();
  }
  size() {
    return this.srcElement.geometry().size;
  }
  origin() {
    return this.srcElement.geometry().origin;
  }
  rx() {
    return this.srcElement.geometry().cornerRadius[0];
  }
  ry() {
    return this.srcElement.geometry().cornerRadius[1];
  }
  template() {
    return `<rect ${this.renderId()} ${this.renderStyle()} ${this.renderOpacity()} x='${this.origin().x}' y='${this.origin().y}' rx='${this.rx()}' ry='${this.ry()}' width='${this.size().width}' height='${this.size().height}' ${this.renderStroke()} ${this.renderFill()} ${this.renderDefinitions()} ${this.renderTransform()}${this.renderClassName()} ${this.renderRole()}${this.renderAriaLabel()} ${this.renderAriaRoleDescription()}${this.renderAriaChecked()} />`;
  }
};
var rect_node_default = RectNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/text-node.js
var ENTITY_REGEX = /&(?:[a-zA-Z]+|#\d+);/g;
function decodeEntities(text) {
  if (!text || typeof text !== "string" || !ENTITY_REGEX.test(text)) {
    return text;
  }
  const element2 = decodeEntities._element;
  ENTITY_REGEX.lastIndex = 0;
  return text.replace(ENTITY_REGEX, (match) => {
    element2.innerHTML = match;
    return element2.textContent || element2.innerText;
  });
}
if (typeof document !== "undefined") {
  decodeEntities._element = document.createElement("span");
}
var TextNode = class extends path_node_default {
  geometryChange() {
    const pos = this.pos();
    this.attr("x", pos.x);
    this.attr("y", pos.y);
    this.invalidate();
  }
  optionsChange(e) {
    if (e.field === "font") {
      this.attr("style", renderStyle(this.mapStyle()));
      this.geometryChange();
    } else if (e.field === "content") {
      super.content(this.srcElement.content());
    }
    super.optionsChange(e);
  }
  mapStyle(encode) {
    const style = super.mapStyle(encode);
    let font = this.srcElement.options.font;
    if (encode) {
      font = htmlEncode(font);
    }
    style.push(["font", font], ["white-space", "pre"]);
    return style;
  }
  pos() {
    const pos = this.srcElement.position();
    const size2 = this.srcElement.measure();
    return pos.clone().setY(pos.y + size2.baseline);
  }
  renderContent() {
    let content = this.srcElement.content();
    content = decodeEntities(content);
    content = htmlEncode(content);
    return normalizeText(content);
  }
  renderTextAnchor() {
    let anchor;
    if ((this.options || {}).rtl && !(support_default.browser.msie || support_default.browser.edge)) {
      anchor = "end";
    }
    return renderAttr("text-anchor", anchor);
  }
  renderPaintOrder() {
    const paintOrder = this.srcElement.options.paintOrder;
    return paintOrder ? renderAttr("paint-order", paintOrder) : "";
  }
  template() {
    return `<text ${this.renderId()} ${this.renderTextAnchor()} ${this.renderStyle()} ${this.renderOpacity()}x='${this.pos().x}' y='${this.pos().y}' ${this.renderStroke()} ${this.renderTransform()} ${this.renderDefinitions()}${this.renderPaintOrder()}${this.renderFill()}${this.renderClassName()} ${this.renderRole()}${this.renderAriaLabel()} ${this.renderAriaRoleDescription()}${this.renderAriaChecked()}>${this.renderContent()}</text>`;
  }
};
var text_node_default = TextNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/surface.js
node_map_default.Arc = arc_node_default;
node_map_default.Circle = circle_node_default;
node_map_default.Group = group_node_default;
node_map_default.Image = image_node_default;
node_map_default.MultiPath = multi_path_node_default;
node_map_default.Path = path_node_default;
node_map_default.Rect = rect_node_default;
node_map_default.Text = text_node_default;
var RTL = "rtl";
function alignToScreen(element2) {
  let ctm;
  try {
    ctm = element2.getScreenCTM ? element2.getScreenCTM() : null;
  } catch (e) {
  }
  if (ctm) {
    const left = -ctm.e % 1;
    const top = -ctm.f % 1;
    const style = element2.style;
    if (left !== 0 || top !== 0) {
      style.left = left + "px";
      style.top = top + "px";
    }
  }
}
var Surface2 = class extends surface_default {
  get type() {
    return "svg";
  }
  constructor(element2, options2) {
    super(element2, options2);
    this._root = new root_node_default(Object.assign({
      rtl: elementStyles(element2, "direction").direction === RTL
    }, this.options));
    render_svg_default(this.element, this._template(""));
    this._rootElement = this.element.firstElementChild;
    this._rootElement.style.width = "100%";
    this._rootElement.style.height = "100%";
    this._rootElement.style.overflow = "hidden";
    alignToScreen(this._rootElement);
    this._root.attachTo(this._rootElement);
    bindEvents(this.element, {
      click: this._click,
      mouseover: this._mouseenter,
      mouseout: this._mouseleave,
      mousemove: this._mousemove
    });
    this.resize();
  }
  destroy() {
    if (this._root) {
      this._root.destroy();
      this._root = null;
      this._rootElement = null;
      unbindEvents(this.element, {
        click: this._click,
        mouseover: this._mouseenter,
        mouseout: this._mouseleave,
        mousemove: this._mousemove
      });
    }
    super.destroy();
  }
  translate(offset) {
    const viewBox = `${Math.round(offset.x)} ${Math.round(offset.y)} ${this._size.width} ${this._size.height}`;
    this._offset = offset;
    this._rootElement.setAttribute("viewBox", viewBox);
  }
  draw(element2) {
    super.draw(element2);
    this._root.load([element2]);
  }
  clear() {
    super.clear();
    this._root.clear();
  }
  svg() {
    return "<?xml version='1.0' ?>" + this._template();
  }
  exportVisual() {
    let { _visual: visual, _offset: offset } = this;
    if (offset) {
      const wrap2 = new group_default();
      wrap2.children.push(visual);
      wrap2.transform(
        transform().translate(-offset.x, -offset.y)
      );
      visual = wrap2;
    }
    return visual;
  }
  _resize() {
    if (this._offset) {
      this.translate(this._offset);
    }
  }
  _template(svgStyles) {
    const styles4 = typeof svgStyles === "string" ? svgStyles : "style='width: 100%; height: 100%; overflow: hidden;' ";
    return `<svg ${styles4}xmlns='${SVG_NS}' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>${this._root.render()}</svg>`;
  }
};
var surface_default2 = Surface2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/node-map.js
var NODE_MAP2 = {};
var node_map_default2 = NODE_MAP2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/node.js
var Node2 = class extends base_node_default {
  constructor(srcElement) {
    super(srcElement);
    if (srcElement) {
      this.initClip();
    }
  }
  initClip() {
    const clip = this.srcElement.clip();
    if (clip) {
      this.clip = clip;
      clip.addObserver(this);
    }
  }
  clear() {
    if (this.srcElement) {
      this.srcElement.removeObserver(this);
    }
    this.clearClip();
    super.clear();
  }
  clearClip() {
    if (this.clip) {
      this.clip.removeObserver(this);
      delete this.clip;
    }
  }
  setClip(ctx) {
    if (this.clip) {
      ctx.beginPath();
      const clipNode = new node_map_default2[this.clip.nodeType](this.clip);
      clipNode.renderPoints(ctx, this.clip);
      ctx.clip("evenodd");
    }
  }
  optionsChange(e) {
    if (e.field === "clip") {
      this.clearClip();
      this.initClip();
    }
    super.optionsChange(e);
  }
  setTransform(ctx) {
    if (this.srcElement) {
      const transform3 = this.srcElement.transform();
      if (transform3) {
        ctx.transform.apply(ctx, transform3.matrix().toArray(6));
      }
    }
  }
  loadElements(elements, pos, cors) {
    for (let i = 0; i < elements.length; i++) {
      let srcElement = elements[i];
      let children = srcElement.children;
      let childNode = new node_map_default2[srcElement.nodeType](srcElement, cors);
      if (children && children.length > 0) {
        childNode.load(children, pos, cors);
      }
      if (pos !== void 0) {
        this.insertAt(childNode, pos);
      } else {
        this.append(childNode);
      }
    }
  }
  load(elements, pos, cors) {
    this.loadElements(elements, pos, cors);
    this.invalidate();
  }
  setOpacity(ctx) {
    if (this.srcElement) {
      const opacity = this.srcElement.opacity();
      if (opacity !== void 0) {
        this.globalAlpha(ctx, opacity);
      }
    }
  }
  globalAlpha(ctx, value2) {
    let opactity = value2;
    if (opactity && ctx.globalAlpha) {
      opactity *= ctx.globalAlpha;
    }
    ctx.globalAlpha = opactity;
  }
  visible() {
    const src = this.srcElement;
    return !src || src && src.options.visible !== false;
  }
};
var node_default2 = Node2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/group-node.js
var GroupNode2 = class extends traversable_default(node_default2, "childNodes") {
  renderTo(ctx) {
    if (!this.visible()) {
      return;
    }
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    const childNodes = this.childNodes;
    for (let i = 0; i < childNodes.length; i++) {
      let child = childNodes[i];
      if (child.visible()) {
        child.renderTo(ctx);
      }
    }
    ctx.restore();
  }
};
var group_node_default2 = GroupNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/root-node.js
var FRAME_DELAY = 1e3 / 60;
var RootNode2 = class extends traversable_default(group_node_default2, "childNodes") {
  constructor(canvas, size2) {
    super();
    this.canvas = canvas;
    this.size = size2;
    this.ctx = canvas.getContext("2d");
    const invalidateHandler = this._invalidate.bind(this);
    this.invalidate = throttle(() => {
      animation_frame_default(invalidateHandler);
    }, FRAME_DELAY);
  }
  destroy() {
    super.destroy();
    this.canvas = null;
    this.ctx = null;
  }
  load(elements, pos, cors) {
    this.loadElements(elements, pos, cors);
    this._invalidate();
  }
  _rescale(scale) {
    const { canvas, size: size2 } = this;
    canvas.width = size2.width * scale;
    canvas.height = size2.height * scale;
    this.ctx.scale(scale, scale);
  }
  _devicePixelRatio() {
    if (typeof window.devicePixelRatio === "number") {
      return window.devicePixelRatio;
    }
    return 1;
  }
  _invalidate(options2) {
    if (!this.ctx) {
      return;
    }
    const fixedScale = options2 && options2.fixedScale;
    const scale = fixedScale ? 1 : this._devicePixelRatio();
    this._rescale(scale);
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.renderTo(this.ctx);
  }
};
var root_node_default2 = RootNode2;

// node_modules/@progress/kendo-drawing/dist/es/search/quad-root.js
var QuadRoot = class extends Class {
  constructor() {
    super();
    this.shapes = [];
  }
  _add(shape, bbox) {
    this.shapes.push({
      bbox,
      shape
    });
    shape._quadNode = this;
  }
  pointShapes(point2) {
    const shapes = this.shapes;
    const length = shapes.length;
    const result = [];
    for (let idx = 0; idx < length; idx++) {
      if (shapes[idx].bbox.containsPoint(point2)) {
        result.push(shapes[idx].shape);
      }
    }
    return result;
  }
  insert(shape, bbox) {
    this._add(shape, bbox);
  }
  remove(shape) {
    const shapes = this.shapes;
    const length = shapes.length;
    for (let idx = 0; idx < length; idx++) {
      if (shapes[idx].shape === shape) {
        shapes.splice(idx, 1);
        break;
      }
    }
  }
};
var quad_root_default = QuadRoot;

// node_modules/@progress/kendo-drawing/dist/es/search/quad-node.js
var QuadNode = class _QuadNode extends quad_root_default {
  constructor(rect) {
    super();
    this.children = [];
    this.rect = rect;
  }
  inBounds(rect) {
    const nodeRect = this.rect;
    const nodeBottomRight = nodeRect.bottomRight();
    const bottomRight = rect.bottomRight();
    const inBounds = nodeRect.origin.x <= rect.origin.x && nodeRect.origin.y <= rect.origin.y && bottomRight.x <= nodeBottomRight.x && bottomRight.y <= nodeBottomRight.y;
    return inBounds;
  }
  pointShapes(point2) {
    const children = this.children;
    const length = children.length;
    const result = super.pointShapes(point2);
    for (let idx = 0; idx < length; idx++) {
      append(result, children[idx].pointShapes(point2));
    }
    return result;
  }
  insert(shape, bbox) {
    const children = this.children;
    let inserted = false;
    if (this.inBounds(bbox)) {
      if (this.shapes.length < 4) {
        this._add(shape, bbox);
      } else {
        if (!children.length) {
          this._initChildren();
        }
        for (let idx = 0; idx < children.length; idx++) {
          if (children[idx].insert(shape, bbox)) {
            inserted = true;
            break;
          }
        }
        if (!inserted) {
          this._add(shape, bbox);
        }
      }
      inserted = true;
    }
    return inserted;
  }
  _initChildren() {
    const { rect, children } = this;
    const center = rect.center();
    const halfWidth = rect.width() / 2;
    const halfHeight = rect.height() / 2;
    children.push(
      new _QuadNode(new rect_default([rect.origin.x, rect.origin.y], [halfWidth, halfHeight])),
      new _QuadNode(new rect_default([center.x, rect.origin.y], [halfWidth, halfHeight])),
      new _QuadNode(new rect_default([rect.origin.x, center.y], [halfWidth, halfHeight])),
      new _QuadNode(new rect_default([center.x, center.y], [halfWidth, halfHeight]))
    );
  }
};
var quad_node_default = QuadNode;

// node_modules/@progress/kendo-drawing/dist/es/search/shapes-quad-tree.js
var ROOT_SIZE = 3e3;
var LEVEL_STEP = BigInt(1e4);
var ShapesQuadTree = class extends Class {
  constructor() {
    super();
    this.initRoots();
  }
  initRoots() {
    this.rootMap = {};
    this.root = new quad_root_default();
    this.rootElements = [];
  }
  clear() {
    const rootElements = this.rootElements;
    for (let idx = 0; idx < rootElements.length; idx++) {
      this.remove(rootElements[idx]);
    }
    this.initRoots();
  }
  pointShape(point2) {
    const sectorRoot = (this.rootMap[Math.floor(point2.x / ROOT_SIZE)] || {})[Math.floor(point2.y / ROOT_SIZE)];
    let result = this.root.pointShapes(point2);
    if (sectorRoot) {
      result = result.concat(sectorRoot.pointShapes(point2));
    }
    const maxLevel = maxZindexLevel(result);
    this.assignZindex(result, maxLevel);
    result.sort(zIndexComparer);
    for (let idx = 0; idx < result.length; idx++) {
      if (result[idx].containsPoint(point2)) {
        return result[idx];
      }
    }
  }
  assignZindex(elements, maxLevel) {
    const initialLevelWeight = bigPow(LEVEL_STEP, BigInt(maxLevel));
    const zIndexes = [];
    const start = BigInt(0);
    for (let idx = 0; idx < elements.length; idx++) {
      let element2 = elements[idx];
      let zIndex = start;
      let levelWeight = initialLevelWeight;
      let parents = [];
      while (element2) {
        parents.push(element2);
        element2 = element2.parent;
      }
      while (parents.length) {
        element2 = parents.pop();
        zIndex += BigInt((element2.parent ? element2.parent.children : this.rootElements).indexOf(element2) + 1) * levelWeight;
        levelWeight /= LEVEL_STEP;
      }
      elements[idx]._zIndex = zIndex;
      zIndexes.push(zIndex);
    }
    zIndexes.sort(sortAscComparer);
    for (let idx = 0; idx < elements.length; idx++) {
      elements[idx]._zIndex = zIndexes.indexOf(elements[idx]._zIndex);
    }
  }
  optionsChange(e) {
    if (e.field === "transform" || e.field === "stroke.width") {
      this.bboxChange(e.element);
    }
  }
  geometryChange(e) {
    this.bboxChange(e.element);
  }
  bboxChange(element2) {
    if (element2.nodeType === "Group") {
      for (let idx = 0; idx < element2.children.length; idx++) {
        this.bboxChange(element2.children[idx]);
      }
    } else {
      if (element2._quadNode) {
        element2._quadNode.remove(element2);
      }
      this._insertShape(element2);
    }
  }
  add(elements) {
    const elementsArray = Array.isArray(elements) ? elements.slice(0) : [elements];
    append(this.rootElements, elementsArray);
    this._insert(elementsArray);
  }
  childrenChange(e) {
    if (e.action === "remove") {
      for (let idx = 0; idx < e.items.length; idx++) {
        this.remove(e.items[idx]);
      }
    } else {
      this._insert(Array.prototype.slice.call(e.items, 0));
    }
  }
  _insert(elements) {
    let element2;
    while (elements.length > 0) {
      element2 = elements.pop();
      element2.addObserver(this);
      if (element2.nodeType === "Group") {
        append(elements, element2.children);
      } else {
        this._insertShape(element2);
      }
    }
  }
  _insertShape(shape) {
    const bbox = shape.bbox();
    if (bbox) {
      const sectors = this.getSectors(bbox);
      const x = sectors[0][0];
      const y = sectors[1][0];
      if (this.inRoot(sectors)) {
        this.root.insert(shape, bbox);
      } else {
        const rootMap = this.rootMap;
        if (!rootMap[x]) {
          rootMap[x] = {};
        }
        if (!rootMap[x][y]) {
          rootMap[x][y] = new quad_node_default(
            new rect_default([x * ROOT_SIZE, y * ROOT_SIZE], [ROOT_SIZE, ROOT_SIZE])
          );
        }
        rootMap[x][y].insert(shape, bbox);
      }
    }
  }
  remove(element2) {
    element2.removeObserver(this);
    if (element2.nodeType === "Group") {
      const children = element2.children;
      for (let idx = 0; idx < children.length; idx++) {
        this.remove(children[idx]);
      }
    } else if (element2._quadNode) {
      element2._quadNode.remove(element2);
      delete element2._quadNode;
    }
  }
  inRoot(sectors) {
    return sectors[0].length > 1 || sectors[1].length > 1;
  }
  getSectors(rect) {
    const bottomRight = rect.bottomRight();
    const bottomX = Math.floor(bottomRight.x / ROOT_SIZE);
    const bottomY = Math.floor(bottomRight.y / ROOT_SIZE);
    const sectors = [[], []];
    for (let x = Math.floor(rect.origin.x / ROOT_SIZE); x <= bottomX; x++) {
      sectors[0].push(x);
    }
    for (let y = Math.floor(rect.origin.y / ROOT_SIZE); y <= bottomY; y++) {
      sectors[1].push(y);
    }
    return sectors;
  }
};
function zIndexComparer(x1, x2) {
  if (x1._zIndex < x2._zIndex) {
    return 1;
  }
  if (x1._zIndex > x2._zIndex) {
    return -1;
  }
  return 0;
}
function sortAscComparer(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
function bigPow(base, exp) {
  let b = base;
  let e = exp;
  const one = BigInt(1);
  let r = one;
  while (e) {
    if (e & one) {
      r *= b;
    }
    e >>= one;
    if (e) {
      b *= b;
    }
  }
  return r;
}
function maxZindexLevel(elements) {
  let maxLevel = 0;
  for (let idx = 0; idx < elements.length; idx++) {
    let element2 = elements[idx];
    let parents = [];
    while (element2) {
      parents.push(element2);
      element2 = element2.parent;
    }
    maxLevel = Math.max(maxLevel, parents.length);
  }
  return maxLevel + 1;
}
var shapes_quad_tree_default = ShapesQuadTree;

// node_modules/@progress/kendo-drawing/dist/es/canvas/surface-cursor.js
var SurfaceCursor = class {
  constructor(surface) {
    surface.bind("mouseenter", this._mouseenter.bind(this));
    surface.bind("mouseleave", this._mouseleave.bind(this));
    this.element = surface.element;
  }
  clear() {
    this._resetCursor();
  }
  destroy() {
    this._resetCursor();
    delete this.element;
  }
  _mouseenter(e) {
    const cursor = this._shapeCursor(e);
    if (!cursor) {
      this._resetCursor();
    } else {
      if (!this._current) {
        this._defaultCursor = this._getCursor();
      }
      this._setCursor(cursor);
    }
  }
  _mouseleave() {
    this._resetCursor();
  }
  _shapeCursor(e) {
    let shape = e.element;
    while (shape && shape.options.cursor === void 0) {
      shape = shape.parent;
    }
    if (shape) {
      return shape.options.cursor;
    }
  }
  _getCursor() {
    if (this.element) {
      return this.element.style.cursor;
    }
  }
  _setCursor(cursor) {
    if (this.element) {
      this.element.style.cursor = cursor;
      this._current = cursor;
    }
  }
  _resetCursor() {
    if (this._current) {
      this._setCursor(this._defaultCursor || "");
      delete this._current;
    }
  }
};
var surface_cursor_default = SurfaceCursor;

// node_modules/@progress/kendo-drawing/dist/es/canvas/utils/render-path.js
function renderPath(ctx, path) {
  const segments = path.segments;
  if (segments.length === 0) {
    return;
  }
  let segment = segments[0];
  let anchor = segment.anchor();
  ctx.moveTo(anchor.x, anchor.y);
  for (let i = 1; i < segments.length; i++) {
    segment = segments[i];
    anchor = segment.anchor();
    let prevSeg = segments[i - 1];
    let prevOut = prevSeg.controlOut();
    let controlIn = segment.controlIn();
    if (prevOut && controlIn) {
      ctx.bezierCurveTo(
        prevOut.x,
        prevOut.y,
        controlIn.x,
        controlIn.y,
        anchor.x,
        anchor.y
      );
    } else {
      ctx.lineTo(anchor.x, anchor.y);
    }
  }
  if (path.options.closed) {
    ctx.closePath();
  }
}

// node_modules/@progress/kendo-drawing/dist/es/canvas/path-node.js
function addGradientStops(gradient, stops) {
  for (let idx = 0; idx < stops.length; idx++) {
    let stop = stops[idx];
    let color = parseColor(stop.color());
    color.a *= stop.opacity();
    gradient.addColorStop(stop.offset(), color.toCssRgba());
  }
}
var PathNode2 = class extends node_default2 {
  renderTo(ctx) {
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    ctx.beginPath();
    this.renderPoints(ctx, this.srcElement);
    this.setLineDash(ctx);
    this.setLineCap(ctx);
    this.setLineJoin(ctx);
    this.setFill(ctx);
    this.setStroke(ctx);
    ctx.restore();
  }
  setFill(ctx) {
    const fill = this.srcElement.options.fill;
    let hasFill = false;
    if (fill) {
      if (fill.nodeType === "Gradient") {
        this.setGradientFill(ctx, fill);
        hasFill = true;
      } else if (fill.nodeType === PATTERN) {
        this.setPatternFill(ctx, fill);
        hasFill = true;
      } else if (!isTransparent(fill.color)) {
        ctx.fillStyle = fill.color;
        ctx.save();
        this.globalAlpha(ctx, fill.opacity);
        ctx.fill();
        ctx.restore();
        hasFill = true;
      }
    }
    return hasFill;
  }
  setGradientFill(ctx, fill) {
    const bbox = this.srcElement.rawBBox();
    let gradient;
    if (fill instanceof linear_gradient_default) {
      let start = fill.start();
      let end = fill.end();
      gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
    } else if (fill instanceof radial_gradient_default) {
      let center = fill.center();
      gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, fill.radius());
    }
    addGradientStops(gradient, fill.stops);
    ctx.save();
    if (!fill.userSpace()) {
      ctx.transform(bbox.width(), 0, 0, bbox.height(), bbox.origin.x, bbox.origin.y);
    }
    ctx.fillStyle = gradient;
    ctx.fill();
    ctx.restore();
  }
  setPatternFill(ctx, pattern) {
    const size2 = pattern.size();
    const patternCanvas = document.createElement("canvas");
    const patternContext = patternCanvas.getContext("2d");
    patternCanvas.width = size2.getWidth();
    patternCanvas.height = size2.getHeight();
    this.childNodes.length = 0;
    this.loadElements(pattern.children);
    const childNodes = this.childNodes;
    for (let i = 0; i < childNodes.length; i++) {
      let child = childNodes[i];
      child.renderTo(patternContext);
    }
    ctx.save();
    ctx.fillStyle = ctx.createPattern(patternCanvas, "repeat");
    ctx.fill();
    ctx.restore();
  }
  setStroke(ctx) {
    const stroke = this.srcElement.options.stroke;
    if (stroke && !isTransparent(stroke.color) && stroke.width > 0) {
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = valueOrDefault(stroke.width, 1);
      ctx.lineJoin = valueOrDefault(stroke.lineJoin, ctx.lineJoin);
      ctx.save();
      this.globalAlpha(ctx, stroke.opacity);
      ctx.stroke();
      ctx.restore();
      return true;
    }
  }
  dashType() {
    const stroke = this.srcElement.options.stroke;
    if (stroke && stroke.dashType) {
      return stroke.dashType.toLowerCase();
    }
  }
  setLineDash(ctx) {
    const dashType = this.dashType();
    if (dashType && dashType !== SOLID) {
      const dashArray = DASH_ARRAYS[dashType];
      if (ctx.setLineDash) {
        ctx.setLineDash(dashArray);
      } else {
        ctx.mozDash = dashArray;
        ctx.webkitLineDash = dashArray;
      }
    }
  }
  setLineCap(ctx) {
    const dashType = this.dashType();
    const stroke = this.srcElement.options.stroke;
    if (dashType && dashType !== SOLID) {
      ctx.lineCap = BUTT;
    } else if (stroke && stroke.lineCap) {
      ctx.lineCap = stroke.lineCap;
    }
  }
  setLineJoin(ctx) {
    const stroke = this.srcElement.options.stroke;
    if (stroke && stroke.lineJoin) {
      ctx.lineJoin = stroke.lineJoin;
    }
  }
  renderPoints(ctx, path) {
    renderPath(ctx, path);
  }
};
var path_node_default2 = PathNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/arc-node.js
var ArcNode2 = class extends path_node_default2 {
  renderPoints(ctx) {
    const path = this.srcElement.toPath();
    renderPath(ctx, path);
  }
};
var arc_node_default2 = ArcNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/circle-node.js
var CircleNode2 = class extends path_node_default2 {
  renderPoints(ctx) {
    const { center, radius } = this.srcElement.geometry();
    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
  }
};
var circle_node_default2 = CircleNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/image-node.js
var ImageNode2 = class extends path_node_default2 {
  constructor(srcElement, cors) {
    super(srcElement);
    this.onLoad = this.onLoad.bind(this);
    this.onError = this.onError.bind(this);
    this.loading = createPromise();
    const img = this.img = new Image();
    const src = srcElement.src();
    if (cors && !/^data:/i.test(src)) {
      img.crossOrigin = cors;
    }
    if (src) {
      img.src = src;
    }
    if (img.complete) {
      this.onLoad();
    } else {
      img.onload = this.onLoad;
      img.onerror = this.onError;
    }
  }
  renderTo(ctx) {
    if (this.loading.state() === "resolved") {
      ctx.save();
      this.setTransform(ctx);
      this.setClip(ctx);
      this.drawImage(ctx);
      ctx.restore();
    }
  }
  optionsChange(e) {
    if (e.field === "src") {
      this.loading = createPromise();
      this.img.src = this.srcElement.src();
    } else {
      super.optionsChange(e);
    }
  }
  onLoad() {
    this.loading.resolve();
    this.invalidate();
  }
  onError() {
    this.loading.reject(new Error(
      "Unable to load image '" + this.img.src + "'. Check for connectivity and verify CORS headers."
    ));
  }
  drawImage(ctx) {
    const rect = this.srcElement.rect();
    const topLeft = rect.topLeft();
    ctx.drawImage(
      this.img,
      topLeft.x,
      topLeft.y,
      rect.width(),
      rect.height()
    );
  }
};
var image_node_default2 = ImageNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/multi-path-node.js
var MultiPathNode2 = class extends path_node_default2 {
  renderPoints(ctx) {
    const paths = this.srcElement.paths;
    for (let i = 0; i < paths.length; i++) {
      renderPath(ctx, paths[i]);
    }
  }
};
var multi_path_node_default2 = MultiPathNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/rect-node.js
var RectNode2 = class extends path_node_default2 {
  renderPoints(ctx) {
    const geometry = this.srcElement.geometry();
    const [rx, ry] = geometry.cornerRadius;
    if (rx === 0 && ry === 0) {
      const { origin, size: size2 } = geometry;
      ctx.rect(origin.x, origin.y, size2.width, size2.height);
    } else {
      super.renderPoints(ctx, Path.fromRect(geometry));
    }
  }
};
var rect_node_default2 = RectNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/text-node.js
var TextNode2 = class extends path_node_default2 {
  renderTo(ctx) {
    const text = this.srcElement;
    const pos = text.position();
    const size2 = text.measure();
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    ctx.beginPath();
    ctx.font = text.options.font;
    ctx.textAlign = "left";
    if (text.options.paintOrder === "stroke") {
      this.stroke(ctx, text, pos, size2);
      this.fill(ctx, text, pos, size2);
    } else {
      this.fill(ctx, text, pos, size2);
      this.stroke(ctx, text, pos, size2);
    }
    ctx.restore();
  }
  stroke(ctx, text, pos, size2) {
    if (this.setStroke(ctx)) {
      this.setLineDash(ctx);
      ctx.strokeText(text.content(), pos.x, pos.y + size2.baseline);
    }
  }
  fill(ctx, text, pos, size2) {
    if (this.setFill(ctx)) {
      ctx.fillText(text.content(), pos.x, pos.y + size2.baseline);
    }
  }
};
var text_node_default2 = TextNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/surface.js
node_map_default2.Arc = arc_node_default2;
node_map_default2.Circle = circle_node_default2;
node_map_default2.Group = group_node_default2;
node_map_default2.Image = image_node_default2;
node_map_default2.MultiPath = multi_path_node_default2;
node_map_default2.Path = path_node_default2;
node_map_default2.Rect = rect_node_default2;
node_map_default2.Text = text_node_default2;
var Surface3 = class extends surface_default {
  get type() {
    return "canvas";
  }
  constructor(element2, options2) {
    super(element2, options2);
    this.element.innerHTML = this._template(this);
    const canvas = this.element.firstElementChild;
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    const size2 = elementSize(element2);
    canvas.width = size2.width;
    canvas.height = size2.height;
    this._rootElement = canvas;
    this._root = new root_node_default2(canvas, size2);
    this._mouseTrackHandler = this._trackMouse.bind(this);
    bindEvents(this.element, {
      click: this._mouseTrackHandler,
      mousemove: this._mouseTrackHandler
    });
  }
  destroy() {
    super.destroy();
    if (this._root) {
      this._root.destroy();
      this._root = null;
    }
    if (this._searchTree) {
      this._searchTree.clear();
      delete this._searchTree;
    }
    if (this._cursor) {
      this._cursor.destroy();
      delete this._cursor;
    }
    unbindEvents(this.element, {
      click: this._mouseTrackHandler,
      mousemove: this._mouseTrackHandler
    });
  }
  draw(element2) {
    super.draw(element2);
    this._root.load([element2], void 0, this.options.cors);
    if (this._searchTree) {
      this._searchTree.add([element2]);
    }
  }
  clear() {
    super.clear();
    this._root.clear();
    if (this._searchTree) {
      this._searchTree.clear();
    }
    if (this._cursor) {
      this._cursor.clear();
    }
  }
  eventTarget(e) {
    if (this._searchTree) {
      const point2 = this._surfacePoint(e);
      const shape = this._searchTree.pointShape(point2);
      return shape;
    }
  }
  image() {
    const { _root: root, _rootElement: rootElement } = this;
    const loadingStates = [];
    root.traverse((childNode) => {
      if (childNode.loading) {
        loadingStates.push(childNode.loading);
      }
    });
    const promise = createPromise();
    const resolveDataURL = () => {
      root._invalidate({ fixedScale: true });
      try {
        const data23 = rootElement.toDataURL();
        promise.resolve(data23);
      } catch (e) {
        promise.reject(e);
      }
    };
    promiseAll(loadingStates).then(resolveDataURL, resolveDataURL);
    return promise;
  }
  suspendTracking() {
    super.suspendTracking();
    if (this._searchTree) {
      this._searchTree.clear();
      delete this._searchTree;
    }
  }
  resumeTracking() {
    super.resumeTracking();
    if (!this._searchTree) {
      this._searchTree = new shapes_quad_tree_default();
      const childNodes = this._root.childNodes;
      const rootElements = [];
      for (let idx = 0; idx < childNodes.length; idx++) {
        rootElements.push(childNodes[idx].srcElement);
      }
      this._searchTree.add(rootElements);
    }
  }
  _resize() {
    this._rootElement.width = this._size.width;
    this._rootElement.height = this._size.height;
    this._root.size = this._size;
    this._root.invalidate();
  }
  _template() {
    return "<canvas></canvas>";
  }
  _enableTracking() {
    this._searchTree = new shapes_quad_tree_default();
    this._cursor = new surface_cursor_default(this);
    super._enableTracking();
  }
  _trackMouse(e) {
    if (this._suspendedTracking) {
      return;
    }
    const shape = this.eventTarget(e);
    if (e.type !== "click") {
      const currentShape = this._currentShape;
      if (currentShape && currentShape !== shape) {
        this.trigger("mouseleave", {
          element: currentShape,
          originalEvent: e,
          type: "mouseleave"
        });
      }
      if (shape && currentShape !== shape) {
        this.trigger("mouseenter", {
          element: shape,
          originalEvent: e,
          type: "mouseenter"
        });
      }
      this.trigger("mousemove", {
        element: shape,
        originalEvent: e,
        type: "mousemove"
      });
      this._currentShape = shape;
    } else if (shape) {
      this.trigger("click", {
        element: shape,
        originalEvent: e,
        type: "click"
      });
    }
  }
};
var surface_default3 = Surface3;

// node_modules/@progress/kendo-drawing/dist/es/surface-factory.js
var instance3;
var support2;
var hasDocument = () => typeof document !== "undefined";
var supportsCanvas = () => hasDocument() && document.createElement("canvas").getContext;
var supportsSVG = () => hasDocument() && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
var SurfaceFactory = class _SurfaceFactory extends Class {
  static get support() {
    if (!support2) {
      support2 = {
        canvas: supportsCanvas(),
        svg: supportsSVG()
      };
    }
    return support2;
  }
  static get current() {
    if (!instance3) {
      instance3 = new _SurfaceFactory();
    }
    return instance3;
  }
  constructor() {
    super();
    this._items = [{
      name: "svg",
      type: surface_default2
    }, {
      name: "canvas",
      type: surface_default3
    }];
  }
  create(element2, options2) {
    const items = this._items;
    let match = items[0];
    if (options2 && options2.type) {
      const preferred = options2.type.toLowerCase();
      for (let i = 0; i < items.length; i++) {
        if (items[i].name === preferred) {
          match = items[i];
          break;
        }
      }
    }
    if (match) {
      return new match.type(element2, options2);
    }
    logToConsole(
      `Warning: Unable to create Kendo UI Drawing Surface. Possible causes:
- The browser does not support SVG and Canvas. User agent: ${navigator.userAgent}`
    );
  }
};
var surface_factory_default = SurfaceFactory;

// node_modules/@progress/kendo-drawing/dist/es/surface.js
var Surface4 = class extends surface_default {
  static get support() {
    return surface_factory_default.support;
  }
  static create(element2, options2) {
    return surface_factory_default.current.create(element2, options2);
  }
};
var surface_default4 = Surface4;

// node_modules/@progress/kendo-drawing/dist/es/svg.js
var svg_exports = {};
__export(svg_exports, {
  ArcNode: () => arc_node_default,
  CircleNode: () => circle_node_default,
  ClipNode: () => clip_node_default,
  DefinitionNode: () => definition_node_default,
  GradientStopNode: () => gradient_stop_node_default,
  GroupNode: () => group_node_default,
  ImageNode: () => image_node_default,
  LinearGradientNode: () => linear_gradient_node_default,
  MultiPathNode: () => multi_path_node_default,
  Node: () => node_default,
  PathNode: () => path_node_default,
  RadialGradientNode: () => radial_gradient_node_default,
  RectNode: () => rect_node_default,
  RootNode: () => root_node_default,
  Surface: () => surface_default2,
  TextNode: () => text_node_default,
  exportGroup: () => exportGroup
});

// node_modules/@progress/kendo-drawing/dist/es/svg/export-group.js
function exportGroup(group) {
  const root = new root_node_default({
    skipBaseHref: true
  });
  const bbox = group.clippedBBox();
  let rootGroup = group;
  if (bbox) {
    const origin = bbox.getOrigin();
    const exportRoot = new group_default();
    exportRoot.transform(transform().translate(-origin.x, -origin.y));
    exportRoot.children.push(group);
    rootGroup = exportRoot;
  }
  root.load([rootGroup]);
  const svg = `<?xml version='1.0' ?><svg xmlns='${SVG_NS}' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>${root.render()}</svg>`;
  root.destroy();
  return svg;
}

// node_modules/@progress/kendo-drawing/dist/es/canvas.js
var canvas_exports = {};
__export(canvas_exports, {
  ArcNode: () => arc_node_default2,
  CircleNode: () => circle_node_default2,
  GroupNode: () => group_node_default2,
  ImageNode: () => image_node_default2,
  MultiPathNode: () => multi_path_node_default2,
  Node: () => node_default2,
  PathNode: () => path_node_default2,
  RectNode: () => rect_node_default2,
  RootNode: () => root_node_default2,
  Surface: () => surface_default3,
  TextNode: () => text_node_default2
});

// node_modules/@progress/kendo-drawing/dist/es/canvas/export-image.js
function exportImage(group, options2) {
  const defaults = {
    width: "800px",
    height: "600px",
    cors: "Anonymous"
  };
  let exportRoot = group;
  const bbox = group.clippedBBox();
  if (bbox) {
    const origin = bbox.getOrigin();
    exportRoot = new group_default();
    exportRoot.transform(transform().translate(-origin.x, -origin.y));
    exportRoot.children.push(group);
    const size2 = bbox.getSize();
    defaults.width = size2.width + "px";
    defaults.height = size2.height + "px";
  }
  const surfaceOptions = Object.assign(defaults, options2);
  const container = document.createElement("div");
  const style = container.style;
  style.display = "none";
  style.width = surfaceOptions.width;
  style.height = surfaceOptions.height;
  document.body.appendChild(container);
  const surface = new surface_default3(container, surfaceOptions);
  surface.suspendTracking();
  surface.draw(exportRoot);
  const promise = surface.image();
  const destroy = () => {
    surface.destroy();
    document.body.removeChild(container);
  };
  promise.then(destroy, destroy);
  return promise;
}

// node_modules/@progress/kendo-drawing/dist/es/svg/export-svg.js
function exportSVG(group, options2) {
  let svg = exportGroup(group);
  if (!options2 || !options2.raw) {
    svg = "data:image/svg+xml;base64," + encodeBase64(svg);
  }
  return createPromise().resolve(svg);
}

// node_modules/@progress/kendo-drawing/dist/es/pdf/utils.js
var HAS_TYPED_ARRAYS = typeof Uint8Array !== "undefined" && support_default.browser && (!support_default.browser.msie || support_default.browser.version > 9);
var BASE64 = /* @__PURE__ */ function() {
  var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  return {
    decode: function(str) {
      var input = str.replace(/[^A-Za-z0-9\+\/\=]/g, ""), i = 0, n = input.length, output = [];
      while (i < n) {
        var enc1 = keyStr.indexOf(input.charAt(i++));
        var enc2 = keyStr.indexOf(input.charAt(i++));
        var enc3 = keyStr.indexOf(input.charAt(i++));
        var enc4 = keyStr.indexOf(input.charAt(i++));
        var chr1 = enc1 << 2 | enc2 >>> 4;
        var chr2 = (enc2 & 15) << 4 | enc3 >>> 2;
        var chr3 = (enc3 & 3) << 6 | enc4;
        output.push(chr1);
        if (enc3 != 64) {
          output.push(chr2);
        }
        if (enc4 != 64) {
          output.push(chr3);
        }
      }
      return output;
    },
    encode: function(bytes) {
      var i = 0, n = bytes.length;
      var output = "";
      while (i < n) {
        var chr1 = bytes[i++];
        var chr2 = bytes[i++];
        var chr3 = bytes[i++];
        var enc1 = chr1 >>> 2;
        var enc2 = (chr1 & 3) << 4 | chr2 >>> 4;
        var enc3 = (chr2 & 15) << 2 | chr3 >>> 6;
        var enc4 = chr3 & 63;
        if (i - n == 2) {
          enc3 = enc4 = 64;
        } else if (i - n == 1) {
          enc4 = 64;
        }
        output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
      }
      return output;
    }
  };
}();
function BinaryStream(data23) {
  var offset = 0, length = 0;
  if (data23 == null) {
    data23 = HAS_TYPED_ARRAYS ? new Uint8Array(256) : [];
  } else {
    length = data23.length;
  }
  var ensure = HAS_TYPED_ARRAYS ? function(len) {
    if (len >= data23.length) {
      var tmp = new Uint8Array(Math.max(len + 256, data23.length * 2));
      tmp.set(data23, 0);
      data23 = tmp;
    }
  } : function() {
  };
  var get10 = HAS_TYPED_ARRAYS ? function() {
    return new Uint8Array(data23.buffer, 0, length);
  } : function() {
    return data23;
  };
  var write = HAS_TYPED_ARRAYS ? function(bytes) {
    if (typeof bytes == "string") {
      return writeString(bytes);
    }
    var len = bytes.length;
    ensure(offset + len);
    data23.set(bytes, offset);
    offset += len;
    if (offset > length) {
      length = offset;
    }
  } : function(bytes) {
    if (typeof bytes == "string") {
      return writeString(bytes);
    }
    for (var i = 0; i < bytes.length; ++i) {
      writeByte(bytes[i]);
    }
  };
  var slice3 = HAS_TYPED_ARRAYS ? function(start, length2) {
    if (data23.buffer.slice) {
      return new Uint8Array(data23.buffer.slice(start, start + length2));
    } else {
      var x = new Uint8Array(length2);
      x.set(new Uint8Array(data23.buffer, start, length2));
      return x;
    }
  } : function(start, length2) {
    return data23.slice(start, start + length2);
  };
  function eof() {
    return offset >= length;
  }
  function readByte() {
    return offset < length ? data23[offset++] : 0;
  }
  function writeByte(b) {
    ensure(offset);
    data23[offset++] = b & 255;
    if (offset > length) {
      length = offset;
    }
  }
  function readShort() {
    return readByte() << 8 | readByte();
  }
  function writeShort(w) {
    writeByte(w >> 8);
    writeByte(w);
  }
  function readShort_() {
    var w = readShort();
    return w >= 32768 ? w - 65536 : w;
  }
  function writeShort_(w) {
    writeShort(w < 0 ? w + 65536 : w);
  }
  function readLong() {
    return readShort() * 65536 + readShort();
  }
  function writeLong(w) {
    writeShort(w >>> 16 & 65535);
    writeShort(w & 65535);
  }
  function readLong_() {
    var w = readLong();
    return w >= 2147483648 ? w - 4294967296 : w;
  }
  function writeLong_(w) {
    writeLong(w < 0 ? w + 4294967296 : w);
  }
  function readFixed() {
    return readLong() / 65536;
  }
  function writeFixed(f) {
    writeLong(Math.round(f * 65536));
  }
  function readFixed_() {
    return readLong_() / 65536;
  }
  function writeFixed_(f) {
    writeLong_(Math.round(f * 65536));
  }
  function read(len) {
    return times(len, readByte);
  }
  function readString(len) {
    return String.fromCharCode.apply(String, read(len));
  }
  function writeString(str) {
    for (var i = 0; i < str.length; ++i) {
      writeByte(str.charCodeAt(i));
    }
  }
  function times(n, reader) {
    for (var ret = new Array(n), i = 0; i < n; ++i) {
      ret[i] = reader();
    }
    return ret;
  }
  var stream = {
    eof,
    readByte,
    writeByte,
    readShort,
    writeShort,
    readLong,
    writeLong,
    readFixed,
    writeFixed,
    // signed numbers.
    readShort_,
    writeShort_,
    readLong_,
    writeLong_,
    readFixed_,
    writeFixed_,
    read,
    write,
    readString,
    writeString,
    times,
    get: get10,
    slice: slice3,
    offset: function(pos) {
      if (pos != null) {
        offset = pos;
        return stream;
      }
      return offset;
    },
    skip: function(nbytes) {
      offset += nbytes;
    },
    toString: function() {
      throw new Error("FIX CALLER.  BinaryStream is no longer convertible to string!");
    },
    length: function() {
      return length;
    },
    saveExcursion: function(f) {
      var pos = offset;
      try {
        return f();
      } finally {
        offset = pos;
      }
    },
    writeBase64: function(base64) {
      if (window.atob) {
        writeString(window.atob(base64));
      } else {
        write(BASE64.decode(base64));
      }
    },
    base64: function() {
      return BASE64.encode(get10());
    }
  };
  return stream;
}
function ucs2decode(string) {
  var output = [], counter = 0, length = string.length, value2, extra;
  while (counter < length) {
    value2 = string.charCodeAt(counter++);
    if (value2 >= 55296 && value2 <= 56319 && counter < length) {
      extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value2);
        counter--;
      }
    } else {
      output.push(value2);
    }
  }
  return output;
}
function atobUint8Array(base64) {
  const data23 = window.atob(base64);
  const result = new Uint8Array(data23.length);
  for (let idx = 0; idx < data23.length; idx++) {
    result[idx] = data23.charCodeAt(idx);
  }
  return result;
}
function createUint8Array(data23) {
  const result = new Uint8Array(data23.length);
  for (let idx = 0; idx < data23.length; idx++) {
    result[idx] = data23[idx];
  }
  return result;
}
function base64ToUint8Array(base64) {
  if (window.atob) {
    return atobUint8Array(base64);
  }
  return createUint8Array(BASE64.decode(base64));
}

// node_modules/@progress/kendo-drawing/dist/es/pdf/ttf.js
function hasOwnProperty(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function sortedKeys(obj) {
  return Object.keys(obj).sort(function(a, b) {
    return a - b;
  }).map(parseFloat);
}
var Directory = class {
  constructor(data23) {
    this.raw = data23;
    this.scalerType = data23.readLong();
    this.tableCount = data23.readShort();
    this.searchRange = data23.readShort();
    this.entrySelector = data23.readShort();
    this.rangeShift = data23.readShort();
    var tables = this.tables = {};
    for (var i = 0; i < this.tableCount; ++i) {
      var entry = {
        tag: data23.readString(4),
        checksum: data23.readLong(),
        offset: data23.readLong(),
        length: data23.readLong()
      };
      tables[entry.tag] = entry;
    }
  }
  readTable(name3, Ctor) {
    var def = this.tables[name3];
    if (!def) {
      throw new Error("Table " + name3 + " not found in directory");
    }
    return this[name3] = def.table = new Ctor(this, def);
  }
  render(tables) {
    var tableCount = Object.keys(tables).length;
    var maxpow2 = Math.pow(2, Math.floor(Math.log(tableCount) / Math.LN2));
    var searchRange = maxpow2 * 16;
    var entrySelector = Math.floor(Math.log(maxpow2) / Math.LN2);
    var rangeShift = tableCount * 16 - searchRange;
    var out = BinaryStream();
    out.writeLong(this.scalerType);
    out.writeShort(tableCount);
    out.writeShort(searchRange);
    out.writeShort(entrySelector);
    out.writeShort(rangeShift);
    var directoryLength = tableCount * 16;
    var offset = out.offset() + directoryLength;
    var headOffset = null;
    var tableData = BinaryStream();
    for (var tag in tables) {
      if (hasOwnProperty(tables, tag)) {
        var table = tables[tag];
        out.writeString(tag);
        out.writeLong(this.checksum(table));
        out.writeLong(offset);
        out.writeLong(table.length);
        tableData.write(table);
        if (tag == "head") {
          headOffset = offset;
        }
        offset += table.length;
        while (offset % 4) {
          tableData.writeByte(0);
          offset++;
        }
      }
    }
    out.write(tableData.get());
    var sum = this.checksum(out.get());
    var adjustment = 2981146554 - sum;
    out.offset(headOffset + 8);
    out.writeLong(adjustment);
    return out.get();
  }
  checksum(data23) {
    data23 = BinaryStream(data23);
    var sum = 0;
    while (!data23.eof()) {
      sum += data23.readLong();
    }
    return sum & 4294967295;
  }
};
var Table = class {
  constructor(file, def) {
    this.definition = def;
    this.length = def.length;
    this.offset = def.offset;
    this.file = file;
    this.rawData = file.raw;
    this.parse(file.raw);
  }
  raw() {
    return this.rawData.slice(this.offset, this.length);
  }
  parse() {
  }
  // abstract
};
var HeadTable = class extends Table {
  parse(data23) {
    data23.offset(this.offset);
    this.version = data23.readLong();
    this.revision = data23.readLong();
    this.checkSumAdjustment = data23.readLong();
    this.magicNumber = data23.readLong();
    this.flags = data23.readShort();
    this.unitsPerEm = data23.readShort();
    this.created = data23.read(8);
    this.modified = data23.read(8);
    this.xMin = data23.readShort_();
    this.yMin = data23.readShort_();
    this.xMax = data23.readShort_();
    this.yMax = data23.readShort_();
    this.macStyle = data23.readShort();
    this.lowestRecPPEM = data23.readShort();
    this.fontDirectionHint = data23.readShort_();
    this.indexToLocFormat = data23.readShort_();
    this.glyphDataFormat = data23.readShort_();
  }
  render(indexToLocFormat) {
    var out = BinaryStream();
    out.writeLong(this.version);
    out.writeLong(this.revision);
    out.writeLong(0);
    out.writeLong(this.magicNumber);
    out.writeShort(this.flags);
    out.writeShort(this.unitsPerEm);
    out.write(this.created);
    out.write(this.modified);
    out.writeShort_(this.xMin);
    out.writeShort_(this.yMin);
    out.writeShort_(this.xMax);
    out.writeShort_(this.yMax);
    out.writeShort(this.macStyle);
    out.writeShort(this.lowestRecPPEM);
    out.writeShort_(this.fontDirectionHint);
    out.writeShort_(indexToLocFormat);
    out.writeShort_(this.glyphDataFormat);
    return out.get();
  }
};
var LocaTable = class extends Table {
  parse(data23) {
    data23.offset(this.offset);
    var format = this.file.head.indexToLocFormat;
    if (format === 0) {
      this.offsets = data23.times(this.length / 2, function() {
        return 2 * data23.readShort();
      });
    } else {
      this.offsets = data23.times(this.length / 4, data23.readLong);
    }
  }
  offsetOf(id) {
    return this.offsets[id];
  }
  lengthOf(id) {
    return this.offsets[id + 1] - this.offsets[id];
  }
  render(offsets) {
    var out = BinaryStream();
    var needsLongFormat = offsets[offsets.length - 1] > 65535;
    for (var i = 0; i < offsets.length; ++i) {
      if (needsLongFormat) {
        out.writeLong(offsets[i]);
      } else {
        out.writeShort(offsets[i] / 2);
      }
    }
    return {
      format: needsLongFormat ? 1 : 0,
      table: out.get()
    };
  }
};
var HheaTable = class extends Table {
  parse(data23) {
    data23.offset(this.offset);
    this.version = data23.readLong();
    this.ascent = data23.readShort_();
    this.descent = data23.readShort_();
    this.lineGap = data23.readShort_();
    this.advanceWidthMax = data23.readShort();
    this.minLeftSideBearing = data23.readShort_();
    this.minRightSideBearing = data23.readShort_();
    this.xMaxExtent = data23.readShort_();
    this.caretSlopeRise = data23.readShort_();
    this.caretSlopeRun = data23.readShort_();
    this.caretOffset = data23.readShort_();
    data23.skip(4 * 2);
    this.metricDataFormat = data23.readShort_();
    this.numOfLongHorMetrics = data23.readShort();
  }
  render(ids) {
    var out = BinaryStream();
    out.writeLong(this.version);
    out.writeShort_(this.ascent);
    out.writeShort_(this.descent);
    out.writeShort_(this.lineGap);
    out.writeShort(this.advanceWidthMax);
    out.writeShort_(this.minLeftSideBearing);
    out.writeShort_(this.minRightSideBearing);
    out.writeShort_(this.xMaxExtent);
    out.writeShort_(this.caretSlopeRise);
    out.writeShort_(this.caretSlopeRun);
    out.writeShort_(this.caretOffset);
    out.write([0, 0, 0, 0, 0, 0, 0, 0]);
    out.writeShort_(this.metricDataFormat);
    out.writeShort(ids.length);
    return out.get();
  }
};
var MaxpTable = class extends Table {
  parse(data23) {
    data23.offset(this.offset);
    this.version = data23.readLong();
    this.numGlyphs = data23.readShort();
    this.maxPoints = data23.readShort();
    this.maxContours = data23.readShort();
    this.maxComponentPoints = data23.readShort();
    this.maxComponentContours = data23.readShort();
    this.maxZones = data23.readShort();
    this.maxTwilightPoints = data23.readShort();
    this.maxStorage = data23.readShort();
    this.maxFunctionDefs = data23.readShort();
    this.maxInstructionDefs = data23.readShort();
    this.maxStackElements = data23.readShort();
    this.maxSizeOfInstructions = data23.readShort();
    this.maxComponentElements = data23.readShort();
    this.maxComponentDepth = data23.readShort();
  }
  render(glyphIds) {
    var out = BinaryStream();
    out.writeLong(this.version);
    out.writeShort(glyphIds.length);
    out.writeShort(this.maxPoints);
    out.writeShort(this.maxContours);
    out.writeShort(this.maxComponentPoints);
    out.writeShort(this.maxComponentContours);
    out.writeShort(this.maxZones);
    out.writeShort(this.maxTwilightPoints);
    out.writeShort(this.maxStorage);
    out.writeShort(this.maxFunctionDefs);
    out.writeShort(this.maxInstructionDefs);
    out.writeShort(this.maxStackElements);
    out.writeShort(this.maxSizeOfInstructions);
    out.writeShort(this.maxComponentElements);
    out.writeShort(this.maxComponentDepth);
    return out.get();
  }
};
var HmtxTable = class extends Table {
  parse(data23) {
    data23.offset(this.offset);
    var dir = this.file, hhea = dir.hhea;
    this.metrics = data23.times(hhea.numOfLongHorMetrics, function() {
      return {
        advance: data23.readShort(),
        lsb: data23.readShort_()
      };
    });
    var lsbCount = dir.maxp.numGlyphs - dir.hhea.numOfLongHorMetrics;
    this.leftSideBearings = data23.times(lsbCount, data23.readShort_);
  }
  forGlyph(id) {
    var metrics = this.metrics;
    var n = metrics.length;
    if (id < n) {
      return metrics[id];
    }
    return {
      advance: metrics[n - 1].advance,
      lsb: this.leftSideBearings[id - n]
    };
  }
  render(glyphIds) {
    var out = BinaryStream();
    for (var i = 0; i < glyphIds.length; ++i) {
      var m = this.forGlyph(glyphIds[i]);
      out.writeShort(m.advance);
      out.writeShort_(m.lsb);
    }
    return out.get();
  }
};
var GlyfTable = /* @__PURE__ */ function() {
  class SimpleGlyph {
    get compound() {
      return false;
    }
    constructor(raw) {
      this.raw = raw;
    }
    render() {
      return this.raw.get();
    }
  }
  var ARG_1_AND_2_ARE_WORDS = 1;
  var WE_HAVE_A_SCALE = 8;
  var MORE_COMPONENTS = 32;
  var WE_HAVE_AN_X_AND_Y_SCALE = 64;
  var WE_HAVE_A_TWO_BY_TWO = 128;
  class CompoundGlyph {
    get compound() {
      return true;
    }
    constructor(data23) {
      this.raw = data23;
      var ids = this.glyphIds = [];
      var offsets = this.idOffsets = [];
      while (true) {
        var flags = data23.readShort();
        offsets.push(data23.offset());
        ids.push(data23.readShort());
        if (!(flags & MORE_COMPONENTS)) {
          break;
        }
        data23.skip(flags & ARG_1_AND_2_ARE_WORDS ? 4 : 2);
        if (flags & WE_HAVE_A_TWO_BY_TWO) {
          data23.skip(8);
        } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
          data23.skip(4);
        } else if (flags & WE_HAVE_A_SCALE) {
          data23.skip(2);
        }
      }
    }
    render(old2new) {
      var out = BinaryStream(this.raw.get());
      for (var i = 0; i < this.glyphIds.length; ++i) {
        var id = this.glyphIds[i];
        out.offset(this.idOffsets[i]);
        out.writeShort(old2new[id]);
      }
      return out.get();
    }
  }
  return class extends Table {
    parse() {
      this.cache = {};
    }
    glyphFor(id) {
      var cache2 = this.cache;
      if (hasOwnProperty(cache2, id)) {
        return cache2[id];
      }
      var loca = this.file.loca;
      var length = loca.lengthOf(id);
      if (length === 0) {
        return cache2[id] = null;
      }
      var data23 = this.rawData;
      var offset = this.offset + loca.offsetOf(id);
      var raw = BinaryStream(data23.slice(offset, length));
      var numberOfContours = raw.readShort_();
      var xMin = raw.readShort_();
      var yMin = raw.readShort_();
      var xMax = raw.readShort_();
      var yMax = raw.readShort_();
      var glyph = cache2[id] = numberOfContours < 0 ? new CompoundGlyph(raw) : new SimpleGlyph(raw);
      glyph.numberOfContours = numberOfContours;
      glyph.xMin = xMin;
      glyph.yMin = yMin;
      glyph.xMax = xMax;
      glyph.yMax = yMax;
      return glyph;
    }
    render(glyphs, oldIds, old2new) {
      var out = BinaryStream(), offsets = [];
      for (var i = 0; i < oldIds.length; ++i) {
        var id = oldIds[i];
        var glyph = glyphs[id];
        if (out.offset() % 2) {
          out.writeByte(0);
        }
        offsets.push(out.offset());
        if (glyph) {
          out.write(glyph.render(old2new));
        }
      }
      if (out.offset() % 2) {
        out.writeByte(0);
      }
      offsets.push(out.offset());
      return {
        table: out.get(),
        offsets
      };
    }
  };
}();
var NameTable = /* @__PURE__ */ function() {
  class NameEntry {
    constructor(text, entry) {
      this.text = text;
      this.length = text.length;
      this.platformID = entry.platformID;
      this.platformSpecificID = entry.platformSpecificID;
      this.languageID = entry.languageID;
      this.nameID = entry.nameID;
    }
  }
  return class extends Table {
    parse(data23) {
      data23.offset(this.offset);
      data23.readShort();
      var count = data23.readShort();
      var stringOffset = this.offset + data23.readShort();
      var nameRecords = data23.times(count, function() {
        return {
          platformID: data23.readShort(),
          platformSpecificID: data23.readShort(),
          languageID: data23.readShort(),
          nameID: data23.readShort(),
          length: data23.readShort(),
          offset: data23.readShort() + stringOffset
        };
      });
      var strings = this.strings = {};
      for (var i = 0; i < nameRecords.length; ++i) {
        var rec = nameRecords[i];
        data23.offset(rec.offset);
        var text = data23.readString(rec.length);
        if (!strings[rec.nameID]) {
          strings[rec.nameID] = [];
        }
        strings[rec.nameID].push(new NameEntry(text, rec));
      }
      this.postscriptEntry = strings[6][0];
      this.postscriptName = this.postscriptEntry.text.replace(/[^\x20-\x7F]/g, "");
    }
    render(psName) {
      var strings = this.strings;
      var strCount = 0;
      for (var i in strings) {
        if (hasOwnProperty(strings, i)) {
          strCount += strings[i].length;
        }
      }
      var out = BinaryStream();
      var strTable = BinaryStream();
      out.writeShort(0);
      out.writeShort(strCount);
      out.writeShort(6 + 12 * strCount);
      for (i in strings) {
        if (hasOwnProperty(strings, i)) {
          var list = i == 6 ? [
            new NameEntry(psName, this.postscriptEntry)
          ] : strings[i];
          for (var j = 0; j < list.length; ++j) {
            var str = list[j];
            out.writeShort(str.platformID);
            out.writeShort(str.platformSpecificID);
            out.writeShort(str.languageID);
            out.writeShort(str.nameID);
            out.writeShort(str.length);
            out.writeShort(strTable.offset());
            strTable.writeString(str.text);
          }
        }
      }
      out.write(strTable.get());
      return out.get();
    }
  };
}();
var PostTable = function() {
  var POSTSCRIPT_GLYPHS = ".notdef .null nonmarkingreturn space exclam quotedbl numbersign dollar percent ampersand quotesingle parenleft parenright asterisk plus comma hyphen period slash zero one two three four five six seven eight nine colon semicolon less equal greater question at A B C D E F G H I J K L M N O P Q R S T U V W X Y Z bracketleft backslash bracketright asciicircum underscore grave a b c d e f g h i j k l m n o p q r s t u v w x y z braceleft bar braceright asciitilde Adieresis Aring Ccedilla Eacute Ntilde Odieresis Udieresis aacute agrave acircumflex adieresis atilde aring ccedilla eacute egrave ecircumflex edieresis iacute igrave icircumflex idieresis ntilde oacute ograve ocircumflex odieresis otilde uacute ugrave ucircumflex udieresis dagger degree cent sterling section bullet paragraph germandbls registered copyright trademark acute dieresis notequal AE Oslash infinity plusminus lessequal greaterequal yen mu partialdiff summation product pi integral ordfeminine ordmasculine Omega ae oslash questiondown exclamdown logicalnot radical florin approxequal Delta guillemotleft guillemotright ellipsis nonbreakingspace Agrave Atilde Otilde OE oe endash emdash quotedblleft quotedblright quoteleft quoteright divide lozenge ydieresis Ydieresis fraction currency guilsinglleft guilsinglright fi fl daggerdbl periodcentered quotesinglbase quotedblbase perthousand Acircumflex Ecircumflex Aacute Edieresis Egrave Iacute Icircumflex Idieresis Igrave Oacute Ocircumflex apple Ograve Uacute Ucircumflex Ugrave dotlessi circumflex tilde macron breve dotaccent ring cedilla hungarumlaut ogonek caron Lslash lslash Scaron scaron Zcaron zcaron brokenbar Eth eth Yacute yacute Thorn thorn minus multiply onesuperior twosuperior threesuperior onehalf onequarter threequarters franc Gbreve gbreve Idotaccent Scedilla scedilla Cacute cacute Ccaron ccaron dcroat".split(/\s+/g);
  return class extends Table {
    parse(data23) {
      data23.offset(this.offset);
      this.format = data23.readLong();
      this.italicAngle = data23.readFixed_();
      this.underlinePosition = data23.readShort_();
      this.underlineThickness = data23.readShort_();
      this.isFixedPitch = data23.readLong();
      this.minMemType42 = data23.readLong();
      this.maxMemType42 = data23.readLong();
      this.minMemType1 = data23.readLong();
      this.maxMemType1 = data23.readLong();
      var numberOfGlyphs;
      switch (this.format) {
        case 65536:
        case 196608:
          break;
        case 131072:
          numberOfGlyphs = data23.readShort();
          this.glyphNameIndex = data23.times(numberOfGlyphs, data23.readShort);
          this.names = [];
          var limit2 = this.offset + this.length;
          while (data23.offset() < limit2) {
            this.names.push(data23.readString(data23.readByte()));
          }
          break;
        case 151552:
          numberOfGlyphs = data23.readShort();
          this.offsets = data23.read(numberOfGlyphs);
          break;
        case 262144:
          this.map = data23.times(this.file.maxp.numGlyphs, data23.readShort);
          break;
      }
    }
    glyphFor(code) {
      switch (this.format) {
        case 65536:
          return POSTSCRIPT_GLYPHS[code] || ".notdef";
        case 131072:
          var index = this.glyphNameIndex[code];
          if (index < POSTSCRIPT_GLYPHS.length) {
            return POSTSCRIPT_GLYPHS[index];
          }
          return this.names[index - POSTSCRIPT_GLYPHS.length] || ".notdef";
        case 151552:
        case 196608:
          return ".notdef";
        case 262144:
          return this.map[code] || 65535;
      }
    }
    render(mapping) {
      if (this.format == 196608) {
        return this.raw();
      }
      var out = BinaryStream(this.rawData.slice(this.offset, 32));
      out.writeLong(131072);
      out.offset(32);
      var indexes = [];
      var strings = [];
      for (var i = 0; i < mapping.length; ++i) {
        var id = mapping[i];
        var post = this.glyphFor(id);
        var index = POSTSCRIPT_GLYPHS.indexOf(post);
        if (index >= 0) {
          indexes.push(index);
        } else {
          indexes.push(POSTSCRIPT_GLYPHS.length + strings.length);
          strings.push(post);
        }
      }
      out.writeShort(mapping.length);
      for (i = 0; i < indexes.length; ++i) {
        out.writeShort(indexes[i]);
      }
      for (i = 0; i < strings.length; ++i) {
        out.writeByte(strings[i].length);
        out.writeString(strings[i]);
      }
      return out.get();
    }
  };
}();
var CmapTable = /* @__PURE__ */ function() {
  class CmapEntry {
    constructor(data23, offset, codeMap) {
      var self = this;
      self.platformID = data23.readShort();
      self.platformSpecificID = data23.readShort();
      self.offset = offset + data23.readLong();
      data23.saveExcursion(function() {
        var code;
        data23.offset(self.offset);
        self.format = data23.readShort();
        switch (self.format) {
          case 0:
            self.length = data23.readShort();
            self.language = data23.readShort();
            for (var i = 0; i < 256; ++i) {
              codeMap[i] = data23.readByte();
            }
            break;
          case 4:
            self.length = data23.readShort();
            self.language = data23.readShort();
            var segCount = data23.readShort() / 2;
            data23.skip(6);
            var endCode = data23.times(segCount, data23.readShort);
            data23.skip(2);
            var startCode = data23.times(segCount, data23.readShort);
            var idDelta = data23.times(segCount, data23.readShort_);
            var idRangeOffset = data23.times(segCount, data23.readShort);
            var count = (self.length + self.offset - data23.offset()) / 2;
            var glyphIds = data23.times(count, data23.readShort);
            for (i = 0; i < segCount; ++i) {
              var start = startCode[i], end = endCode[i];
              for (code = start; code <= end; ++code) {
                var glyphId;
                if (idRangeOffset[i] === 0) {
                  glyphId = code + idDelta[i];
                } else {
                  var index = idRangeOffset[i] / 2 - (segCount - i) + (code - start);
                  glyphId = glyphIds[index] || 0;
                  if (glyphId !== 0) {
                    glyphId += idDelta[i];
                  }
                }
                codeMap[code] = glyphId & 65535;
              }
            }
            break;
          case 6:
            self.length = data23.readShort();
            self.language = data23.readShort();
            code = data23.readShort();
            var length = data23.readShort();
            while (length-- > 0) {
              codeMap[code++] = data23.readShort();
            }
            break;
          case 12:
            data23.readShort();
            self.length = data23.readLong();
            self.language = data23.readLong();
            var ngroups = data23.readLong();
            while (ngroups-- > 0) {
              code = data23.readLong();
              var endCharCode = data23.readLong();
              var glyphCode = data23.readLong();
              while (code <= endCharCode) {
                codeMap[code++] = glyphCode++;
              }
            }
            break;
          default:
            if (window.console) {
              window.console.error("Unhandled CMAP format: " + self.format);
            }
        }
      });
    }
  }
  function renderCharmap(ncid2ogid, ogid2ngid) {
    var codes = sortedKeys(ncid2ogid);
    var startCodes = [];
    var endCodes = [];
    var last2 = null;
    var diff = null;
    function new_gid(charcode) {
      return ogid2ngid[ncid2ogid[charcode]];
    }
    for (var i = 0; i < codes.length; ++i) {
      var code = codes[i];
      var gid = new_gid(code);
      var delta = gid - code;
      if (last2 == null || delta !== diff) {
        if (last2) {
          endCodes.push(last2);
        }
        startCodes.push(code);
        diff = delta;
      }
      last2 = code;
    }
    if (last2) {
      endCodes.push(last2);
    }
    endCodes.push(65535);
    startCodes.push(65535);
    var segCount = startCodes.length;
    var segCountX2 = segCount * 2;
    var searchRange = 2 * Math.pow(2, Math.floor(Math.log(segCount) / Math.LN2));
    var entrySelector = Math.log(searchRange / 2) / Math.LN2;
    var rangeShift = segCountX2 - searchRange;
    var deltas = [];
    var rangeOffsets = [];
    var glyphIds = [];
    for (i = 0; i < segCount; ++i) {
      var startCode = startCodes[i];
      var endCode = endCodes[i];
      if (startCode == 65535) {
        deltas.push(0);
        rangeOffsets.push(0);
        break;
      }
      var startGlyph = new_gid(startCode);
      if (startCode - startGlyph >= 32768) {
        deltas.push(0);
        rangeOffsets.push(2 * (glyphIds.length + segCount - i));
        for (var j = startCode; j <= endCode; ++j) {
          glyphIds.push(new_gid(j));
        }
      } else {
        deltas.push(startGlyph - startCode);
        rangeOffsets.push(0);
      }
    }
    var out = BinaryStream();
    out.writeShort(3);
    out.writeShort(1);
    out.writeLong(12);
    out.writeShort(4);
    out.writeShort(16 + segCount * 8 + glyphIds.length * 2);
    out.writeShort(0);
    out.writeShort(segCountX2);
    out.writeShort(searchRange);
    out.writeShort(entrySelector);
    out.writeShort(rangeShift);
    endCodes.forEach(out.writeShort);
    out.writeShort(0);
    startCodes.forEach(out.writeShort);
    deltas.forEach(out.writeShort_);
    rangeOffsets.forEach(out.writeShort);
    glyphIds.forEach(out.writeShort);
    return out.get();
  }
  return class extends Table {
    parse(data23) {
      var self = this;
      var offset = self.offset;
      data23.offset(offset);
      self.codeMap = {};
      self.version = data23.readShort();
      var tableCount = data23.readShort();
      self.tables = data23.times(tableCount, function() {
        return new CmapEntry(data23, offset, self.codeMap);
      });
    }
    static render(ncid2ogid, ogid2ngid) {
      var out = BinaryStream();
      out.writeShort(0);
      out.writeShort(1);
      out.write(renderCharmap(ncid2ogid, ogid2ngid));
      return out.get();
    }
  };
}();
var OS2Table = class extends Table {
  parse(data23) {
    data23.offset(this.offset);
    this.version = data23.readShort();
    this.averageCharWidth = data23.readShort_();
    this.weightClass = data23.readShort();
    this.widthClass = data23.readShort();
    this.type = data23.readShort();
    this.ySubscriptXSize = data23.readShort_();
    this.ySubscriptYSize = data23.readShort_();
    this.ySubscriptXOffset = data23.readShort_();
    this.ySubscriptYOffset = data23.readShort_();
    this.ySuperscriptXSize = data23.readShort_();
    this.ySuperscriptYSize = data23.readShort_();
    this.ySuperscriptXOffset = data23.readShort_();
    this.ySuperscriptYOffset = data23.readShort_();
    this.yStrikeoutSize = data23.readShort_();
    this.yStrikeoutPosition = data23.readShort_();
    this.familyClass = data23.readShort_();
    this.panose = data23.times(10, data23.readByte);
    this.charRange = data23.times(4, data23.readLong);
    this.vendorID = data23.readString(4);
    this.selection = data23.readShort();
    this.firstCharIndex = data23.readShort();
    this.lastCharIndex = data23.readShort();
    if (this.version > 0) {
      this.ascent = data23.readShort_();
      this.descent = data23.readShort_();
      this.lineGap = data23.readShort_();
      this.winAscent = data23.readShort();
      this.winDescent = data23.readShort();
      this.codePageRange = data23.times(2, data23.readLong);
      if (this.version > 1) {
        this.xHeight = data23.readShort();
        this.capHeight = data23.readShort();
        this.defaultChar = data23.readShort();
        this.breakChar = data23.readShort();
        this.maxContext = data23.readShort();
      }
    }
  }
  render() {
    return this.raw();
  }
};
var subsetTag = 1e5;
function nextSubsetTag() {
  var ret = "", n = String(subsetTag);
  for (var i = 0; i < n.length; ++i) {
    ret += String.fromCharCode(n.charCodeAt(i) - 48 + 65);
  }
  ++subsetTag;
  return ret;
}
var Subfont = class {
  constructor(font) {
    this.font = font;
    this.subset = {};
    this.unicodes = {};
    this.ogid2ngid = { 0: 0 };
    this.ngid2ogid = { 0: 0 };
    this.ncid2ogid = {};
    this.next = this.firstChar = 1;
    this.nextGid = 1;
    this.psName = nextSubsetTag() + "+" + this.font.psName;
  }
  use(ch) {
    var self = this;
    if (typeof ch == "string") {
      return ucs2decode(ch).reduce(function(ret, code2) {
        return ret + String.fromCharCode(self.use(code2));
      }, "");
    }
    var code = self.unicodes[ch];
    if (!code) {
      code = self.next++;
      self.subset[code] = ch;
      self.unicodes[ch] = code;
      var old_gid = self.font.cmap.codeMap[ch];
      if (old_gid) {
        self.ncid2ogid[code] = old_gid;
        if (self.ogid2ngid[old_gid] == null) {
          var new_gid = self.nextGid++;
          self.ogid2ngid[old_gid] = new_gid;
          self.ngid2ogid[new_gid] = old_gid;
        }
      }
    }
    return code;
  }
  encodeText(text) {
    return this.use(text);
  }
  glyphIds() {
    return sortedKeys(this.ogid2ngid);
  }
  glyphsFor(glyphIds, result) {
    if (!result) {
      result = {};
    }
    for (var i = 0; i < glyphIds.length; ++i) {
      var id = glyphIds[i];
      if (!result[id]) {
        var glyph = result[id] = this.font.glyf.glyphFor(id);
        if (glyph && glyph.compound) {
          this.glyphsFor(glyph.glyphIds, result);
        }
      }
    }
    return result;
  }
  render() {
    var glyphs = this.glyphsFor(this.glyphIds());
    for (var old_gid in glyphs) {
      if (hasOwnProperty(glyphs, old_gid)) {
        old_gid = parseInt(old_gid, 10);
        if (this.ogid2ngid[old_gid] == null) {
          var new_gid = this.nextGid++;
          this.ogid2ngid[old_gid] = new_gid;
          this.ngid2ogid[new_gid] = old_gid;
        }
      }
    }
    var new_gid_ids = sortedKeys(this.ngid2ogid);
    var old_gid_ids = new_gid_ids.map(function(id) {
      return this.ngid2ogid[id];
    }, this);
    var font = this.font;
    var glyf = font.glyf.render(glyphs, old_gid_ids, this.ogid2ngid);
    var loca = font.loca.render(glyf.offsets);
    this.lastChar = this.next - 1;
    var tables = {
      "cmap": CmapTable.render(this.ncid2ogid, this.ogid2ngid),
      "glyf": glyf.table,
      "loca": loca.table,
      "hmtx": font.hmtx.render(old_gid_ids),
      "hhea": font.hhea.render(old_gid_ids),
      "maxp": font.maxp.render(old_gid_ids),
      "post": font.post.render(old_gid_ids),
      "name": font.name.render(this.psName),
      "head": font.head.render(loca.format),
      "OS/2": font.os2.render()
    };
    return this.font.directory.render(tables);
  }
  cidToGidMap() {
    var out = BinaryStream(), len = 0;
    for (var cid = this.firstChar; cid < this.next; ++cid) {
      while (len < cid) {
        out.writeShort(0);
        len++;
      }
      var old_gid = this.ncid2ogid[cid];
      if (old_gid) {
        var new_gid = this.ogid2ngid[old_gid];
        out.writeShort(new_gid);
      } else {
        out.writeShort(0);
      }
      len++;
    }
    return out.get();
  }
};
var TTFFont = class {
  constructor(rawData, name3) {
    var self = this;
    var data23 = self.contents = BinaryStream(rawData);
    if (data23.readString(4) == "ttcf") {
      var offset;
      const parse = function() {
        data23.offset(offset);
        self.parse();
      };
      if (!name3) {
        throw new Error("Must specify a name for TTC files");
      }
      data23.readLong();
      var numFonts = data23.readLong();
      for (var i = 0; i < numFonts; ++i) {
        offset = data23.readLong();
        data23.saveExcursion(parse);
        if (self.psName == name3) {
          return;
        }
      }
      throw new Error("Font " + name3 + " not found in collection");
    } else {
      data23.offset(0);
      self.parse();
    }
  }
  parse() {
    var dir = this.directory = new Directory(this.contents);
    this.head = dir.readTable("head", HeadTable);
    this.loca = dir.readTable("loca", LocaTable);
    this.hhea = dir.readTable("hhea", HheaTable);
    this.maxp = dir.readTable("maxp", MaxpTable);
    this.hmtx = dir.readTable("hmtx", HmtxTable);
    this.glyf = dir.readTable("glyf", GlyfTable);
    this.name = dir.readTable("name", NameTable);
    this.post = dir.readTable("post", PostTable);
    this.cmap = dir.readTable("cmap", CmapTable);
    this.os2 = dir.readTable("OS/2", OS2Table);
    this.psName = this.name.postscriptName;
    this.ascent = this.os2.ascent || this.hhea.ascent;
    this.descent = this.os2.descent || this.hhea.descent;
    this.lineGap = this.os2.lineGap || this.hhea.lineGap;
    this.scale = 1e3 / this.head.unitsPerEm;
  }
  widthOfGlyph(glyph) {
    return this.hmtx.forGlyph(glyph).advance * this.scale;
  }
  makeSubset() {
    return new Subfont(this);
  }
};

// node_modules/@progress/pako-esm/dist/pako-esm5.js
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
var Z_SYNC_FLUSH = 2;
var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_BUF_ERROR = -5;
var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN = 2;
var Z_DEFLATED = 8;
function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function assign(obj) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
}
function shrinkBuf(buf, size2) {
  if (buf.length === size2) {
    return buf;
  }
  if (buf.subarray) {
    return buf.subarray(0, size2);
  }
  buf.length = size2;
  return buf;
}
var fnTyped = {
  arraySet: function(dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function(chunks) {
    var i, l, len, pos, chunk, result;
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  },
  Buf8: function(size2) {
    return new Uint8Array(size2);
  },
  Buf16: function(size2) {
    return new Uint16Array(size2);
  },
  Buf32: function(size2) {
    return new Int32Array(size2);
  }
};
var fnUntyped = {
  arraySet: function(dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function(chunks) {
    return [].concat.apply([], chunks);
  },
  Buf8: function(size2) {
    return new Array(size2);
  },
  Buf16: function(size2) {
    return new Array(size2);
  },
  Buf32: function(size2) {
    return new Array(size2);
  }
};
var typedOK = function() {
  var supported = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  typedOK = function() {
    return supported;
  };
  return supported;
};
var arraySet = function(dest, src, src_offs, len, dest_offs) {
  arraySet = typedOK() ? fnTyped.arraySet : fnUntyped.arraySet;
  return arraySet(dest, src, src_offs, len, dest_offs);
};
var flattenChunks = function(chunks) {
  flattenChunks = typedOK() ? fnTyped.flattenChunks : fnUntyped.flattenChunks;
  return flattenChunks(chunks);
};
var Buf8 = function(size2) {
  Buf8 = typedOK() ? fnTyped.Buf8 : fnUntyped.Buf8;
  return Buf8(size2);
};
var Buf16 = function(size2) {
  Buf16 = typedOK() ? fnTyped.Buf16 : fnUntyped.Buf16;
  return Buf16(size2);
};
var Buf32 = function(size2) {
  Buf32 = typedOK() ? fnTyped.Buf32 : fnUntyped.Buf32;
  return Buf32(size2);
};
var strApplyOK = function() {
  var result = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (_) {
    result = false;
  }
  strApplyOK = function() {
    return result;
  };
  return result;
};
var strApplyUintOK = function() {
  var result = true;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (_) {
    result = false;
  }
  strApplyUintOK = function() {
    return result;
  };
  return result;
};
var utf8len = function(c) {
  var table = Buf8(256);
  for (var q = 0; q < 256; q++) {
    table[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  table[254] = table[254] = 1;
  utf8len = function(arg) {
    return table[arg];
  };
  return table[c];
};
function string2buf(str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
}
function _buf2binstring(buf, len) {
  if (len < 65534) {
    if (buf.subarray && strApplyUintOK() || !buf.subarray && strApplyOK()) {
      return String.fromCharCode.apply(null, shrinkBuf(buf, len));
    }
  }
  var result = "";
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}
function buf2binstring(buf) {
  return _buf2binstring(buf, buf.length);
}
function binstring2buf(str) {
  var buf = new Uint8Array(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
}
function buf2string(buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;
  var utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    c_len = utf8len(c);
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return _buf2binstring(utf16buf, out);
}
function utf8border(buf, max) {
  var pos;
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + utf8len(buf[pos]) > max ? pos : max;
}
function adler32(adler, buf, len, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
function makeTable() {
  var c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
}
var crcTable = function() {
  var table = makeTable();
  crcTable = function() {
    return table;
  };
  return table;
};
function crc32(crc, buf, len, pos) {
  var t = crcTable(), end = pos + len;
  crc ^= -1;
  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
var BAD = 30;
var TYPE = 12;
function inflate_fast(strm, start) {
  var state;
  var _in;
  var last2;
  var _out;
  var beg;
  var end;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len;
  var dist;
  var from;
  var from_source;
  var input, output;
  state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break top;
          }
          break;
        }
    } while (_in < last2 && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
}
var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var lbase = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits;
  var len = 0;
  var sym = 0;
  var min = 0, max = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill;
  var low;
  var mask4;
  var next;
  var base = null;
  var base_index = 0;
  var end;
  var count = Buf16(MAXBITS + 1);
  var offs = Buf16(MAXBITS + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES) {
    base = extra = work;
    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase;
    extra = dext;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask4 = used - 1;
  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask4) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      low = huff & mask4;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
}
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var Z_FINISH$1 = 4;
var Z_BLOCK$1 = 5;
var Z_TREES$1 = 6;
var Z_OK$1 = 0;
var Z_STREAM_END$1 = 1;
var Z_NEED_DICT$1 = 2;
var Z_STREAM_ERROR$1 = -2;
var Z_DATA_ERROR$1 = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR$1 = -5;
var Z_DEFLATED$1 = 8;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE$1 = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD$1 = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
function zswap32(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = Buf16(320);
  this.work = Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = Buf32(ENOUGH_LENS$1);
  state.distcode = state.distdyn = Buf32(ENOUGH_DISTS$1);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
}
function inflateReset(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
  var wrap2;
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap2;
  state.wbits = windowBits;
  return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
  var ret;
  var state;
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  state = new InflateState();
  strm.state = state;
  state.window = null;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
}
var virgin = true;
var lenfix;
var distfix;
function fixedtables(state) {
  if (virgin) {
    var sym;
    lenfix = Buf32(512);
    distfix = Buf32(32);
    sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inflate_table(LENS$1, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inflate_table(DISTS$1, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = Buf8(state.wsize);
  }
  if (copy >= state.wsize) {
    arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
}
function inflate(strm, flush) {
  var state;
  var input, output;
  var next;
  var put;
  var have, left;
  var hold;
  var bits;
  var _in, _out;
  var copy;
  var from;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len;
  var ret;
  var hbuf = Buf8(4);
  var opts;
  var n;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE$1) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD$1;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED$1) {
            strm.msg = "unknown compression method";
            state.mode = BAD$1;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          } else if (len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD$1;
            break;
          }
          state.dmax = 1 << len;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE$1;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED$1) {
            strm.msg = "unknown compression method";
            state.mode = BAD$1;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD$1;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Array(state.head.extra_len);
                }
                arraySet(
                  state.head.extra,
                  input,
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE$1;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE$1;
        case TYPE$1:
          if (flush === Z_BLOCK$1 || flush === Z_TREES$1) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES$1) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD$1;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD$1;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES$1) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            arraySet(output, input, next, copy, put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE$1;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD$1;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inflate_table(CODES$1, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD$1;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD$1;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD$1;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD$1) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD$1;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inflate_table(LENS$1, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD$1;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inflate_table(DISTS$1, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD$1;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES$1) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inflate_fast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE$1) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE$1;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD$1;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD$1;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD$1;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
              state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD$1:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD$1 && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE$1 ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR$1;
  }
  return ret;
}
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
}
function inflateGetHeader(strm, head) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
}
function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  return Z_OK$1;
}
var msg = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var toString2 = Object.prototype.toString;
var Inflate = function Inflate2(options2) {
  if (!(this instanceof Inflate2)) {
    return new Inflate2(options2);
  }
  this.options = assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ""
  }, options2 || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream();
  this.strm.avail_out = 0;
  var status = inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }
  this.header = new GZheader();
  inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = string2buf(opt.dictionary);
    } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
};
Inflate.prototype.push = function push(data23, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;
  var allowBufError = false;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (typeof data23 === "string") {
    strm.input = binstring2buf(data23);
  } else if (toString2.call(data23) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data23);
  } else {
    strm.input = data23;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate(strm, Z_NO_FLUSH);
    if (status === Z_NEED_DICT && dictionary) {
      if (typeof dictionary === "string") {
        dict = string2buf(dictionary);
      } else if (toString2.call(dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }
      status = inflateSetDictionary(this.strm, dict);
    }
    if (status === Z_BUF_ERROR && allowBufError === true) {
      status = Z_OK;
      allowBufError = false;
    }
    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          next_out_utf8 = utf8border(strm.output, strm.next_out);
          tail = strm.next_out - next_out_utf8;
          utf8str = buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }
          this.onData(utf8str);
        } else {
          this.onData(shrinkBuf(strm.output, strm.next_out));
        }
      }
    }
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
  if (status === Z_STREAM_END) {
    _mode = Z_FINISH;
  }
  if (_mode === Z_FINISH) {
    status = inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Inflate.prototype.onData = function onData(chunk) {
  this.chunks.push(chunk);
};
Inflate.prototype.onEnd = function onEnd(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function zero(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN = 512;
var static_ltree;
var static_dtree;
var _dist_code;
var _length_code;
var base_length;
var base_dist;
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
function put_short(s, w) {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
}
function send_bits(s, value2, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value2 << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value2 >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value2 << s.bi_valid & 65535;
    s.bi_valid += length;
  }
}
function send_code(s, c, tree) {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
}
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
function gen_bitlen(s, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  var n, m;
  var bits;
  var xbits;
  var f;
  var overflow = 0;
  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
}
function gen_codes(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS + 1);
  var code = 0;
  var bits;
  var n;
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
}
function tr_static_init() {
  var n;
  var bits;
  var length;
  var code;
  var dist;
  var bl_count = new Array(MAX_BITS + 1);
  static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  base_length = new Array(LENGTH_CODES);
  zero(base_length);
  base_dist = new Array(D_CODES);
  zero(base_dist);
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES + 1, bl_count);
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
}
function init_block(s) {
  var n;
  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}
function copy_block(s, buf, len, header) {
  bi_windup(s);
  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
  arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
}
function pqdownheap(s, tree, k) {
  var v = s.heap[k];
  var j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
}
function compress_block(s, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code;
  var extra;
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (lx < s.last_lit);
  }
  send_code(s, END_BLOCK, ltree);
}
function build_tree(s, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m;
  var max_code = -1;
  var node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
}
function scan_tree(s, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree(s, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree(s) {
  var max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees(s, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
}
function detect_data_type(s) {
  var black_mask = 4093624447;
  var n;
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
}
var static_init_done = false;
function _tr_init(s) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
}
function _tr_stored_block(s, buf, stored_len, last2) {
  send_bits(s, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
  copy_block(s, buf, stored_len, true);
}
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}
function _tr_flush_block(s, buf, stored_len, last2) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s, buf, stored_len, last2);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last2) {
    bi_windup(s);
  }
}
function _tr_tally(s, dist, lc) {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
  s.last_lit++;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.last_lit === s.lit_bufsize - 1;
}
var MAX_MEM_LEVEL = 9;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var MIN_LOOKAHEAD = MAX_MATCH$1 + MIN_MATCH$1 + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}
function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}
function zero$1(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function flush_pending(strm) {
  var s = strm.state;
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}
function flush_block_only(s, last2) {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}
function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}
function putShortMSB(s, b) {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
}
function read_buf(strm, buf, start, size2) {
  var len = strm.avail_in;
  if (len > size2) {
    len = size2;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
}
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;
  var scan = s.strstart;
  var match;
  var len;
  var best_len = s.prev_length;
  var nice_match = s.nice_match;
  var limit2 = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  var _win = s.window;
  var wmask = s.w_mask;
  var prev = s.prev;
  var strend = s.strstart + MAX_MATCH$1;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH$1 - (strend - scan);
    scan = strend - MAX_MATCH$1;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit2 && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH$1) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
      while (s.insert) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH$1 - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH$1) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
}
function deflate_stored(s, flush) {
  var max_block_size = 65535;
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s.lookahead <= 1) {
      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.strstart += s.lookahead;
    s.lookahead = 0;
    var max_start = s.block_start + max_block_size;
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.strstart > s.block_start) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
}
function deflate_fast(s, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$1) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH$1) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH$1) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_slow(s, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$1) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH$1 - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH$1 - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH$1;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH$1 - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_rle(s, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH$1) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH$1;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH$1 - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH$1) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH$1);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_huff(s, flush) {
  var bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configurationTable = function() {
  var table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  configurationTable = function() {
    return table;
  };
  return table;
};
function lm_init(s) {
  s.window_size = 2 * s.w_size;
  zero$1(s.head);
  var table = configurationTable();
  s.max_lazy_match = table[s.level].max_lazy;
  s.good_match = table[s.level].good_length;
  s.nice_match = table[s.level].nice_length;
  s.max_chain_length = table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
  s.match_available = 0;
  s.ins_h = 0;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = Buf16(HEAP_SIZE$1 * 2);
  this.dyn_dtree = Buf16((2 * D_CODES$1 + 1) * 2);
  this.bl_tree = Buf16((2 * BL_CODES$1 + 1) * 2);
  zero$1(this.dyn_ltree);
  zero$1(this.dyn_dtree);
  zero$1(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = Buf16(MAX_BITS$1 + 1);
  this.heap = Buf16(2 * L_CODES$1 + 1);
  zero$1(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = Buf16(2 * L_CODES$1 + 1);
  zero$1(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep(strm) {
  var s;
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = Z_NO_FLUSH;
  _tr_init(s);
  return Z_OK;
}
function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}
function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }
  strm.state.gzhead = head;
  return Z_OK;
}
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  var wrap2 = 1;
  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap2;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);
  s.window = Buf8(s.w_size * 2);
  s.head = Buf16(s.hash_size);
  s.prev = Buf16(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = Buf8(s.pending_buf_size);
  s.d_buf = 1 * s.lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
}
function deflate(strm, flush) {
  var old_flush, s;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }
  s = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }
  s.strm = strm;
  old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      strm.adler = 0;
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(
          s,
          (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 255);
        put_byte(s, s.gzhead.time >> 8 & 255);
        put_byte(s, s.gzhead.time >> 16 & 255);
        put_byte(s, s.gzhead.time >> 24 & 255);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 255);
          put_byte(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else {
      var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s.status = BUSY_STATE;
      putShortMSB(s, header);
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      beg = s.pending;
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 255);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        strm.adler = 0;
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configurationTable()[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero$1(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    }
  }
  if (flush !== Z_FINISH) {
    return Z_OK;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}
function deflateEnd(strm) {
  var status;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s;
  var str, n;
  var wrap2;
  var avail;
  var next;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  s = strm.state;
  wrap2 = s.wrap;
  if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR;
  }
  if (wrap2 === 1) {
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap2 === 0) {
      zero$1(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    tmpDict = Buf8(s.w_size);
    arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH$1) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH$1 - 1);
    do {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH$1 - 1]) & s.hash_mask;
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH$1 - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap2;
  return Z_OK;
}
var toString$1 = Object.prototype.toString;
var Deflate = function Deflate2(options2) {
  this.options = assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ""
  }, options2 || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream();
  this.strm.avail_out = 0;
  var status = deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }
  if (opt.header) {
    deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    var dict;
    if (typeof opt.dictionary === "string") {
      dict = string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    this._dict_set = true;
  }
};
Deflate.prototype.push = function push2(data23, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (typeof data23 === "string") {
    strm.input = string2buf(data23);
  } else if (toString$1.call(data23) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data23);
  } else {
    strm.input = data23;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = deflate(strm, _mode);
    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
      if (this.options.to === "string") {
        this.onData(buf2binstring(shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
  if (_mode === Z_FINISH) {
    status = deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Deflate.prototype.onData = function onData2(chunk) {
  this.chunks.push(chunk);
};
Deflate.prototype.onEnd = function onEnd2(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

// node_modules/@progress/kendo-drawing/dist/es/pdf/core.js
var browser4 = support_default.browser;
var FONT_CACHE = {
  "Times-Roman": true,
  "Times-Bold": true,
  "Times-Italic": true,
  "Times-BoldItalic": true,
  "Helvetica": true,
  "Helvetica-Bold": true,
  "Helvetica-Oblique": true,
  "Helvetica-BoldOblique": true,
  "Courier": true,
  "Courier-Bold": true,
  "Courier-Oblique": true,
  "Courier-BoldOblique": true,
  "Symbol": true,
  "ZapfDingbats": true
};
function loadBinary(url, cont) {
  let m;
  if (browser4.msie && (m = /^data:.*?;base64,/i.exec(url))) {
    cont(base64ToUint8Array(url.substr(m[0].length)));
    return;
  }
  function error() {
    if (window.console) {
      if (window.console.error) {
        window.console.error("Cannot load URL: %s", url);
      } else {
        window.console.log("Cannot load URL: %s", url);
      }
    }
    cont(null);
  }
  var req = new XMLHttpRequest();
  req.open("GET", url, true);
  if (HAS_TYPED_ARRAYS) {
    req.responseType = "arraybuffer";
  }
  req.onload = function() {
    if (req.status == 200 || req.status == 304) {
      if (HAS_TYPED_ARRAYS) {
        cont(new Uint8Array(req.response));
      } else {
        cont(new window.VBArray(req.responseBody).toArray());
      }
    } else {
      error();
    }
  };
  req.onerror = error;
  req.send(null);
}
function loadFont(url, cont) {
  var font = FONT_CACHE[url];
  if (font) {
    cont(font);
  } else {
    loadBinary(url, function(data23) {
      if (data23 == null) {
        throw new Error("Cannot load font from " + url);
      } else {
        var font2 = new TTFFont(data23);
        FONT_CACHE[url] = font2;
        cont(font2);
      }
    });
  }
}
function manyLoader(loadOne) {
  return function(urls, callback) {
    var n = urls.length, i = n;
    if (n === 0) {
      return callback();
    }
    function next() {
      if (--n === 0) {
        callback();
      }
    }
    while (i-- > 0) {
      loadOne(urls[i], next);
    }
  };
}
var loadFonts = manyLoader(loadFont);
var isArray = Array.isArray || function(obj) {
  return obj instanceof Array;
};
var FONT_MAPPINGS = {
  "serif": "Times-Roman",
  "serif|bold": "Times-Bold",
  "serif|italic": "Times-Italic",
  "serif|bold|italic": "Times-BoldItalic",
  "sans-serif": "Helvetica",
  "sans-serif|bold": "Helvetica-Bold",
  "sans-serif|italic": "Helvetica-Oblique",
  "sans-serif|bold|italic": "Helvetica-BoldOblique",
  "monospace": "Courier",
  "monospace|bold": "Courier-Bold",
  "monospace|italic": "Courier-Oblique",
  "monospace|bold|italic": "Courier-BoldOblique",
  "zapfdingbats": "ZapfDingbats",
  "zapfdingbats|bold": "ZapfDingbats",
  "zapfdingbats|italic": "ZapfDingbats",
  "zapfdingbats|bold|italic": "ZapfDingbats"
};
function fontAlias(alias, name3) {
  alias = alias.toLowerCase();
  FONT_MAPPINGS[alias] = function() {
    return FONT_MAPPINGS[name3];
  };
  FONT_MAPPINGS[alias + "|bold"] = function() {
    return FONT_MAPPINGS[name3 + "|bold"];
  };
  FONT_MAPPINGS[alias + "|italic"] = function() {
    return FONT_MAPPINGS[name3 + "|italic"];
  };
  FONT_MAPPINGS[alias + "|bold|italic"] = function() {
    return FONT_MAPPINGS[name3 + "|bold|italic"];
  };
}
fontAlias("Times New Roman", "serif");
fontAlias("Courier New", "monospace");
fontAlias("Arial", "sans-serif");
fontAlias("Helvetica", "sans-serif");
fontAlias("Verdana", "sans-serif");
fontAlias("Tahoma", "sans-serif");
fontAlias("Georgia", "sans-serif");
fontAlias("Monaco", "monospace");
fontAlias("Andale Mono", "monospace");

// node_modules/@progress/kendo-drawing/dist/es/html/core.js
var browser5 = support_default.browser || {};
function slice2(thing) {
  return Array.prototype.slice.call(thing);
}
var nodeInfo = {};
nodeInfo._root = nodeInfo;
var inBrowser = typeof window !== "undefined";
var microsoft = inBrowser ? browser5.msie || browser5.edge : false;
var matches = typeof Element !== "undefined" && Element.prototype && function(p) {
  if (p.matches) {
    return function(el, selector) {
      return el.matches(selector);
    };
  }
  if (p.webkitMatchesSelector) {
    return function(el, selector) {
      return el.webkitMatchesSelector(selector);
    };
  }
  if (p.mozMatchesSelector) {
    return function(el, selector) {
      return el.mozMatchesSelector(selector);
    };
  }
  if (p.msMatchesSelector) {
    return function(el, selector) {
      return el.msMatchesSelector(selector);
    };
  }
  return function(s) {
    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
  };
}(Element.prototype);
var cloneNodes = function($) {
  if ($) {
    return function cloneNodes2(el) {
      var clone = el.cloneNode(false);
      if (el.nodeType == 1) {
        var $el = $(el), $clone = $(clone), i;
        var data23 = $el.data();
        for (i in data23) {
          $clone.data(i, data23[i]);
        }
        if (/^canvas$/i.test(el.tagName)) {
          clone.getContext("2d").drawImage(el, 0, 0);
        } else if (/^(?:input|select|textarea|option)$/i.test(el.tagName)) {
          clone.removeAttribute("id");
          clone.removeAttribute("name");
          if (!/^textarea$/i.test(el.tagName)) {
            clone.value = el.value;
          }
          clone.checked = el.checked;
          clone.selected = el.selected;
        } else if (/^img$/i.test(el.tagName)) {
          clone.removeAttribute("loading");
        }
        if (el._kendoExportVisual) {
          clone._kendoExportVisual = el._kendoExportVisual;
        }
        for (i = el.firstChild; i; i = i.nextSibling) {
          clone.appendChild(cloneNodes2(i));
        }
      }
      return clone;
    };
  } else {
    return function cloneNodes2(el) {
      const clone = function dive(node) {
        const clone2 = node.cloneNode(false);
        if (node._kendoExportVisual) {
          clone2._kendoExportVisual = node._kendoExportVisual;
        }
        for (let i = node.firstChild; i; i = i.nextSibling) {
          clone2.appendChild(dive(i));
        }
        return clone2;
      }(el);
      const canvases = el.querySelectorAll("canvas");
      if (canvases.length) {
        slice2(clone.querySelectorAll("canvas")).forEach((canvas, i) => {
          canvas.getContext("2d").drawImage(canvases[i], 0, 0);
        });
      }
      const orig = el.querySelectorAll("input, select, textarea, option");
      slice2(clone.querySelectorAll("input, select, textarea, option")).forEach((el2, i) => {
        el2.removeAttribute("id");
        el2.removeAttribute("name");
        if (!/^textarea$/i.test(el2.tagName)) {
          el2.value = orig[i].value;
        }
        el2.checked = orig[i].checked;
        el2.selected = orig[i].selected;
      });
      slice2(clone.querySelectorAll("img")).forEach((img) => {
        img.removeAttribute("loading");
      });
      return clone;
    };
  }
}(typeof window !== "undefined" && window.kendo && window.kendo.jQuery);

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/utils/color-parser.js
var parseColor2 = function(value2, format, opacityEnabled, safe) {
  if (opacityEnabled === void 0) {
    opacityEnabled = false;
  }
  if (safe === void 0) {
    safe = true;
  }
  var allowedFormats = ["hex", "rgba"];
  if (allowedFormats.indexOf(format) === -1) {
    throw new Error("Unsupported color output format '".concat(format, "'. The available options are 'hex' or 'rgba'."));
  }
  if (!isPresent(value2)) {
    return;
  }
  var parsedColor = parseColor(value2.trim(), safe);
  if (!isPresent(parsedColor)) {
    return;
  }
  return format === "hex" ? getHexValue(parsedColor, opacityEnabled) : parsedColor.toCssRgba();
};
var getHexValue = function(color, opacity) {
  return opacity && color.a < 1 ? color.toCss({ alpha: true }) : color.toCss();
};
var getHSV = function(value2, safe) {
  if (safe === void 0) {
    safe = true;
  }
  var parsed = parseColor(value2, safe);
  if (!isPresent(parsed)) {
    return {};
  }
  return parsed.toHSV();
};
var getRGBA = function(value2, safe) {
  if (safe === void 0) {
    safe = true;
  }
  var parsed = parseColor(value2, safe);
  if (!isPresent(parsed)) {
    return {};
  }
  return parsed.toBytes();
};
var getColorFromHSV = function(hsva2) {
  var hue = fitIntoBounds(hsva2.h, 0, 359.9);
  var saturation = fitIntoBounds(hsva2.s, 0, 1);
  var value2 = fitIntoBounds(hsva2.v, 0, 1);
  var alpha = fitIntoBounds(hsva2.a, 0, 1);
  return color_default.fromHSV(hue, saturation, value2, alpha).toCssRgba();
};
var getColorFromHue = function(hue) {
  return getColorFromHSV({ h: hue, s: 1, v: 1, a: 1 });
};
var getColorFromRGBA = function(rgba2) {
  var red = fitIntoBounds(rgba2.r, 0, 255);
  var green = fitIntoBounds(rgba2.g, 0, 255);
  var blue = fitIntoBounds(rgba2.b, 0, 255);
  var alpha = fitIntoBounds(rgba2.a, 0, 1);
  return color_default.fromBytes(red, green, blue, alpha).toCssRgba();
};
var getRGBFromRGBA = function(foregroundColor, backgroundColor) {
  var r1 = fitIntoBounds(foregroundColor.r, 0, 255);
  var g1 = fitIntoBounds(foregroundColor.g, 0, 255);
  var b1 = fitIntoBounds(foregroundColor.b, 0, 255);
  var a1 = fitIntoBounds(foregroundColor.a, 0, 1);
  var r2 = fitIntoBounds(backgroundColor.r, 0, 255);
  var g2 = fitIntoBounds(backgroundColor.g, 0, 255);
  var b2 = fitIntoBounds(backgroundColor.b, 0, 255);
  return {
    r: Math.round((1 - a1) * r2 + a1 * r1),
    g: Math.round((1 - a1) * g2 + a1 * g1),
    b: Math.round((1 - a1) * b2 + a1 * b1)
  };
};
var getLuminance = function(rgb) {
  var a = [rgb.r, rgb.g, rgb.b].map(function(v) {
    v /= 255;
    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  });
  return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;
};
var getContrast = function(luminance1, luminance2) {
  var brightest = Math.max(luminance1, luminance2);
  var darkest = Math.min(luminance1, luminance2);
  return (brightest + 0.05) / (darkest + 0.05);
};
var getContrastFromTwoRGBAs = function(a, b) {
  return getContrast(getLuminance(getRGBFromRGBA(a, b)), getLuminance(getRGBFromRGBA(b, { r: 0, g: 0, b: 0, a: 1 })));
};

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/utils/color-palette.service.js
var ColorPaletteService = (
  /** @class */
  function() {
    function ColorPaletteService2() {
      this.colorRows = [];
    }
    ColorPaletteService2.prototype.setColorMatrix = function(palette, columns) {
      this.colorRows = [];
      if (!(isPresent(palette) && palette.length)) {
        return;
      }
      columns = columns || palette.length;
      for (var start = 0; start < palette.length; start += columns) {
        var row = palette.slice(start, columns + start);
        this.colorRows.push(row);
      }
    };
    ColorPaletteService2.prototype.isInColors = function(colors, current) {
      return colors.some(function(c) {
        return c === current;
      });
    };
    ColorPaletteService2.prototype.getCellCoordsFor = function(color) {
      if (!isPresent(color)) {
        return;
      }
      var parsedColor = color ? parseColor(color, true) : color;
      var colors = [color];
      if (isPresent(parsedColor)) {
        colors.push(parsedColor.toCss(), parsedColor.toCssRgba());
      }
      for (var row = 0; row < this.colorRows.length; row++) {
        for (var col = 0; col < this.colorRows[row].length; col++) {
          if (this.isInColors(colors, this.colorRows[row][col])) {
            return { row, col };
          }
        }
      }
    };
    ColorPaletteService2.prototype.getColorAt = function(cellCoords) {
      if (!(isPresent(cellCoords) && isPresent(this.colorRows[cellCoords.row]))) {
        return;
      }
      return this.colorRows[cellCoords.row][cellCoords.col];
    };
    ColorPaletteService2.prototype.getNextCell = function(current, horizontalStep, verticalStep) {
      if (!(isPresent(current) && isPresent(current.row) && isPresent(current.col))) {
        return { row: 0, col: 0 };
      }
      var row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);
      var col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);
      return { row, col };
    };
    ColorPaletteService2.prototype.clampIndex = function(index, max) {
      var minArrayIndex = 0;
      if (index < minArrayIndex) {
        return minArrayIndex;
      }
      if (index > max) {
        return max;
      }
      return index;
    };
    return ColorPaletteService2;
  }()
);

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/models/palette-presets.js
var PALETTEPRESETS = {
  basic: {
    colors: ["#000000", "#7f7f7f", "#880015", "#ed1c24", "#ff7f27", "#fff200", "#22b14c", "#00a2e8", "#3f48cc", "#a349a4", " ffffff", "#c3c3c3", "#b97a57", "#ffaec9", "#ffc90e", "#efe4b0", "#b5e61d", "#99d9ea", "#7092be", "#c8bfe7"],
    columns: 10
  },
  office: {
    colors: ["#ffffff", "#000000", "#e6e6e6", "#435569", "#4371c4", "#ed7e32", "#a5a4a5", "#febf04", "#5a9bd5", "#71ae48", "#f2f2f3", "#7f7f7f", "#d1cece", "#d5dde3", "#dae1f4", "#fce5d4", "#deeded", "#fff2cc", "#deeaf6", "#e1efd9", "#d7d8d8", "#585959", "#aeabab", "#adbaca", "#b4c5e7", "#f6caac", "#dbdbdb", "#ffe498", "#bcd6ee", "#c5e0b2", "#bfbfc0", "#3f3f3f", "#767070", "#8595b1", "#8fabdb", "#f5b183", "#c9c8c9", "#fed965", "#9bc4e5", "#a8d08d", "#a5a5a6", "#262625", "#393939", "#334050", "#2e5496", "#c45a11", "#7b7b7a", "#bf9000", "#2f75b5", "#548235", "#7f7f7f", "#0b0c0c", "#161616", "#222a34", "#203764", "#843d0b", "#525252", "#7f6000", "#1d4d79", "#375623"],
    columns: 10
  },
  apex: {
    colors: ["#ffffff", "#000000", "#c9c2d1", "#69676d", "#ceb966", "#9cb084", "#6bb1c9", "#6585cf", "#7e6bc9", "#a379bb", "#f2f2f2", "#7f7f7f", "#f4f2f5", "#e0e0e2", "#f5f1e0", "#ebefe6", "#e1eff4", "#e0e6f5", "#e5e1f4", "#ece4f1", "#d8d8d8", "#595959", "#e9e6ec", "#c2c1c5", "#ebe3c1", "#d7dfcd", "#c3dfe9", "#c1ceeb", "#cbc3e9", "#dac9e3", "#bfbfbf", "#3f3f3f", "#dedae3", "#a4a3a8", "#e1d5a3", "#c3cfb5", "#a6d0de", "#a2b5e2", "#b1a6de", "#c7aed6", "#a5a5a5", "#262626", "#9688a5", "#4e4d51", "#ae9638", "#758c5a", "#3d8da9", "#365bb0", "#533da9", "#7d4d99", "#7f7f7f", "#0c0c0c", "#635672", "#343336", "#746425", "#4e5d3c", "#295e70", "#243c75", "#372970", "#533366"],
    columns: 10
  },
  austin: {
    colors: ["#ffffff", "#000000", "#caf278", "#3e3d2d", "#94c600", "#71685a", "#ff6700", "#909465", "#956b43", "#fea022", "#f2f2f2", "#7f7f7f", "#f4fce4", "#dddcd0", "#efffc0", "#e3e1dc", "#ffe0cb", "#e8e9df", "#ece1d6", "#feecd2", "#d8d8d8", "#595959", "#e9f9c9", "#bbb9a1", "#dfff82", "#c8c3ba", "#ffc299", "#d2d4c0", "#dac3ad", "#fed9a6", "#bfbfbf", "#3f3f3f", "#dff7ae", "#ada598", "#cfff43", "#ada598", "#ffa365", "#bcbfa1", "#c8a585", "#fec67a", "#a5a5a5", "#262626", "#a9ea25", "#2e2d21", "#6f9400", "#544e43", "#bf4d00", "#6c6f4b", "#6f5032", "#d77b00", "#7f7f7f", "#0c0c0c", "#74a50f", "#1f1e16", "#4a6300", "#38342d", "#7f3300", "#484a32", "#4a3521", "#8f5200"],
    columns: 10
  },
  clarity: {
    colors: ["#ffffff", "#292934", "#f3f2dc", "#d2533c", "#93a299", "#ad8f67", "#726056", "#4c5a6a", "#808da0", "#79463d", "#f2f2f2", "#e7e7ec", "#e7e5b9", "#f6dcd8", "#e9ecea", "#eee8e0", "#e4dedb", "#d8dde3", "#e5e8ec", "#e9d6d3", "#d8d8d8", "#c4c4d1", "#d5d185", "#edbab1", "#d3d9d6", "#ded2c2", "#c9beb8", "#b2bcc8", "#ccd1d9", "#d3aea7", "#bfbfbf", "#8a8aa3", "#aca73b", "#e4978a", "#bec7c1", "#cdbba3", "#af9e94", "#8c9bac", "#b2bac6", "#bd857c", "#a5a5a5", "#56566e", "#56531d", "#a43925", "#6b7c72", "#866b48", "#554840", "#39434f", "#5c697b", "#5a342d", "#7f7f7f", "#3b3b4b", "#22210b", "#6d2619", "#47534c", "#594730", "#39302b", "#262d35", "#3d4652", "#3c231e"],
    columns: 10
  },
  slipstream: {
    colors: ["#ffffff", "#000000", "#b4dcfa", "#212745", "#4e67c8", "#5eccf3", "#a7ea52", "#5dceaf", "#ff8021", "#f14124", "#f2f2f2", "#7f7f7f", "#8bc9f7", "#c7cce4", "#dbe0f4", "#def4fc", "#edfadc", "#def5ef", "#ffe5d2", "#fcd9d3", "#d8d8d8", "#595959", "#4facf3", "#909aca", "#b8c2e9", "#beeafa", "#dbf6b9", "#beebdf", "#ffcca6", "#f9b3a7", "#bfbfbf", "#3f3f3f", "#0d78c9", "#5967af", "#94a3de", "#9ee0f7", "#caf297", "#9de1cf", "#ffb279", "#f68d7b", "#a5a5a5", "#262626", "#063c64", "#181d33", "#31479f", "#11b2eb", "#81d319", "#34ac8b", "#d85c00", "#c3260c", "#7f7f7f", "#0c0c0c", "#021828", "#101322", "#202f6a", "#0b769c", "#568c11", "#22725c", "#903d00", "#821908"],
    columns: 10
  },
  metro: {
    colors: ["#ffffff", "#000000", "#d6ecff", "#4e5b6f", "#7fd13b", "#ea157a", "#feb80a", "#00addc", "#738ac8", "#1ab39f", "#f2f2f2", "#7f7f7f", "#a7d6ff", "#d9dde4", "#e5f5d7", "#fad0e4", "#fef0cd", "#c5f2ff", "#e2e7f4", "#c9f7f1", "#d8d8d8", "#595959", "#60b5ff", "#b3bcca", "#cbecb0", "#f6a1c9", "#fee29c", "#8be6ff", "#c7d0e9", "#94efe3", "#bfbfbf", "#3f3f3f", "#007dea", "#8d9baf", "#b2e389", "#f272af", "#fed46b", "#51d9ff", "#aab8de", "#5fe7d5", "#a5a5a5", "#262626", "#003e75", "#3a4453", "#5ea226", "#af0f5b", "#c58c00", "#0081a5", "#425ea9", "#138677", "#7f7f7f", "#0c0c0c", "#00192e", "#272d37", "#3f6c19", "#750a3d", "#835d00", "#00566e", "#2c3f71", "#0c594f"],
    columns: 10
  },
  flow: {
    colors: ["#ffffff", "#000000", "#dbf5f9", "#04617b", "#0f6fc6", "#009dd9", "#0bd0d9", "#10cf9b", "#7cca62", "#a5c249", "#f2f2f2", "#7f7f7f", "#b2e9f2", "#b4ecfc", "#c7e2fa", "#c4eeff", "#c9fafc", "#c9faed", "#e4f4df", "#edf2da", "#d8d8d8", "#595959", "#76d9e8", "#6adafa", "#90c6f6", "#89deff", "#93f5f9", "#94f6db", "#cae9c0", "#dbe6b6", "#bfbfbf", "#3f3f3f", "#21b2c8", "#20c8f7", "#59a9f2", "#4fceff", "#5df0f6", "#5ff2ca", "#b0dfa0", "#c9da91", "#a5a5a5", "#262626", "#105964", "#02485c", "#0b5394", "#0075a2", "#089ca2", "#0b9b74", "#54a838", "#7e9532", "#7f7f7f", "#0c0c0c", "#062328", "#01303d", "#073763", "#004e6c", "#05686c", "#07674d", "#387025", "#546321"],
    columns: 10
  },
  hardcover: {
    colors: ["#ffffff", "#000000", "#ece9c6", "#895d1d", "#873624", "#d6862d", "#d0be40", "#877f6c", "#972109", "#aeb795", "#f2f2f2", "#7f7f7f", "#e1dca5", "#f2e0c6", "#f0d0c9", "#f6e6d5", "#f5f2d8", "#e7e5e1", "#fbc7bc", "#eef0e9", "#d8d8d8", "#595959", "#d0c974", "#e6c28d", "#e2a293", "#eeceaa", "#ece5b2", "#cfccc3", "#f78f7a", "#dee2d4", "#bfbfbf", "#3f3f3f", "#a29a36", "#daa454", "#d4735e", "#e6b681", "#e2d88c", "#b7b2a5", "#f35838", "#ced3bf", "#a5a5a5", "#262626", "#514d1b", "#664515", "#65281a", "#a2641f", "#a39428", "#655f50", "#711806", "#879464", "#7f7f7f", "#0c0c0c", "#201e0a", "#442e0e", "#431b11", "#6c4315", "#6d621a", "#433f35", "#4b1004", "#5a6243"],
    columns: 10
  },
  trek: {
    colors: ["#ffffff", "#000000", "#fbeec9", "#4e3b30", "#f0a22e", "#a5644e", "#b58b80", "#c3986d", "#a19574", "#c17529", "#f2f2f2", "#7f7f7f", "#f7e09e", "#e1d6cf", "#fcecd5", "#eddfda", "#f0e7e5", "#f3eae1", "#ece9e3", "#f5e3d1", "#d8d8d8", "#595959", "#f3cc5f", "#c4ad9f", "#f9d9ab", "#dcc0b6", "#e1d0cc", "#e7d5c4", "#d9d4c7", "#ebc7a3", "#bfbfbf", "#3f3f3f", "#d29f0f", "#a78470", "#f6c781", "#cba092", "#d2b9b2", "#dbc1a7", "#c6bfab", "#e1ac76", "#a5a5a5", "#262626", "#694f07", "#3a2c24", "#c87d0e", "#7b4b3a", "#926255", "#a17242", "#7b7153", "#90571e", "#7f7f7f", "#0c0c0c", "#2a1f03", "#271d18", "#855309", "#523226", "#614138", "#6b4c2c", "#524b37", "#603a14"],
    columns: 10
  },
  verve: {
    colors: ["#ffffff", "#000000", "#d2d2d2", "#666666", "#ff388c", "#e40059", "#9c007f", "#68007f", "#005bd3", "#00349e", "#f2f2f2", "#7f7f7f", "#bdbdbd", "#e0e0e0", "#ffd7e8", "#ffc6dc", "#ffb8f1", "#f1b2ff", "#c3dcff", "#b8cfff", "#d8d8d8", "#595959", "#9d9d9d", "#c1c1c1", "#ffafd1", "#ff8eba", "#ff71e4", "#e365ff", "#87baff", "#72a0ff", "#bfbfbf", "#3f3f3f", "#696969", "#a3a3a3", "#ff87ba", "#ff5597", "#ff2ad7", "#d519ff", "#4b98ff", "#2b71ff", "#a5a5a5", "#262626", "#343434", "#4c4c4c", "#e90062", "#ab0042", "#75005f", "#4e005f", "#00449e", "#002676", "#7f7f7f", "#0c0c0c", "#151515", "#333333", "#9b0041", "#72002c", "#4e003f", "#34003f", "#002d69", "#00194f"],
    columns: 10
  },
  monochrome: {
    colors: ["#000000", "#1a1a1a", "#333333", "#4d4d4d", "#666666", "#808080", "#999999", "#b3b3b3", "#cccccc", "#e6e6e6", "#f2f2f2", "#ffffff"],
    columns: 12
  }
};

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/ColorPalette.js
var allVue = vue_runtime_esm_bundler_exports;
var gh = allVue.h;
var isV3 = allVue.version && allVue.version[0] === "3";
var DEFAULT_TILE_SIZE = 24;
var DEFAULT_COLUMNS_COUNT = 10;
var DEFAULT_PRESET = "office";
var ColorPaletteVue2 = {
  name: "KendoColorPalette",
  model: {
    event: "changemodel"
  },
  // @ts-ignore
  emits: {
    "keydown": null,
    "focus": null,
    "blur": null,
    "changemodel": null,
    "update:modelValue": null,
    "update:modelRgbaValue": null,
    "change": null
  },
  props: {
    palette: {
      type: [String, Array],
      default: DEFAULT_PRESET
    },
    columns: Number,
    tileSize: {
      type: [Number, Object],
      default: DEFAULT_TILE_SIZE
    },
    modelValue: String,
    modelRgbaValue: String,
    defaultValue: String,
    value: String,
    disabled: Boolean,
    tabIndex: Number,
    id: String,
    ariaLabelledBy: String,
    ariaDescribedBy: String
  },
  created: function created() {
    validatePackage(packageMetadata);
    this.guid = guid();
  },
  mounted: function mounted() {
    this.wrapper = getRef(this, "wrapper");
  },
  updated: function updated() {
    this.wrapper = getRef(this, "wrapper");
  },
  computed: {
    focusedColorCooridanates: function focusedColorCooridanates() {
      return this.focusedColor ? this.paletteService.getCellCoordsFor(this.focusedColor) : void 0;
    },
    isUncontrolled: function isUncontrolled() {
      return this.$props.value === void 0;
    },
    selectedColor: function selectedColor() {
      return this.$props.value !== void 0 ? this.$props.value : this.modelValue !== void 0 ? this.modelValue : this.modelRgbaValue !== void 0 ? this.modelRgbaValue : this.currentValue !== void 0 ? this.currentValue : this.$props.defaultValue;
    }
  },
  data: function data() {
    return {
      focusedColor: this.$props.value,
      currentValue: void 0
    };
  },
  // @ts-ignore
  setup: !isV3 ? void 0 : function() {
    var v3 = !!isV3;
    return {
      v3
    };
  },
  // @ts-ignore
  render: function render(createElement) {
    var h = gh || createElement;
    var paletteInfo = this.getPaletteInfo();
    var svc = this.paletteService = new ColorPaletteService();
    svc.setColorMatrix(paletteInfo.colors, paletteInfo.columns);
    var selectedCellCoords = svc.getCellCoordsFor(this.selectedColor);
    var focusedCellCoords = svc.getCellCoordsFor(this.focusedColor);
    var className = classNames("k-colorpalette", {
      "k-disabled": this.$props.disabled
    });
    var renderColumns = function renderColumns2(columns, rowIndex, cSelectedCellCoords, cFocusedCellCoords) {
      var rowIsSelected = cSelectedCellCoords !== void 0 && cSelectedCellCoords.row === rowIndex;
      var selectedColumn = cSelectedCellCoords && cSelectedCellCoords.col;
      var rowIsFocused = cFocusedCellCoords !== void 0 && cFocusedCellCoords.row === rowIndex;
      var focusedColumn = cFocusedCellCoords && cFocusedCellCoords.col;
      var tileSize = typeof this.$props.tileSize !== "number" ? this.$props.tileSize : {
        width: this.$props.tileSize,
        height: this.$props.tileSize
      };
      var width = tileSize.width + "px";
      var height = tileSize.height + "px";
      return columns.map(function(color, i) {
        var _this = this;
        var isSelected = rowIsSelected && selectedColumn === i;
        var tdClassName = classNames("k-colorpalette-tile", {
          "k-selected": isSelected,
          "k-focus": rowIsFocused && focusedColumn === i
        });
        return h("td", {
          "class": tdClassName,
          "aria-label": color,
          attrs: this.v3 ? void 0 : {
            "aria-label": color,
            "aria-selected": isSelected ? true : this.$props.disabled ? void 0 : false,
            id: this.createCellId({
              row: rowIndex,
              col: i
            }),
            role: "gridcell"
          },
          "aria-selected": isSelected ? true : this.$props.disabled ? void 0 : false,
          style: {
            backgroundColor: color,
            width,
            height,
            minWidth: width
          },
          onClick: function onClick2(event) {
            return _this.onColorClick(color, event);
          },
          on: this.v3 ? void 0 : {
            "click": function onClick2(event) {
              return _this.onColorClick(color, event);
            }
          },
          id: this.createCellId({
            row: rowIndex,
            col: i
          }),
          key: i,
          role: "gridcell"
        });
      }, this);
    };
    var renderRows = function renderRows2(rows, rSelectedCellCoords, rFocusedCellCoords) {
      return rows.map(function(row, i) {
        return h("tr", {
          role: "row",
          attrs: this.v3 ? void 0 : {
            role: "row"
          },
          key: i
        }, [renderColumns.call(this, row, i, rSelectedCellCoords, rFocusedCellCoords)]);
      }, this);
    };
    if (paletteInfo.colors.length) {
      return h("div", {
        id: this.$props.id,
        attrs: this.v3 ? void 0 : {
          id: this.$props.id,
          "aria-disabled": this.$props.disabled ? "true" : void 0,
          "aria-activedescendant": focusedCellCoords && this.createCellId(focusedCellCoords),
          "aria-labelledby": this.$props.ariaLabelledBy,
          "aria-describedby": this.$props.ariaDescribedBy,
          role: "grid",
          tabindex: getTabIndex(this.$props.tabIndex, this.$props.disabled)
        },
        "class": className,
        onFocusin: this.onFocus,
        on: this.v3 ? void 0 : {
          "focusin": this.onFocus,
          "focusout": this.onBlur,
          "keydown": this.onKeyDown
        },
        onFocusout: this.onBlur,
        onKeydown: this.onKeyDown,
        "aria-disabled": this.$props.disabled ? "true" : void 0,
        "aria-activedescendant": focusedCellCoords && this.createCellId(focusedCellCoords),
        "aria-labelledby": this.$props.ariaLabelledBy,
        "aria-describedby": this.$props.ariaDescribedBy,
        role: "grid",
        tabindex: getTabIndex(this.$props.tabIndex, this.$props.disabled),
        ref: setRef(this, "wrapper")
      }, [h("table", {
        "class": "k-colorpalette-table k-palette",
        role: "presentation",
        attrs: this.v3 ? void 0 : {
          role: "presentation"
        }
      }, [h("tbody", [renderRows.call(this, svc.colorRows, selectedCellCoords, focusedCellCoords)])])]);
    } else {
      return "";
    }
  },
  methods: {
    focus: function focus() {
      if (this.wrapper) {
        this.wrapper.focus();
      }
    },
    onKeyDown: function onKeyDown(event) {
      switch (event.keyCode) {
        case Keys.down:
          this.handleCellNavigation(event, 0, 1);
          break;
        case Keys.up:
          this.handleCellNavigation(event, 0, -1);
          break;
        case Keys.right:
          this.handleCellNavigation(event, 1, 0);
          break;
        case Keys.left:
          this.handleCellNavigation(event, -1, 0);
          break;
        case Keys.enter:
          this.handleEnter(event);
          break;
        default:
          this.$emit("keydown", event);
          return;
      }
      this.$emit("keydown", event);
    },
    onColorClick: function onColorClick(color, event) {
      if (this.isUncontrolled) {
        this.currentValue = color;
        this.focusedColor = color;
      } else {
        this.focusedColor = color;
      }
      this.dispatchChangeEvent(color, event);
    },
    onFocus: function onFocus(event) {
      this.focusedColor = this.selectedColor || this.paletteService.colorRows[0][0];
      this.$emit("focus", {
        event,
        target: this
      });
    },
    onBlur: function onBlur(event) {
      this.focusedColor = void 0;
      this.$emit("blur", {
        event,
        target: this
      });
    },
    handleCellNavigation: function handleCellNavigation(event, horizontalStep, verticalStep) {
      event.preventDefault();
      if (this.focusedColorCooridanates) {
        var newCoords = this.paletteService.getNextCell(this.focusedColorCooridanates, horizontalStep, verticalStep);
        this.focusedColor = this.paletteService.getColorAt(newCoords);
      } else {
        this.focusedColor = this.paletteService.colorRows[0][0];
      }
    },
    handleEnter: function handleEnter(event) {
      if (this.isUncontrolled) {
        this.currentValue = this.focusedColor;
      }
      this.dispatchChangeEvent(this.focusedColor, event);
    },
    dispatchChangeEvent: function dispatchChangeEvent(value2, event) {
      var rgbaValue = parseColor2(value2, "rgba");
      this.$emit("changemodel", value2);
      this.$emit("update:modelValue", value2);
      this.$emit("update:modelRgbaValue", rgbaValue);
      this.$emit("change", {
        event,
        component: this,
        value: value2,
        rgbaValue
      });
    },
    getPaletteInfo: function getPaletteInfo() {
      if (typeof this.$props.palette === "string") {
        var preset = PALETTEPRESETS[this.$props.palette];
        if (isPresent(preset)) {
          return {
            colors: preset.colors,
            columns: this.$props.columns || preset.columns || DEFAULT_COLUMNS_COUNT
          };
        } else {
          return {
            colors: [],
            columns: 0
          };
        }
      } else {
        return {
          colors: this.$props.palette || [],
          columns: this.$props.columns || DEFAULT_COLUMNS_COUNT
        };
      }
    },
    createCellId: function createCellId(cellCoords) {
      return "".concat(this.guid, "_").concat(cellCoords.row, "_").concat(cellCoords.col);
    }
  }
};
var ColorPalette = ColorPaletteVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/utils/color-cache.js
var cache = {};
var DEFAULT_GRADIENT_SETTINGS = {
  opacity: true
};
var DEFAULT_PALETTE_SETTINGS = {
  palette: DEFAULT_PRESET,
  tileSize: DEFAULT_TILE_SIZE
};
function removeCachedColor(componentGuid) {
  delete cache[componentGuid];
}

// node_modules/@progress/kendo-vue-labels/dist/es/messages/main.js
var _a;
var labelsOptional = "labels.optional";
var messages = (_a = {}, _a[labelsOptional] = "(Optional)", _a);

// node_modules/@progress/kendo-vue-labels/dist/es/package-metadata.js
var packageMetadata2 = {
  name: "@progress/kendo-vue-labels",
  productName: "Kendo UI for Vue",
  productCodes: ["KENDOUIVUE", "KENDOUICOMPLETE"],
  publishDate: 1714476880,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-vue-ui/my-license/?utm_medium=product&utm_source=kendovue&utm_campaign=kendo-ui-vue-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-vue-labels/dist/es/Label.js
var allVue2 = vue_runtime_esm_bundler_exports;
var gh2 = allVue2.h;
var isV32 = allVue2.version && allVue2.version[0] === "3";
var inject = allVue2.inject;
var LabelVue2 = {
  name: "KendoLabel",
  props: {
    id: String,
    editorId: String,
    editorRef: String,
    editorValid: {
      type: Boolean,
      default: void 0
    },
    editorDisabled: Boolean,
    optional: Boolean
  },
  inject: {
    kendoLocalizationService: {
      default: null
    }
  },
  created: function created2() {
    validatePackage(packageMetadata2);
  },
  computed: {
    labelClassName: function labelClassName() {
      return {
        "k-label": true,
        "k-label-empty": !this.defaultSlots,
        "k-text-error": this.$props.editorValid === false,
        "k-text-disabled": this.$props.editorDisabled === true
      };
    }
  },
  methods: {
    onLabelClick: function onLabelClick(e) {
      if (this.$props.editorRef && this.$props.editorRef.current && !this.$props.editorDisabled) {
        if (this.$props.editorRef.current.focus) {
          e.preventDefault();
          this.$props.editorRef.current.focus();
        }
        var editorActionElement = this.$props.editorRef.current.actionElement;
        if (editorActionElement) {
          e.preventDefault();
          editorActionElement.click();
        }
      }
    }
  },
  // @ts-ignore
  setup: !isV32 ? void 0 : function() {
    var v3 = !!isV32;
    var kendoLocalizationService = inject("kendoLocalizationService", {});
    return {
      v3,
      kendoLocalizationService
    };
  },
  render: function render2(createElement) {
    var h = gh2 || createElement;
    this.defaultSlots = getDefaultSlots(this);
    var ls = provideLocalizationService(this);
    var _a5 = this.$props, id = _a5.id, editorId = _a5.editorId, optional = _a5.optional;
    var localizedOptional = optional ? ls.toLanguageString(labelsOptional, messages[labelsOptional]) : "";
    var optionalElement = localizedOptional && h("span", {
      "class": "k-label-optional"
    }, [localizedOptional]);
    return h("label", {
      id,
      attrs: this.v3 ? void 0 : {
        id,
        "for": editorId
      },
      "for": editorId,
      onClick: this.onLabelClick,
      on: this.v3 ? void 0 : {
        "click": this.onLabelClick
      },
      "class": this.labelClassName
    }, [this.defaultSlots, optionalElement]);
  }
};
var Label = LabelVue2;

// node_modules/@progress/kendo-vue-labels/dist/es/Error.js
var allVue3 = vue_runtime_esm_bundler_exports;
var gh3 = allVue3.h;
var isV33 = allVue3.version && allVue3.version[0] === "3";

// node_modules/@progress/kendo-vue-labels/dist/es/Hint.js
var allVue4 = vue_runtime_esm_bundler_exports;
var gh4 = allVue4.h;
var isV34 = allVue4.version && allVue4.version[0] === "3";

// node_modules/@progress/kendo-vue-labels/dist/es/FloatingLabel.js
var allVue5 = vue_runtime_esm_bundler_exports;
var gh5 = allVue5.h;
var isV35 = allVue5.version && allVue5.version[0] === "3";
var inject2 = allVue5.inject;
var FloatingLabelVue2 = {
  name: "KendoFloatingLabel",
  props: {
    label: String,
    labelClass: String,
    editorId: String,
    editorValue: [String, Boolean, Number],
    editorPlaceholder: String,
    editorValid: {
      type: Boolean,
      default: void 0
    },
    editorDisabled: Boolean,
    id: String,
    optional: Boolean,
    focused: {
      type: Boolean,
      default: void 0
    }
  },
  data: function data2() {
    return {
      currentFocused: false
    };
  },
  inject: {
    kendoLocalizationService: {
      default: null
    }
  },
  created: function created3() {
    validatePackage(packageMetadata2);
  },
  computed: {
    computedFocused: function computedFocused() {
      return this.$props.focused !== void 0 ? this.$props.focused : this.currentFocused;
    },
    spanClassNames: function spanClassNames() {
      return {
        "k-floating-label-container": true,
        "k-focus": this.computedFocused,
        "k-empty": !this.$props.editorPlaceholder && !this.$props.editorValue && this.$props.editorValue !== 0,
        "k-text-disabled": this.$props.editorDisabled,
        "k-rtl": this.$props.dir === "rtl"
      };
    },
    labelClassNames: function labelClassNames() {
      var _a5;
      return _a5 = {
        "k-label": true,
        "k-text-error": this.$props.editorValid === false,
        "k-text-disabled": this.$props.editorDisabled
      }, _a5[this.$props.labelClass] = this.$props.labelClass, _a5;
    }
  },
  methods: {
    handleFocus: function handleFocus() {
      this.currentFocused = true;
    },
    handleBlur: function handleBlur() {
      this.currentFocused = false;
    }
  },
  // @ts-ignore
  setup: !isV35 ? void 0 : function() {
    var v3 = !!isV35;
    var kendoLocalizationService = inject2("kendoLocalizationService", {});
    return {
      v3,
      kendoLocalizationService
    };
  },
  render: function render3(createElement) {
    var h = gh5 || createElement;
    var defaultSlots = getDefaultSlots(this);
    var _a5 = this.$props, label = _a5.label, editorId = _a5.editorId, id = _a5.id, optional = _a5.optional;
    var ls = provideLocalizationService(this);
    var localizedOptional = optional ? ls.toLanguageString(labelsOptional, messages[labelsOptional]) : "";
    var optionalElement = localizedOptional && h("span", {
      "class": "k-label-optional"
    }, [localizedOptional]);
    return h("span", {
      "class": this.spanClassNames,
      onFocusin: this.handleFocus,
      on: this.v3 ? void 0 : {
        "focusin": this.handleFocus,
        "focusout": this.handleBlur
      },
      onFocusout: this.handleBlur,
      dir: this.$props.dir,
      attrs: this.v3 ? void 0 : {
        dir: this.$props.dir
      }
    }, [defaultSlots, label ? editorId ? h("label", {
      id,
      attrs: this.v3 ? void 0 : {
        id,
        "for": editorId
      },
      "for": editorId,
      "class": this.labelClassNames
    }, [label, optionalElement]) : h("span", {
      id,
      attrs: this.v3 ? void 0 : {
        id
      },
      "class": this.labelClassNames
    }, [label, optionalElement]) : null]);
  }
};
var FloatingLabel = FloatingLabelVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/textbox/TextBox.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var allVue6 = vue_runtime_esm_bundler_exports;
var gh6 = allVue6.h;
var isV36 = allVue6.version && allVue6.version[0] === "3";
var ref = allVue6.ref;
var TextBoxVue2 = {
  model: {
    event: "changemodel"
  },
  // @ts-ignore
  emits: {
    "input": null,
    "change": null,
    "changemodel": null,
    "update:modelValue": null,
    "focus": null,
    "blur": null,
    "keyup": null,
    "keydown": null,
    "keypress": null
  },
  props: {
    modelValue: {
      type: [String, Number],
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    defaultValue: {
      type: [String, Number],
      default: ""
    },
    value: {
      type: [String, Number]
    },
    label: {
      type: String
    },
    placeholder: {
      type: String
    },
    required: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator(value2) {
        return [null, "small", "medium", "large"].includes(value2);
      }
    },
    rounded: {
      type: String,
      default: "medium",
      validator: function validator2(value2) {
        return [null, "small", "medium", "large", "full"].includes(value2);
      }
    },
    fillMode: {
      type: String,
      default: "solid",
      validator: function validator3(value2) {
        return [null, "solid", "flat", "outline"].includes(value2);
      }
    },
    dir: {
      type: String
    },
    id: String,
    valid: {
      type: Boolean,
      default: void 0
    },
    validate: {
      type: Boolean
    },
    validationMessage: {
      type: String
    },
    validityStyles: {
      type: Boolean,
      default: true
    },
    iconName: String,
    inputPrefix: templateDefinition,
    inputSuffix: templateDefinition,
    showValidationIcon: Boolean,
    showLoadingIcon: Boolean,
    showClearButton: Boolean,
    inputClass: String,
    wrapperClass: String,
    tabIndex: Number,
    ariaLabel: String,
    ariaLabelledBy: String,
    ariaDescribedBy: String
  },
  data: function data3() {
    return {
      hasMounted: false,
      autofill: false,
      currentValue: "",
      valueDuringOnChange: "",
      focused: false
    };
  },
  created: function created4() {
    validatePackage(packageMetadata);
    this._input = void 0;
    this._inputId = guid();
    this.$data.valueDuringOnChange = void 0;
    this.$data.currentValue = this.$props.defaultValue;
  },
  mounted: function mounted2() {
    this._input = this.v3 ? this.inputRef : this.$refs.input;
    this.wrapper = this.v3 ? this.wrapperRef : this.$refs.wrapper;
    this.$data.hasMounted = true;
    this.setValidity();
  },
  updated: function updated2() {
    this.setValidity();
    this.updateValidClass();
  },
  // @ts-ignore
  setup: !isV36 ? void 0 : function() {
    var v3 = !!isV36;
    var inputRef = ref(null);
    return {
      v3,
      inputRef
    };
  },
  render: function render4(createElement) {
    var _this = this;
    var h = gh6 || createElement;
    var isValid3 = !this.$props.validityStyles || this.validity().valid;
    var _a5 = this.$props, label = _a5.label, id = _a5.id, required = _a5.required, iconName = _a5.iconName, showValidationIcon = _a5.showValidationIcon, showLoadingIcon = _a5.showLoadingIcon, showClearButton = _a5.showClearButton, tabIndex = _a5.tabIndex, ariaLabel = _a5.ariaLabel, ariaLabelledBy = _a5.ariaLabelledBy, ariaDescribedBy = _a5.ariaDescribedBy;
    var inputId = id || this._inputId;
    var textbox = h("input", __assign(__assign({
      domProps: this.v3 ? null : __assign(__assign({}, this.$attrs), {
        placeholder: this.$props.placeholder,
        id: inputId,
        required,
        disabled: this.$props.disabled,
        value: this.computedValue
      }),
      attrs: this.v3 ? void 0 : __assign(__assign({}, this.$attrs), {
        tabindex: tabIndex
      })
    }, this.$attrs), {
      placeholder: this.$props.placeholder,
      id: inputId,
      tabindex: tabIndex,
      required,
      ariaLabel,
      ariaLabelledby: ariaLabelledBy,
      ariaDescribedby: ariaDescribedBy,
      ariaDisabled: this.$props.disabled,
      disabled: this.$props.disabled,
      value: this.computedValue,
      class: this.inputInnerClass,
      ref: this.v3 ? function(el) {
        _this.inputRef = el;
      } : "input",
      on: this.v3 ? null : {
        change: this.handleChange,
        focus: this.emitFocus,
        blur: this.emitBlur,
        keydown: this.handleKeydown,
        keyup: this.handleKeyup,
        keypress: this.handleKeypress,
        input: this.handleInput,
        animationstart: this.handleAutoFill,
        animationend: this.handleAutoFillEnd
      },
      onKeydown: this.handleKeydown,
      onKeyup: this.handleKeyup,
      onKeypress: this.handleKeypress,
      onChange: this.handleChange,
      onFocus: this.emitFocus,
      onBlur: this.emitBlur,
      onInput: this.handleInput,
      onAnimationstart: this.handleAutoFill,
      onAnimationend: this.handleAutoFillEnd
    }));
    var inputPrefixTemplate = templateRendering.call(this, this.$props.inputPrefix, getListeners.call(this));
    var inputSuffixTemplate = templateRendering.call(this, this.$props.inputSuffix, getListeners.call(this));
    var inputPrefix = getTemplate.call(this, {
      h,
      template: inputPrefixTemplate,
      additionalProps: {
        value: this.computedValue,
        valid: isValid3
      }
    });
    var inputSuffix = getTemplate.call(this, {
      h,
      template: inputSuffixTemplate,
      additionalProps: {
        value: this.computedValue,
        valid: isValid3
      }
    });
    var inputWrapper = h("span", {
      "class": this.inputWrapperClass(),
      ref: this.v3 ? function(el) {
        _this.wrapperRef = el;
      } : "wrapper"
    }, [iconName && h(Icon, {
      name: iconName,
      attrs: this.v3 ? void 0 : {
        name: iconName
      },
      "class": "k-input-icon"
    }), this.$props.inputPrefix && h("span", {
      "class": "k-input-prefix"
    }, [inputPrefix]), textbox, this.$props.inputSuffix && h("span", {
      "class": "k-input-suffix"
    }, [inputSuffix]), showValidationIcon && isValid3 && h(Icon, {
      name: "check",
      attrs: this.v3 ? void 0 : {
        name: "check",
        icon: checkIcon
      },
      icon: checkIcon,
      "class": "k-input-validation-icon"
    }), showValidationIcon && !isValid3 && h(Icon, {
      name: "exclamation-circle",
      attrs: this.v3 ? void 0 : {
        name: "exclamation-circle",
        icon: exclamationCircleIcon
      },
      icon: exclamationCircleIcon,
      "class": "k-input-validation-icon"
    }), showLoadingIcon && h(Icon, {
      name: "loading",
      attrs: this.v3 ? void 0 : {
        name: "loading"
      },
      "class": "k-input-loading-icon"
    }), showClearButton && this.computedValue && h("span", {
      onClick: this.clearClick,
      on: this.v3 ? void 0 : {
        "click": this.clearClick
      },
      "class": "k-clear-value"
    }, [h(Icon, {
      name: "x",
      attrs: this.v3 ? void 0 : {
        name: "x",
        icon: xIcon
      },
      icon: xIcon
    })])]);
    return label ? (
      // @ts-ignore function children
      h(FloatingLabel, {
        label,
        attrs: this.v3 ? void 0 : {
          label,
          editorId: inputId,
          editorValue: this.computedValue,
          editorValid: isValid3,
          editorDisabled: this.$props.disabled,
          editorPlaceholder: this.$data.focused ? this.$props.placeholder : "",
          dir: this.$props.dir
        },
        editorId: inputId,
        editorValue: this.computedValue,
        editorValid: isValid3,
        editorDisabled: this.$props.disabled,
        editorPlaceholder: this.$data.focused ? this.$props.placeholder : "",
        dir: this.$props.dir
      }, this.v3 ? function() {
        return [inputWrapper];
      } : [inputWrapper])
    ) : inputWrapper;
  },
  methods: {
    updateValidClass: function updateValidClass() {
      this.wrapper.classList.toggle("k-invalid", !this.validity().valid);
    },
    emitFocus: function emitFocus(e) {
      this.$emit("focus", e);
      this.$data.focused = true;
    },
    emitBlur: function emitBlur(e) {
      this.$emit("blur", e);
      this.$data.focused = false;
    },
    handleKeydown: function handleKeydown(e) {
      this.$emit("keydown", e);
    },
    handleKeyup: function handleKeyup(e) {
      this.$emit("keyup", e);
    },
    handleKeypress: function handleKeypress(e) {
      this.$emit("keypress", e);
    },
    clearClick: function clearClick(event) {
      this.emitUpdate(event, "change", "");
    },
    focus: function focus2() {
      if (this._input) {
        this._input.focus();
      }
    },
    validity: function validity() {
      var result = {
        badTextBox: this._input ? this._input.validity.badTextBox : false,
        patternMismatch: this._input ? this._input.validity.patternMismatch : false,
        rangeOverflow: this._input ? this._input.validity.rangeOverflow : false,
        rangeUnderflow: this._input ? this._input.validity.rangeUnderflow : false,
        stepMismatch: this._input ? this._input.validity.stepMismatch : false,
        tooLong: this._input ? this._input.validity.tooLong : false,
        tooShort: this._input ? this._input.validity.tooShort : false,
        typeMismatch: this._input ? this._input.validity.typeMismatch : false,
        valueMissing: this._input ? this._input.validity.valueMissing : false
      };
      return __assign(__assign({}, result), {
        customError: this.$props.validationMessage !== void 0,
        valid: this.$props.valid !== void 0 ? this.$props.valid : this._input ? !this.isInvalid(result) : true
      });
    },
    isInvalid: function isInvalid(state) {
      var result = false;
      for (var prop in state) {
        if (state.hasOwnProperty(prop)) {
          result = result || state[prop];
        }
      }
      return result;
    },
    setValidity: function setValidity() {
      if (this._input && this._input.setCustomValidity) {
        this._input.setCustomValidity(this.validity().valid ? "" : this.$props.validationMessage || "");
      }
    },
    handleInput: function handleInput(event) {
      this.emitUpdate(event, "input", event.target.value);
    },
    handleChange: function handleChange(event) {
      this.emitUpdate(event, "change", event.target.value);
    },
    emitUpdate: function emitUpdate(event, eventName, value2) {
      var that = this;
      if (this.disabled) {
        return;
      }
      this.$data.currentValue = value2;
      this.$data.valueDuringOnChange = value2;
      this.$nextTick(function() {
        that.$emit("changemodel", value2);
        that.$emit("update:modelValue", value2);
        that.$emit(eventName, {
          event,
          value: value2,
          component: that,
          target: event.target,
          validity: that.validity()
        });
        that.$data.valueDuringOnChange = void 0;
      });
    },
    handleAutoFill: function handleAutoFill(e) {
      if (e.animationName === "autoFillStart") {
        var parent_1 = e.target.parentNode;
        if (parent_1 && parent_1.classList.contains("k-empty")) {
          this.$data.autofill = true;
          parent_1.classList.remove("k-empty");
        }
      }
    },
    handleAutoFillEnd: function handleAutoFillEnd(e) {
      if (e.animationName === "autoFillEnd") {
        var parent_2 = e.target.parentNode;
        if (parent_2) {
          this.$data.autofill = false;
        }
      }
    },
    name: function name() {
      return this.$props.name;
    },
    inputWrapperClass: function inputWrapperClass() {
      var _a5;
      var _b = this.$props, size2 = _b.size, fillMode = _b.fillMode, rounded = _b.rounded;
      var isValid3 = !this.$data.hasMounted || !this.$props.validityStyles || this.validity().valid;
      return _a5 = {
        "k-textbox": true,
        "k-input": true
      }, _a5["k-input-".concat(kendoThemeMaps.sizeMap[size2] || size2)] = size2, _a5["k-input-".concat(fillMode)] = fillMode, _a5["k-rounded-".concat(kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded, _a5["k-invalid"] = !isValid3, _a5["k-required"] = this.required, _a5["k-disabled"] = this.$props.disabled, _a5[this.wrapperClass] = this.wrapperClass, _a5;
    }
  },
  computed: {
    spanClassNames: {
      get: function get() {
        var isValid3 = !this.$data.hasMounted || !this.$props.validityStyles || this.validity().valid;
        return {
          "k-floating-label-container": true,
          "k-focus": this.$data.focused,
          "k-empty": !((this.computedValue === 0 ? true : this.computedValue) || this.$props.placeholder || this.$data.autofill),
          "k-autofill": this.$data.autofill,
          "k-invalid": !isValid3 && isValid3 !== void 0,
          "k-rtl": this.$props.dir === "rtl"
        };
      }
    },
    inputInnerClass: function inputInnerClass() {
      var _a5;
      return _a5 = {
        "k-input-inner": true
      }, _a5[this.inputClass] = this.inputClass, _a5;
    },
    computedValue: {
      get: function get2() {
        return this.$data.valueDuringOnChange !== void 0 ? this.$data.valueDuringOnChange : this.$props.value !== void 0 ? this.$props.value : this.$props.modelValue !== void 0 ? this.$props.modelValue : this.$data.currentValue;
      }
    }
  }
};
var TextBox = TextBoxVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/HexInput.js
var allVue7 = vue_runtime_esm_bundler_exports;
var gh7 = allVue7.h;
var isV37 = allVue7.version && allVue7.version[0] === "3";
var HexInputVue2 = {
  name: "KendoHexInput",
  // @ts-ignore
  emits: {
    "hexchange": null,
    "blur": null,
    "focus": null
  },
  props: {
    tabIndex: Number,
    hex: String,
    disabled: Boolean
  },
  computed: {
    isHexValid: function isHexValid() {
      return !!parseColor2(this.currentHex, "rgba");
    }
  },
  data: function data4() {
    return {
      currentHex: this.$props.hex,
      originalHex: this.$props.hex
    };
  },
  mounted: function mounted3() {
    this._input = this.$refs.input._input;
  },
  // @ts-ignore
  setup: !isV37 ? void 0 : function() {
    var v3 = !!isV37;
    return {
      v3
    };
  },
  watch: {
    hex: function hex2(newValue) {
      this.currentHex = newValue;
    }
  },
  // @ts-ignore
  render: function render5(createElement) {
    var h = gh7 || createElement;
    return h(TextBox, {
      value: this.currentHex,
      attrs: this.v3 ? void 0 : {
        value: this.currentHex,
        valid: this.isHexValid,
        disabled: this.$props.disabled,
        tabIndex: this.tabIndex
      },
      onInput: this.onChange,
      on: this.v3 ? void 0 : {
        "input": this.onChange,
        "change": this.onChange,
        "focus": this.onFocus,
        "blur": this.onBlur
      },
      onChange: this.onChange,
      onFocus: this.onFocus,
      onBlur: this.onBlur,
      valid: this.isHexValid,
      disabled: this.$props.disabled,
      tabIndex: this.tabIndex,
      ref: "input"
    });
  },
  methods: {
    onChange: function onChange(event) {
      var hex4 = event.target.value;
      var value2 = parseColor2(hex4, "rgba");
      this.currentHex = hex4;
      if (isPresent(value2)) {
        this.$emit("hexchange", {
          hex: hex4,
          value: value2,
          event
        });
      }
    },
    onBlur: function onBlur2(event) {
      if (!isPresent(parseColor2(this.hex, "rgba"))) {
        this.currentHex = this.originalHex;
      }
      this.$emit("blur", event);
    },
    onFocus: function onFocus2(event) {
      this.$emit("focus", event);
    }
  }
};
var HexInput = HexInputVue2;

// node_modules/@progress/kendo-vue-buttons/dist/es/package-metadata.js
var packageMetadata3 = {
  name: "@progress/kendo-vue-buttons",
  productName: "Kendo UI for Vue",
  productCodes: ["KENDOUIVUE", "KENDOUICOMPLETE"],
  publishDate: 1714476841,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-vue-ui/my-license/?utm_medium=product&utm_source=kendovue&utm_campaign=kendo-ui-vue-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-vue-buttons/dist/es/util.js
var styles = {
  button: "k-button",
  "flat": "k-flat",
  "outline": "k-outline",
  "clear": "k-button-clear",
  "primary": "k-primary",
  "state-selected": "k-selected",
  "button-icon": "k-button-icon",
  "button-icontext": "k-button-icontext",
  "state-disabled": "k-disabled",
  "group-start": "k-group-start",
  "group-end": "k-group-end",
  "button-group": "k-button-group",
  "button-group-stretched": "k-button-group-stretched",
  "ltr": "k-ltr",
  "rtl": "k-rtl"
};
var notInternalButton = ":not(.k-dropdownlist button):not(.k-colorpicker button):not(.k-split-button .k-split-button-arrow)";
var toolbarButtons = [
  "button" + notInternalButton,
  ".k-button-group > button",
  ".k-dropdownlist",
  ".k-colorpicker"
];
var util_default = {
  styles
};

// node_modules/@progress/kendo-vue-buttons/dist/es/Button.js
var allVue8 = vue_runtime_esm_bundler_exports;
var gh8 = allVue8.h;
var isV38 = allVue8.version && allVue8.version[0] === "3";
var styles2 = util_default.styles;
var ButtonVue2 = {
  name: "KendoButton",
  // @ts-ignore
  emits: {
    click: null,
    mousedown: null,
    mouseup: null,
    pointerdown: null,
    pointerup: null,
    focus: null,
    blur: null,
    keypress: null,
    keydown: null
  },
  props: {
    ariaLabel: String,
    title: String,
    dir: String,
    selected: {
      type: Boolean,
      default: void 0
    },
    togglable: {
      type: Boolean,
      default: false
    },
    icon: {
      type: String,
      default: function _default() {
        return void 0;
      }
    },
    svgIcon: Object,
    iconClass: {
      type: String,
      default: function _default2() {
        return void 0;
      }
    },
    imageUrl: {
      type: String,
      default: function _default3() {
        return void 0;
      }
    },
    imageAlt: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    size: {
      type: String,
      default: "medium"
    },
    shape: {
      type: String
    },
    rounded: {
      type: String,
      default: "medium"
    },
    fillMode: {
      type: String,
      default: "solid"
    },
    // eslint-disable-next-line max-len
    themeColor: {
      type: String,
      default: "base"
    }
  },
  created: function created5() {
    validatePackage(packageMetadata3);
    this.currentActive = this.$props.togglable === true && this.$props.selected === true;
    this._activeTemp = void 0;
  },
  data: function data5() {
    return {
      currentActive: null
    };
  },
  computed: {
    computedSelected: function computedSelected() {
      return this._activeTemp !== void 0 ? this._activeTemp : this.$props.selected !== void 0 ? this.$props.selected : this.currentActive;
    },
    buttonClasses: function buttonClasses() {
      var _a5;
      var _b = this.$props, disabled = _b.disabled, icon = _b.icon, iconClass = _b.iconClass, imageUrl = _b.imageUrl, dir = _b.dir, svgIcon = _b.svgIcon, size2 = _b.size, shape = _b.shape, rounded = _b.rounded, fillMode = _b.fillMode, themeColor = _b.themeColor;
      var hasIcon = svgIcon !== void 0 || icon !== void 0 || iconClass !== void 0 || imageUrl !== void 0;
      var defaultSlot = getDefaultSlots(this);
      var hasChildren = defaultSlot;
      return _a5 = {}, _a5[styles2.button] = true, _a5["k-button-".concat(kendoThemeMaps.sizeMap[size2] || size2)] = size2, _a5["k-button-".concat(shape)] = shape && shape !== "rectangle", _a5["k-rounded-".concat(kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded, _a5["k-icon-button"] = !hasChildren && hasIcon, _a5["k-disabled"] = disabled, _a5["k-selected"] = this.computedSelected, _a5["k-rtl"] = dir === "rtl", _a5["k-button-".concat(fillMode)] = fillMode, _a5["k-button-".concat(fillMode, "-").concat(themeColor)] = fillMode && themeColor, _a5;
    }
  },
  updated: function updated3() {
    if (this.$props.togglable && this.$props.selected !== void 0 && this.$props.selected !== this.currentActive) {
      this.currentActive = this.$props.selected;
    }
  },
  methods: {
    focus: function focus3(e) {
      this.$el.focus(e);
    },
    toggleIfApplicable: function toggleIfApplicable() {
      if (!this.disabled && this.$props.togglable && this.$props.selected === void 0) {
        var active = !this.currentActive;
        this._activeTemp = active;
        this.currentActive = active;
        this._activeTemp = void 0;
      }
    },
    handleClick: function handleClick(event) {
      this.toggleIfApplicable();
      if (!this.disabled) {
        this.$emit("click", event);
      }
    },
    handleMouseDown: function handleMouseDown(event) {
      if (!this.disabled) {
        this.$emit("mousedown", event);
      }
    },
    handlePointerDown: function handlePointerDown(event) {
      if (!this.disabled) {
        this.$emit("pointerdown", event);
      }
    },
    handleMouseUp: function handleMouseUp(event) {
      if (!this.disabled) {
        this.$emit("mouseup", event);
      }
    },
    handlePointerUp: function handlePointerUp(event) {
      if (!this.disabled) {
        this.$emit("pointerup", event);
      }
    },
    handleFocus: function handleFocus2(event) {
      if (!this.disabled) {
        this.$emit("focus", event);
      }
    },
    handleBlur: function handleBlur2(event) {
      if (!this.disabled) {
        this.$emit("blur", event);
      }
    },
    handleKeypress: function handleKeypress2(event) {
      if (!this.disabled) {
        this.$emit("keypress", event);
      }
    },
    handleKeydown: function handleKeydown2(event) {
      if (!this.disabled) {
        this.$emit("keydown", event);
      }
    },
    handleContextmenu: function handleContextmenu(event) {
      if (!this.disabled) {
        this.$emit("contextmenu", event);
      }
    }
  },
  // @ts-ignore
  setup: !isV38 ? void 0 : function() {
    var v3 = !!isV38;
    return {
      v3
    };
  },
  // @ts-ignore
  render: function render6(createElement) {
    var h = gh8 || createElement;
    var _a5 = this.$props, togglable = _a5.togglable, icon = _a5.icon, svgIcon = _a5.svgIcon, iconClass = _a5.iconClass, imageUrl = _a5.imageUrl, imageAlt = _a5.imageAlt;
    var defaultSlot = getDefaultSlots(this);
    var iconElement = function iconElement2() {
      if (imageUrl) {
        return h("img", {
          role: "presentation",
          attrs: this.v3 ? void 0 : {
            role: "presentation",
            alt: imageAlt,
            src: imageUrl
          },
          "class": "k-image",
          alt: imageAlt,
          src: imageUrl
        });
      } else if (icon || svgIcon) {
        var iconClasses = classNames("k-button-icon", iconClass);
        return h(Icon, {
          name: icon,
          attrs: this.v3 ? void 0 : {
            name: icon,
            icon: svgIcon
          },
          icon: svgIcon,
          "class": iconClasses
        });
      } else if (iconClass) {
        return h("span", {
          role: "presentation",
          attrs: this.v3 ? void 0 : {
            role: "presentation"
          },
          "class": iconClass
        });
      }
      return null;
    };
    return h("button", {
      "class": this.buttonClasses,
      onClick: this.handleClick,
      on: this.v3 ? void 0 : {
        "click": this.handleClick,
        "mousedown": this.handleMouseDown,
        "mouseup": this.handleMouseUp,
        "pointerdown": this.handlePointerDown,
        "pointerup": this.handlePointerUp,
        "focus": this.handleFocus,
        "blur": this.handleBlur,
        "keypress": this.handleKeypress,
        "keydown": this.handleKeydown,
        "contextmenu": this.handleContextmenu
      },
      onMousedown: this.handleMouseDown,
      onMouseup: this.handleMouseUp,
      onPointerdown: this.handlePointerDown,
      onPointerup: this.handlePointerUp,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur,
      onKeypress: this.handleKeypress,
      onKeydown: this.handleKeydown,
      onContextmenu: this.handleContextmenu,
      title: this.title,
      attrs: this.v3 ? void 0 : {
        title: this.title,
        "aria-label": this.ariaLabel,
        "aria-disabled": this.$props.disabled || void 0,
        "aria-pressed": togglable ? this.currentActive ? true : false : void 0
      },
      "aria-label": this.ariaLabel,
      "aria-disabled": this.$props.disabled || void 0,
      "aria-pressed": togglable ? this.currentActive ? true : false : void 0
    }, [iconElement.call(this), defaultSlot && h("span", {
      "class": "k-button-text"
    }, [defaultSlot])]);
  }
};
var Button = ButtonVue2;

// node_modules/@progress/kendo-vue-buttons/dist/es/ButtonWrap.js
var allVue9 = vue_runtime_esm_bundler_exports;
var gh9 = allVue9.h;
var isV39 = allVue9.version && allVue9.version[0] === "3";
var ButtonWrapVue2 = {
  name: "KendoButtonWrap",
  props: {},
  // @ts-ignore
  setup: !isV39 ? void 0 : function() {
    var v3 = !!isV39;
    return {
      v3
    };
  },
  // @ts-ignore
  render: function render7(createElement) {
    var h = gh9 || createElement;
    var defaultSlot = getDefaultSlots(this);
    return defaultSlot[0];
  }
};
var ButtonWrap = ButtonWrapVue2;

// node_modules/@progress/kendo-vue-buttons/dist/es/ButtonGroup.js
var allVue10 = vue_runtime_esm_bundler_exports;
var gh10 = allVue10.h;
var isV310 = allVue10.version && allVue10.version[0] === "3";
var styles3 = util_default.styles;
var ButtonGroupVue2 = {
  name: "KendoButtonGroup",
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    width: String,
    dir: {
      type: String,
      default: function _default4() {
        return void 0;
      }
    }
  },
  created: function created6() {
    validatePackage(packageMetadata3);
  },
  // @ts-ignore
  setup: !isV310 ? void 0 : function() {
    var v3 = !!isV310;
    return {
      v3
    };
  },
  // @ts-ignore
  render: function render8(createElement) {
    var _a5;
    var h = gh10 || createElement;
    var defaultSlot = getDefaultSlots(this);
    var renderButton = function renderButton2(child, index, isLast, isRtl2) {
      var _a6;
      var className = classNames((_a6 = {}, _a6[styles3["state-disabled"]] = this.$props.disabled, _a6[styles3["group-start"]] = isRtl2 ? isLast : index === 0, _a6[styles3["group-end"]] = isRtl2 ? index === 0 : isLast, _a6));
      return h(ButtonWrap, {
        class: className,
        attrs: this.v3 ? void 0 : {
          "aria-disabled": this.$props.disabled
        },
        "aria-disabled": this.$props.disabled
      }, this.v3 ? function() {
        return [child];
      } : [child]);
    };
    var mapButtons = function mapButtons2(children) {
      var _this = this;
      var count = children.length;
      var rtl = this.$props.dir !== void 0 ? this.$props.dir === "rtl" : this.$el && getComputedStyle(this.$el).direction === "rtl" || false;
      return children.map(function(child, index) {
        if (_this.isValidButton(child)) {
          return renderButton.call(_this, child, index, index === count - 1, rtl);
        }
        return child;
      });
    };
    var groupClasses = classNames([styles3["button-group"]], (_a5 = {}, _a5["k-disabled"] = this.$props.disabled, _a5[styles3["button-group-stretched"]] = !!this.$props.width, _a5));
    return h("div", {
      style: {
        width: this.width
      },
      dir: this.$props.dir,
      attrs: this.v3 ? void 0 : {
        dir: this.$props.dir,
        role: "group",
        "aria-disabled": this.$props.disabled
      },
      role: "group",
      "aria-disabled": this.$props.disabled,
      "class": groupClasses
    }, [mapButtons.call(this, defaultSlot)]);
  },
  methods: {
    isValidButton: function isValidButton(child) {
      return child && child.tag && child.tag.toLowerCase().indexOf("button") !== -1 || child.componentOptions && child.componentOptions.tag && child.componentOptions.tag.toLowerCase().indexOf("button") !== -1 || child.type && child.type.name && child.type.name.toLowerCase().indexOf("kendobutton") !== -1;
    }
  }
};
var ButtonGroup = ButtonGroupVue2;

// node_modules/@progress/kendo-vue-buttons/dist/es/Chip/focus-reducer.js
var FOCUS_ACTION;
(function(FOCUS_ACTION2) {
  FOCUS_ACTION2["next"] = "next";
  FOCUS_ACTION2["prev"] = "prev";
  FOCUS_ACTION2["current"] = "current";
  FOCUS_ACTION2["reset"] = "reset";
})(FOCUS_ACTION || (FOCUS_ACTION = {}));

// node_modules/@progress/kendo-vue-buttons/dist/es/Chip/data-reducer.js
var DATA_ACTION;
(function(DATA_ACTION2) {
  DATA_ACTION2["remove"] = "remove";
  DATA_ACTION2["add"] = "add";
  DATA_ACTION2["reorder"] = "reorder";
})(DATA_ACTION || (DATA_ACTION = {}));

// node_modules/@progress/kendo-vue-buttons/dist/es/Chip/selection-reducer.js
var SELECTION_TYPE;
(function(SELECTION_TYPE2) {
  SELECTION_TYPE2["single"] = "single";
  SELECTION_TYPE2["multiple"] = "multiple";
  SELECTION_TYPE2["none"] = "none";
})(SELECTION_TYPE || (SELECTION_TYPE = {}));
var SELECTION_ACTION;
(function(SELECTION_ACTION2) {
  SELECTION_ACTION2["toggle"] = "toggle";
  SELECTION_ACTION2["remove"] = "remove";
})(SELECTION_ACTION || (SELECTION_ACTION = {}));

// node_modules/@progress/kendo-vue-buttons/dist/es/Chip/Chip.js
var allVue11 = vue_runtime_esm_bundler_exports;
var gh11 = allVue11.h;
var isV311 = allVue11.version && allVue11.version[0] === "3";
var ref2 = allVue11.ref;

// node_modules/@progress/kendo-vue-buttons/dist/es/Chip/ChipList.js
var allVue12 = vue_runtime_esm_bundler_exports;
var gh12 = allVue12.h;
var isV312 = allVue12.version && allVue12.version[0] === "3";
var ref3 = allVue12.ref;

// node_modules/@progress/kendo-vue-buttons/dist/es/FloatingActionButton/FloatingActionButtonItem.js
var allVue13 = vue_runtime_esm_bundler_exports;
var gh13 = allVue13.h;
var isV313 = allVue13.version && allVue13.version[0] === "3";
var ref4 = allVue13.ref;

// node_modules/@progress/kendo-vue-buttons/dist/es/FloatingActionButton/FloatingActionButton.js
var allVue14 = vue_runtime_esm_bundler_exports;
var gh14 = allVue14.h;
var isV314 = allVue14.version && allVue14.version[0] === "3";
var ref5 = allVue14.ref;

// node_modules/@progress/kendo-vue-buttons/dist/es/ListButton/ButtonItem.js
var allVue15 = vue_runtime_esm_bundler_exports;
var gh15 = allVue15.h;
var isV315 = allVue15.version && allVue15.version[0] === "3";

// node_modules/@progress/kendo-vue-buttons/dist/es/ListButton/SplitButton.js
var allVue16 = vue_runtime_esm_bundler_exports;
var gh16 = allVue16.h;
var isV316 = allVue16.version && allVue16.version[0] === "3";
var ref6 = allVue16.ref;

// node_modules/@progress/kendo-vue-buttons/dist/es/ListButton/DropDownButton.js
var allVue17 = vue_runtime_esm_bundler_exports;
var gh17 = allVue17.h;
var isV317 = allVue17.version && allVue17.version[0] === "3";
var ref7 = allVue17.ref;

// node_modules/@progress/kendo-vue-buttons/dist/es/toolbar/Toolbar.js
var allVue18 = vue_runtime_esm_bundler_exports;
var gh18 = allVue18.h;
var isV318 = allVue18.version && allVue18.version[0] === "3";

// node_modules/@progress/kendo-vue-buttons/dist/es/toolbar/tools/ToolbarItem.js
var allVue19 = vue_runtime_esm_bundler_exports;
var gh19 = allVue19.h;
var isV319 = allVue19.version && allVue19.version[0] === "3";

// node_modules/@progress/kendo-vue-buttons/dist/es/toolbar/tools/ToolbarSeparator.js
var allVue20 = vue_runtime_esm_bundler_exports;
var gh20 = allVue20.h;
var isV320 = allVue20.version && allVue20.version[0] === "3";

// node_modules/@progress/kendo-vue-buttons/dist/es/toolbar/tools/ToolbarSpacer.js
var allVue21 = vue_runtime_esm_bundler_exports;
var gh21 = allVue21.h;
var isV321 = allVue21.version && allVue21.version[0] === "3";

// node_modules/@progress/kendo-vue-inputs/dist/es/messages/main.js
var _a2;
var numericIncreaseValue = "numerictextbox.increment";
var numericDecreaseValue = "numerictextbox.decrement";
var sliderIncreaseValue = "slider.increment";
var sliderDecreaseValue = "slider.decrement";
var sliderDragTitle = "slider.dragTitle";
var colorGradientDragHandle = "colorGradient.dragHandle";
var colorGradientR = "colorGradient.r";
var colorGradientG = "colorGradient.g";
var colorGradientB = "colorGradient.b";
var colorGradientA = "colorGradient.a";
var colorGradientHex = "colorGradient.hex";
var colorGradientHexLabel = "colorGradient.hexLabel";
var colorGradientInputColorButton = "colorGradient.inputColorButton";
var colorGradientRLabel = "colorGradient.rLabel";
var colorGradientGLabel = "colorGradient.gLabel";
var colorGradientBLabel = "colorGradient.bLabel";
var colorGradientALabel = "colorGradient.aLabel";
var colorGradientContrastRatio = "colorGradient.contrastRatio";
var colorGradientAALevel = "colorGradient.colorGradientAALevel";
var colorGradientAAALevel = "colorGradient.colorGradientAAALevel";
var colorGradientPass = "colorGradient.colorGradientPass";
var colorGradientFail = "colorGradient.colorGradientFail";
var colorGradientHueSliderLabel = "colorGradient.hueSliderLabel";
var colorGradientAlphaSliderLabel = "colorGradient.alphaSliderLabel";
var flatColorPickerCancelBtn = "flatColorPicker.cancelBtn";
var flatColorPickerApplyBtn = "flatColorPicker.applyBtn";
var flatColorPickerGradientBtn = "flatColorPicker.gradientBtn";
var flatColorPickerPaletteBtn = "flatColorPicker.paletterBtn";
var flatColorPickerClearBtn = "flatColorPicker.clearBtn";
var checkboxValidation = "checkbox.validation";
var checkboxOptionalText = "checkbox.optionalText";
var radioButtonValidation = "radioButton.validation";
var switchValidation = "switch.validation";
var colorPickerDropdownButtonAriaLabel = "colorPicker.dropdownButtonAriaLabel";
var colorGradientToggleInputsButton = "colorGradient.toggleInputsButton";
var ratingAriaLabel = "rating.ariaLabel";
var signatureClear = "signature.clear";
var signatureMaximize = "signature.maximize";
var signatureMinimize = "signature.minimize";
var messages2 = (_a2 = {}, _a2[numericIncreaseValue] = "Increase value", _a2[numericDecreaseValue] = "Decrease value", _a2[sliderIncreaseValue] = "Increase", _a2[sliderDecreaseValue] = "Decrease", _a2[sliderDragTitle] = "Drag", _a2[colorGradientDragHandle] = "Color well with two-dimensional slider for selecting\n     saturation and lightness. Selected color is", _a2[colorGradientInputColorButton] = "Change the color input", _a2[colorGradientR] = "r", _a2[colorGradientG] = "g", _a2[colorGradientB] = "b", _a2[colorGradientA] = "a", _a2[colorGradientRLabel] = "red chanel", _a2[colorGradientGLabel] = "green chanel", _a2[colorGradientBLabel] = "blue chanel", _a2[colorGradientALabel] = "alpha chanel", _a2[colorGradientHex] = "hex", _a2[colorGradientHexLabel] = "HEX", _a2[colorGradientContrastRatio] = "Contrast ratio", _a2[colorGradientAALevel] = "AA", _a2[colorGradientAAALevel] = "AAA", _a2[colorGradientPass] = "Pass", _a2[colorGradientFail] = "Fail", _a2[colorGradientHueSliderLabel] = "Hue slider", _a2[colorGradientAlphaSliderLabel] = "Alpha slider", _a2[colorGradientToggleInputsButton] = "Toggle colorgradient inputs", _a2[flatColorPickerCancelBtn] = "Cancel", _a2[flatColorPickerApplyBtn] = "Apply", _a2[flatColorPickerGradientBtn] = "Gradient", _a2[flatColorPickerPaletteBtn] = "Palette", _a2[flatColorPickerClearBtn] = "Clear", _a2[checkboxValidation] = "Please check this box if you want to proceed!", _a2[checkboxOptionalText] = "(Optional)", _a2[radioButtonValidation] = "Please select option if you want to proceed!", _a2[switchValidation] = "Please turn on if you want to proceed!", _a2[colorPickerDropdownButtonAriaLabel] = "Select", _a2[ratingAriaLabel] = "Rating", _a2[signatureClear] = "Clear", _a2[signatureMaximize] = "Maximize", _a2[signatureMinimize] = "Minimize", _a2);

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/ColorInput.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var allVue22 = vue_runtime_esm_bundler_exports;
var gh22 = allVue22.h;
var isV322 = allVue22.version && allVue22.version[0] === "3";
var modes = ["rgba", "rgb", "hex"];
var ColorInputVue2 = {
  name: "KendoColorInput",
  // @ts-ignore
  emits: {
    "hexchange": null,
    "rgbachange": null
  },
  props: {
    tabIndex: Number,
    rgba: {
      type: Object,
      default: function _default5() {
        return {};
      }
    },
    hex: String,
    opacity: Boolean,
    disabled: Boolean
  },
  inject: {
    kendoLocalizationService: {
      default: null
    }
  },
  created: function created7() {
    this.hexInputId = guid();
  },
  data: function data6() {
    return {
      inputMode: modes[1]
    };
  },
  mounted: function mounted4() {
    this.lastFocusable = this.$refs.hexinput || this.$refs.numerica || this.$refs.numericb;
  },
  updated: function updated4() {
    this.lastFocusable = this.$refs.hexinput || this.$refs.numerica || this.$refs.numericb;
  },
  // @ts-ignore
  setup: !isV322 ? void 0 : function() {
    var v3 = !!isV322;
    return {
      v3
    };
  },
  // @ts-ignore
  render: function render9(createElement) {
    var h = gh22 || createElement;
    var localizationService = provideLocalizationService(this);
    var hexMessage = localizationService.toLanguageString(colorGradientHex, messages2[colorGradientHex]);
    var buttonMessage = localizationService.toLanguageString(colorGradientInputColorButton, messages2[colorGradientInputColorButton]);
    var rMessage = localizationService.toLanguageString(colorGradientR, messages2[colorGradientR]);
    var gMessage = localizationService.toLanguageString(colorGradientG, messages2[colorGradientG]);
    var bMessage = localizationService.toLanguageString(colorGradientB, messages2[colorGradientB]);
    var aMessage = localizationService.toLanguageString(colorGradientA, messages2[colorGradientA]);
    var rLabelMessage = localizationService.toLanguageString(colorGradientRLabel, messages2[colorGradientRLabel]);
    var gLabelMessage = localizationService.toLanguageString(colorGradientGLabel, messages2[colorGradientGLabel]);
    var bLabelMessage = localizationService.toLanguageString(colorGradientBLabel, messages2[colorGradientBLabel]);
    var aLabelMessage = localizationService.toLanguageString(colorGradientALabel, messages2[colorGradientALabel]);
    return h("div", {
      "class": "k-colorgradient-inputs k-hstack"
    }, [h("div", {
      "class": "k-vstack"
    }, [h(Button, {
      ariaLabel: buttonMessage,
      attrs: this.v3 ? void 0 : {
        ariaLabel: buttonMessage,
        tabIndex: this.tabIndex,
        type: "button",
        fillMode: "flat",
        icon: "caret-alt-expand",
        svgIcon: caretAltExpandIcon
      },
      tabIndex: this.tabIndex,
      type: "button",
      fillMode: "flat",
      icon: "caret-alt-expand",
      svgIcon: caretAltExpandIcon,
      "class": "k-colorgradient-toggle-mode k-icon-button",
      onClick: this.onToggleModeChange,
      on: this.v3 ? void 0 : {
        "click": this.onToggleModeChange,
        "keydown": this.onKeyDown
      },
      onKeydown: this.onKeyDown
    })]), this.inputMode === "hex" && h("div", {
      "class": "k-vstack k-flex-1"
    }, [
      h("span", {
        "class": "k-hex-value"
      }, [h(HexInput, {
        id: this.hexInputId,
        attrs: this.v3 ? void 0 : {
          id: this.hexInputId,
          tabIndex: this.tabIndex,
          hex: this.$props.hex,
          disabled: this.$props.disabled
        },
        tabIndex: this.tabIndex,
        hex: this.$props.hex,
        onHexchange: this.onHexChange,
        on: this.v3 ? void 0 : {
          "hexchange": this.onHexChange
        },
        disabled: this.$props.disabled,
        ref: "hexinput"
      })]),
      // @ts-ignore  function children
      h(Label, {
        "class": "k-colorgradient-input-label",
        "for": this.hexInputId,
        attrs: this.v3 ? void 0 : {
          "for": this.hexInputId
        }
      }, this.v3 ? function() {
        return [hexMessage];
      } : [hexMessage])
    ]), (this.inputMode === "rgb" || this.inputMode === "rgba") && [h("div", {
      "class": "k-vstack"
    }, [
      h(NumericTextBox, {
        inputType: "number",
        attrs: this.v3 ? void 0 : {
          inputType: "number",
          tabIndex: this.tabIndex,
          value: this.$props.rgba.r,
          min: 0,
          max: 255,
          spinners: false,
          format: "n",
          ariaLabel: rLabelMessage,
          disabled: this.$props.disabled
        },
        tabIndex: this.tabIndex,
        value: this.$props.rgba.r,
        min: 0,
        max: 255,
        spinners: false,
        format: "n",
        ariaLabel: rLabelMessage,
        onChange: this.onRgbaRChange,
        on: this.v3 ? void 0 : {
          "change": this.onRgbaRChange
        },
        disabled: this.$props.disabled
      }),
      // @ts-ignore  function children
      h(Label, {
        "class": "k-colorgradient-input-label"
      }, this.v3 ? function() {
        return [rMessage];
      } : [rMessage])
    ]), h("div", {
      "class": "k-vstack"
    }, [
      h(NumericTextBox, {
        inputType: "number",
        attrs: this.v3 ? void 0 : {
          inputType: "number",
          tabIndex: this.tabIndex,
          value: this.$props.rgba.g,
          min: 0,
          max: 255,
          spinners: false,
          format: "n",
          ariaLabel: gLabelMessage,
          disabled: this.$props.disabled
        },
        tabIndex: this.tabIndex,
        value: this.$props.rgba.g,
        min: 0,
        max: 255,
        spinners: false,
        format: "n",
        ariaLabel: gLabelMessage,
        onChange: this.onRgbaGChange,
        on: this.v3 ? void 0 : {
          "change": this.onRgbaGChange
        },
        disabled: this.$props.disabled
      }),
      // @ts-ignore  function children
      h(Label, {
        "class": "k-colorgradient-input-label"
      }, this.v3 ? function() {
        return [gMessage];
      } : [gMessage])
    ]), h("div", {
      "class": "k-vstack"
    }, [
      h(NumericTextBox, {
        inputType: "number",
        attrs: this.v3 ? void 0 : {
          inputType: "number",
          tabIndex: this.tabIndex,
          value: this.$props.rgba.b,
          min: 0,
          max: 255,
          spinners: false,
          format: "n",
          ariaLabel: bLabelMessage,
          disabled: this.$props.disabled
        },
        tabIndex: this.tabIndex,
        value: this.$props.rgba.b,
        min: 0,
        max: 255,
        spinners: false,
        format: "n",
        ariaLabel: bLabelMessage,
        onChange: this.onRgbaBChange,
        on: this.v3 ? void 0 : {
          "change": this.onRgbaBChange
        },
        disabled: this.$props.disabled,
        ref: "numericb"
      }),
      // @ts-ignore  function children
      h(Label, {
        "class": "k-colorgradient-input-label"
      }, this.v3 ? function() {
        return [bMessage];
      } : [bMessage])
    ])], this.inputMode === "rgba" && h("div", {
      "class": "k-vstack"
    }, [this.$props.opacity && h(NumericTextBox, {
      inputType: "number",
      attrs: this.v3 ? void 0 : {
        inputType: "number",
        tabIndex: this.tabIndex,
        value: this.$props.rgba.a,
        min: 0,
        max: 1,
        step: 0.01,
        spinners: false,
        format: "n2",
        ariaLabel: aLabelMessage,
        disabled: this.$props.disabled
      },
      tabIndex: this.tabIndex,
      value: this.$props.rgba.a,
      min: 0,
      max: 1,
      step: 0.01,
      spinners: false,
      format: "n2",
      ariaLabel: aLabelMessage,
      onChange: this.onRgbaAChange,
      on: this.v3 ? void 0 : {
        "change": this.onRgbaAChange
      },
      disabled: this.$props.disabled,
      ref: "numerica"
    }), this.$props.opacity && // @ts-ignore  function children
    h(Label, {
      "class": "k-colorgradient-input-label"
    }, this.v3 ? function() {
      return [aMessage];
    } : [aMessage])])]);
  },
  methods: {
    onHexChange: function onHexChange(event) {
      this.$emit("hexchange", event.hex, event.value, event);
    },
    onRgbaRChange: function onRgbaRChange(event) {
      this.dispatchRgbaChange({
        r: event.value
      }, event);
    },
    onRgbaGChange: function onRgbaGChange(event) {
      this.dispatchRgbaChange({
        g: event.value
      }, event);
    },
    onRgbaBChange: function onRgbaBChange(event) {
      this.dispatchRgbaChange({
        b: event.value
      }, event);
    },
    onRgbaAChange: function onRgbaAChange(event) {
      this.dispatchRgbaChange({
        a: event.value
      }, event);
    },
    dispatchRgbaChange: function dispatchRgbaChange(newValue, event) {
      var rgba2 = __assign2({}, this.$props.rgba);
      if (newValue.r !== void 0) {
        rgba2.r = newValue.r;
      }
      if (newValue.g !== void 0) {
        rgba2.g = newValue.g;
      }
      if (newValue.b !== void 0) {
        rgba2.b = newValue.b;
      }
      if (newValue.a !== void 0) {
        rgba2.a = newValue.a;
      }
      this.$emit("rgbachange", rgba2, event);
    },
    onToggleModeChange: function onToggleModeChange() {
      var index = modes.length - 1 === modes.indexOf(this.inputMode) ? 0 : modes.indexOf(this.inputMode) + 1;
      if (!this.$props.opacity) {
        var nextIndex = modes[index] === "rgba" ? index + 1 : index;
        this.inputMode = modes[nextIndex];
      } else {
        this.inputMode = modes[index];
      }
    },
    onKeyDown: function onKeyDown2(e) {
      if (e.keyCode === Keys.enter) {
        e.stopPropagation();
      }
    }
  }
};
var ColorInput = ColorInputVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/ColorContrastLabels.js
var allVue23 = vue_runtime_esm_bundler_exports;
var gh23 = allVue23.h;
var isV323 = allVue23.version && allVue23.version[0] === "3";
var ColorContrastLabelsVue2 = {
  name: "KendoColorContrastLabels",
  props: {
    bgColor: Object,
    rgba: Object
  },
  inject: {
    kendoLocalizationService: {
      default: null
    }
  },
  // @ts-ignore
  setup: !isV323 ? void 0 : function() {
    var v3 = !!isV323;
    return {
      v3
    };
  },
  // @ts-ignore
  render: function render10(createElement) {
    var h = gh23 || createElement;
    var ls = provideLocalizationService(this);
    var contrastRatioMessage = ls.toLanguageString(colorGradientContrastRatio, messages2[colorGradientContrastRatio]);
    var AALevelMessage = ls.toLanguageString(colorGradientAALevel, messages2[colorGradientAALevel]);
    var AAALevelMessage = ls.toLanguageString(colorGradientAAALevel, messages2[colorGradientAAALevel]);
    var passMessage = ls.toLanguageString(colorGradientPass, messages2[colorGradientPass]);
    var failMessage = ls.toLanguageString(colorGradientFail, messages2[colorGradientFail]);
    var contrast = getContrastFromTwoRGBAs(this.$props.rgba, this.$props.bgColor);
    var requiredAAContrast = 4.5.toFixed(1);
    var requiredAAAContrast = 7 .toFixed(1);
    var contrastText = "".concat(contrastRatioMessage, ": ").concat(contrast.toFixed(2));
    var aaText = "".concat(AALevelMessage, ": ").concat(requiredAAContrast);
    var aaaText = "".concat(AAALevelMessage, ": ").concat(requiredAAAContrast);
    var aaPass = contrast >= 4.5;
    var aaaPass = contrast >= 7;
    var success = h("span", {
      key: 1,
      "class": "k-contrast-validation k-text-success"
    }, [passMessage, " ", h(Icon, {
      name: "check",
      attrs: this.v3 ? void 0 : {
        name: "check",
        icon: checkIcon
      },
      icon: checkIcon
    })]);
    var error = h("span", {
      key: 2,
      "class": "k-contrast-validation k-text-error"
    }, [failMessage, " ", h(Icon, {
      name: "x",
      attrs: this.v3 ? void 0 : {
        name: "x",
        icon: xIcon
      },
      icon: xIcon
    })]);
    return h("div", {
      "class": "k-vbox k-colorgradient-color-contrast"
    }, [h("div", {
      "class": "k-contrast-ratio"
    }, [h("span", {
      "class": "k-contrast-ratio-text"
    }, [contrastText]), aaPass ? h("span", {
      "class": "k-contrast-validation k-text-success"
    }, [h(Icon, {
      name: "check",
      attrs: this.v3 ? void 0 : {
        name: "check",
        icon: checkIcon
      },
      icon: checkIcon
    }), aaaPass && h(Icon, {
      name: "check",
      attrs: this.v3 ? void 0 : {
        name: "check",
        icon: checkIcon
      },
      icon: checkIcon
    })]) : h("span", {
      "class": "k-contrast-validation k-text-error"
    }, [h(Icon, {
      name: "x",
      attrs: this.v3 ? void 0 : {
        name: "x",
        icon: xIcon
      },
      icon: xIcon
    })])]), h("div", [h("span", [aaText]), aaPass ? success : error]), h("div", [h("span", [aaaText]), aaaPass ? success : error])]);
  }
};
var ColorContrastLabels = ColorContrastLabelsVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/utils/svg-calc.js
var line = function(pointA, pointB) {
  var lengthX = pointB[0] - pointA[0];
  var lengthY = pointB[1] - pointA[1];
  return {
    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),
    angle: Math.atan2(lengthY, lengthX)
  };
};
var controlPoint = function(lineCalc) {
  return function(current, previous, next, reverse) {
    var p = previous || current;
    var n = next || current;
    var smooth = 0.1;
    var l = lineCalc(p, n);
    var angle = l.angle + (reverse ? Math.PI : 0);
    var length = l.length * smooth;
    var x = current[0] + Math.cos(angle) * length;
    var y = current[1] + Math.sin(angle) * length;
    return [x, y];
  };
};
var bezierCommand = function(controlPointCalc) {
  return function(point2, i, a) {
    var _a5 = controlPointCalc(a[i - 1], a[i - 2], point2), cpsX = _a5[0], cpsY = _a5[1];
    var _b = controlPointCalc(point2, a[i - 1], a[i + 1], true), cpeX = _b[0], cpeY = _b[1];
    return "C ".concat(cpsX, ",").concat(cpsY, " ").concat(cpeX, ",").concat(cpeY, " ").concat(point2[0], ",").concat(point2[1]);
  };
};

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/ColorContrastSvg.js
var allVue24 = vue_runtime_esm_bundler_exports;
var gh24 = allVue24.h;
var isV324 = allVue24.version && allVue24.version[0] === "3";
var AA_CONTRAST = 4.5;
var AAA_CONTRAST = 7;
var STEP_COUNT = 16;
var ColorContrastSvgVue2 = {
  name: "KendoColorContrastSvg",
  props: {
    metrics: Object,
    backgroundColor: String,
    hsva: Object
  },
  // @ts-ignore
  setup: !isV324 ? void 0 : function() {
    var v3 = !!isV324;
    return {
      v3
    };
  },
  // @ts-ignore
  render: function render11(createElement) {
    var _this = this;
    var h = gh24 || createElement;
    var svgPath = function svgPath2(points3, command) {
      if (points3.length === 0) {
        return "";
      }
      var d = points3.reduce(function(acc, point2, i, a) {
        return i === 0 ? (
          // if first point
          "M ".concat(point2[0], ",").concat(point2[1])
        ) : (
          // else
          "".concat(acc, " ").concat(command(point2, i, a))
        );
      }, "");
      return h("path", {
        d,
        attrs: this.v3 ? void 0 : {
          d,
          fill: "none",
          stroke: "white",
          "stroke-width": "1"
        },
        fill: "none",
        stroke: "white",
        "stroke-width": "1"
      });
    };
    var gradientRectMetrics = this.$props.metrics;
    var findValue = function findValue2(contrast, saturation, low, high, comparer) {
      var mid = (low + high) / 2;
      var hsva2 = Object.assign({}, _this.$props.hsva, {
        s: saturation / gradientRectMetrics.width,
        v: 1 - mid / gradientRectMetrics.height
      });
      var currentContrast = getContrastFromTwoRGBAs(getRGBA(getColorFromHSV(hsva2)), getRGBA(_this.$props.backgroundColor || ""));
      if (low + 0.5 > high) {
        if (currentContrast < contrast + 1 && currentContrast > contrast - 1) {
          return mid;
        } else {
          return null;
        }
      }
      if (comparer(currentContrast, contrast)) {
        return findValue2(contrast, saturation, low, high - (high - low) / 2, comparer);
      }
      return findValue2(contrast, saturation, low + (high - low) / 2, high, comparer);
    };
    var getPaths = function getPaths2(contrast, stepCount, reversed) {
      if (reversed === void 0) {
        reversed = false;
      }
      var points3 = [];
      for (var i = 0; i <= gradientRectMetrics.width; i += gradientRectMetrics.width / stepCount) {
        var value2 = findValue(contrast, i, 0, gradientRectMetrics.height, reversed ? function(a, b) {
          return a < b;
        } : function(a, b) {
          return a > b;
        });
        if (value2 !== null) {
          points3.push([i, value2]);
        }
      }
      return points3;
    };
    var bezierCommandCalc = bezierCommand(controlPoint(line));
    return h("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      attrs: this.v3 ? void 0 : {
        xmlns: "http://www.w3.org/2000/svg"
      },
      "class": "k-color-contrast-svg",
      style: {
        position: "absolute",
        overflow: "visible",
        pointerEvents: "none",
        left: 0,
        top: 0,
        zIndex: 3
      }
    }, [svgPath.call(this, getPaths(AA_CONTRAST, STEP_COUNT), bezierCommandCalc), svgPath.call(this, getPaths(AA_CONTRAST, STEP_COUNT, true), bezierCommandCalc), svgPath.call(this, getPaths(AAA_CONTRAST, STEP_COUNT), bezierCommandCalc), svgPath.call(this, getPaths(AAA_CONTRAST, STEP_COUNT, true), bezierCommandCalc)]);
  }
};
var ColorContrastSvg = ColorContrastSvgVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/ColorGradient.js
var allVue25 = vue_runtime_esm_bundler_exports;
var gh25 = allVue25.h;
var isV325 = allVue25.version && allVue25.version[0] === "3";
var FORMAT = "rgba";
var DEFAULT_SELECTED_COLOR = "rgba(255, 255, 255, 1)";
var ColorGradientVue2 = {
  name: "KendoColorGradient",
  model: {
    event: "changemodel"
  },
  // @ts-ignore
  emits: {
    "change": null,
    "focus": null,
    "blur": null,
    "changemodel": null,
    "update:modelValue": null,
    "update:modelRgbaValue": null,
    "keydown": null
  },
  inject: {
    kendoLocalizationService: {
      default: null
    }
  },
  props: {
    modelValue: String,
    modelRgbaValue: String,
    defaultValue: String,
    value: String,
    opacity: {
      type: Boolean,
      default: true
    },
    backgroundColor: String,
    disabled: Boolean,
    id: String,
    ariaLabelledBy: String,
    ariaDescribedBy: String,
    tabIndex: Number,
    innerTabIndex: {
      type: Number,
      default: void 0
    }
  },
  created: function created8() {
    validatePackage(packageMetadata);
    this.guid = guid();
  },
  computed: {
    valueSet: function valueSet() {
      return this.value || this.modelValue || this.modelRgbaValue;
    },
    computedValue: function computedValue() {
      var value2 = this.valueSet || this.currentValue || this.defaultValue || parseColor2(DEFAULT_SELECTED_COLOR, FORMAT);
      if (!isPresent(parseColor2(value2, "hex", this.opacity))) {
        value2 = DEFAULT_SELECTED_COLOR;
      }
      return value2;
    },
    hsva: function hsva() {
      return this.valueSet ? getHSV(this.computedValue) : this.currentHsva || getHSV(this.computedValue);
    },
    rgba: function rgba() {
      return this.valueSet ? getRGBA(this.computedValue) : this.currentRgba;
    },
    hex: function hex3() {
      return this.valueSet ? parseColor2(this.computedValue, "hex", this.opacity) : this.currentHex;
    },
    computedBgColor: function computedBgColor() {
      return this.currentBgColor || getColorFromHue(this.hsva.h);
    },
    computedTabIndex: function computedTabIndex() {
      return this.innerTabIndex !== void 0 ? this.innerTabIndex : this.focused ? 0 : -1;
    }
  },
  data: function data7() {
    return {
      currentValue: void 0,
      currentBgColor: void 0,
      isFirstRender: true,
      currentHsva: void 0,
      currentRgba: void 0,
      currentHex: void 0,
      focused: false
    };
  },
  mounted: function mounted5() {
    this.setAlphaSliderBackground(this.computedBgColor);
    if (this.$el) {
      this.draggable = this.$refs.draggable;
      this.gradientWrapper = this.draggable && this.draggable.element;
    }
    this.alphaSlider = this.v3 ? this.alphaSliderRef : this.$refs.alphaSlider;
    if (this.isFirstRender) {
      this.isFirstRender = false;
    }
  },
  destroyed: function destroyed() {
    removeCachedColor(this.guid);
  },
  updated: function updated5() {
    this.setAlphaSliderBackground(this.computedBgColor);
  },
  // @ts-ignore
  setup: !isV325 ? void 0 : function() {
    var v3 = !!isV325;
    return {
      v3
    };
  },
  // @ts-ignore
  render: function render12(createElement) {
    var _this2 = this;
    var _this = this;
    var h = gh25 || createElement;
    var className = classNames("k-colorgradient", {
      "k-disabled": this.$props.disabled
    });
    var localizationService = provideLocalizationService(this);
    var colorGradientHueSliderLabelMessage = localizationService.toLanguageString(colorGradientHueSliderLabel, messages2[colorGradientHueSliderLabel]);
    var colorGradientAlphaSliderLabelMessage = localizationService.toLanguageString(colorGradientAlphaSliderLabel, messages2[colorGradientAlphaSliderLabel]);
    var dragHandle = localizationService.toLanguageString(colorGradientDragHandle, messages2[colorGradientDragHandle]);
    var renderRectangleDragHandle = function renderRectangleDragHandle2() {
      var style = {};
      if (!this.isFirstRender) {
        var gradientRectMetrics = this.getGradientRectMetrics();
        var top_1 = (1 - this.hsva.v) * gradientRectMetrics.height;
        var left = this.hsva.s * gradientRectMetrics.width;
        style.top = "".concat(top_1, "px");
        style.left = "".concat(left, "px");
      }
      return h("div", {
        "class": "k-hsv-draghandle k-draghandle",
        role: "slider",
        attrs: this.v3 ? void 0 : {
          role: "slider",
          "aria-orientation": "undefined",
          "aria-label": dragHandle + "".concat(this.value || "none"),
          "aria-valuenow": Math.round(this.hsva.s * 100),
          "aria-valuetext": "\n                    saturation: ".concat(Math.round(this.hsva.s * 100), "%,\n                    value: ").concat(Math.round(this.hsva.v * 100), "%"),
          tabindex: this.computedTabIndex
        },
        "aria-orientation": "undefined",
        "aria-label": dragHandle + "".concat(this.value || "none"),
        "aria-valuenow": Math.round(this.hsva.s * 100),
        "aria-valuetext": "\n                    saturation: ".concat(Math.round(this.hsva.s * 100), "%,\n                    value: ").concat(Math.round(this.hsva.v * 100), "%"),
        tabindex: this.computedTabIndex,
        onKeydown: this.dragKeyDown,
        on: this.v3 ? void 0 : {
          "keydown": this.dragKeyDown
        },
        style,
        ref: setRef(this, "draghandle")
      });
    };
    return h("div", {
      id: this.$props.id,
      attrs: this.v3 ? void 0 : {
        id: this.$props.id,
        role: this.$props.tabIndex !== -1 ? "textbox" : void 0,
        "aria-disabled": this.$props.disabled,
        tabindex: getTabIndex(this.$props.tabIndex, this.$props.disabled),
        "aria-labelledby": this.$props.ariaLabelledBy,
        "aria-describedby": this.$props.ariaDescribedBy
      },
      "class": className,
      role: this.$props.tabIndex !== -1 ? "textbox" : void 0,
      "aria-disabled": this.$props.disabled,
      tabindex: getTabIndex(this.$props.tabIndex, this.$props.disabled),
      "aria-labelledby": this.$props.ariaLabelledBy,
      "aria-describedby": this.$props.ariaDescribedBy,
      onFocus: this.onFocus,
      on: this.v3 ? void 0 : {
        "focus": this.onFocus,
        "blur": this.onBlur,
        "keydown": this.onKeyDownHandler
      },
      onBlur: this.onBlur,
      onKeydown: this.onKeyDownHandler
    }, [h("div", {
      "class": "k-colorgradient-canvas k-hstack"
    }, [h("div", {
      "class": "k-hsv-rectangle",
      style: {
        background: this.computedBgColor
      }
    }, [
      // @ts-ignore  function children
      h(Draggable, {
        onDrag: this.onDrag,
        on: this.v3 ? void 0 : {
          "drag": this.onDrag,
          "release": this.onRelease
        },
        onRelease: this.onRelease,
        ref: "draggable"
      }, this.v3 ? function() {
        return [h("div", {
          "class": "k-hsv-gradient",
          style: {
            touchAction: "none"
          },
          tabindex: -1,
          attrs: _this2.v3 ? void 0 : {
            tabindex: -1
          },
          onClick: _this2.onGradientWrapperClick,
          on: _this2.v3 ? void 0 : {
            "click": _this2.onGradientWrapperClick
          }
        }, [renderRectangleDragHandle.call(_this2)])];
      } : [h("div", {
        "class": "k-hsv-gradient",
        style: {
          touchAction: "none"
        },
        tabindex: -1,
        attrs: _this2.v3 ? void 0 : {
          tabindex: -1
        },
        onClick: _this2.onGradientWrapperClick,
        on: _this2.v3 ? void 0 : {
          "click": _this2.onGradientWrapperClick
        }
      }, [renderRectangleDragHandle.call(_this2)])]),
      this.backgroundColor && !this.isFirstRender && h(ColorContrastSvg, {
        metrics: this.gradientWrapper ? this.getGradientRectMetrics() : void 0,
        attrs: this.v3 ? void 0 : {
          metrics: this.gradientWrapper ? this.getGradientRectMetrics() : void 0,
          hsva: this.hsva,
          backgroundColor: this.backgroundColor
        },
        hsva: this.hsva,
        backgroundColor: this.backgroundColor
      })
    ]), h("div", {
      "class": "k-hsv-controls k-hstack"
    }, [h(Slider, {
      tabIndex: this.computedTabIndex,
      attrs: this.v3 ? void 0 : {
        tabIndex: this.computedTabIndex,
        value: this.hsva.h,
        buttons: false,
        vertical: true,
        min: 0,
        max: 360,
        step: 5,
        disabled: this.$props.disabled,
        ariaLabel: colorGradientHueSliderLabelMessage
      },
      value: this.hsva.h,
      buttons: false,
      vertical: true,
      min: 0,
      max: 360,
      step: 5,
      onChange: this.onHueSliderChange,
      on: this.v3 ? void 0 : {
        "change": this.onHueSliderChange
      },
      "class": "k-hue-slider k-colorgradient-slider",
      disabled: this.$props.disabled,
      ariaLabel: colorGradientHueSliderLabelMessage
    }), this.$props.opacity && h(Slider, {
      tabIndex: this.computedTabIndex,
      attrs: this.v3 ? void 0 : {
        tabIndex: this.computedTabIndex,
        value: isPresent(this.hsva.a) ? this.hsva.a * 100 : 100,
        buttons: false,
        vertical: true,
        min: 0,
        max: 100,
        step: 1,
        disabled: this.$props.disabled,
        ariaLabel: colorGradientAlphaSliderLabelMessage
      },
      value: isPresent(this.hsva.a) ? this.hsva.a * 100 : 100,
      buttons: false,
      vertical: true,
      min: 0,
      max: 100,
      step: 1,
      onChange: this.onAlphaSliderChange,
      on: this.v3 ? void 0 : {
        "change": this.onAlphaSliderChange
      },
      "class": "k-alpha-slider k-colorgradient-slider",
      disabled: this.$props.disabled,
      ariaLabel: colorGradientAlphaSliderLabelMessage,
      ref: this.v3 ? function(el) {
        _this.alphaSliderRef = el;
      } : "alphaSlider"
    })])]), h(ColorInput, {
      tabIndex: this.computedTabIndex,
      attrs: this.v3 ? void 0 : {
        tabIndex: this.computedTabIndex,
        rgba: this.rgba,
        hex: this.hex,
        opacity: this.$props.opacity,
        disabled: this.$props.disabled
      },
      rgba: this.rgba,
      onRgbachange: this.onRgbaChange,
      on: this.v3 ? void 0 : {
        "rgbachange": this.onRgbaChange,
        "hexchange": this.onHexChange
      },
      hex: this.hex,
      onHexchange: this.onHexChange,
      opacity: this.$props.opacity,
      disabled: this.$props.disabled,
      ref: "colorInput"
    }), this.backgroundColor && h(ColorContrastLabels, {
      bgColor: getRGBA(this.backgroundColor),
      attrs: this.v3 ? void 0 : {
        bgColor: getRGBA(this.backgroundColor),
        rgba: this.rgba
      },
      rgba: this.rgba
    })]);
  },
  methods: {
    onKeyDownHandler: function onKeyDownHandler(e) {
      var element2 = this.$el;
      if (this.innerTabIndex === void 0) {
        this.focused = focusContainer(e, element2);
      }
      this.$emit("keydown", e);
    },
    onHexChange: function onHexChange2(hex4, value2, event) {
      var rgba2 = getRGBA(value2);
      var hsva2 = getHSV(value2);
      this.currentHsva = hsva2;
      this.currentBgColor = getColorFromHue(hsva2.h);
      this.currentRgba = rgba2;
      this.currentHex = hex4;
      this.dispatchChangeEvent(value2, event.event, hex4, value2);
    },
    onRgbaChange: function onRgbaChange(rgba2, event) {
      var value2 = getColorFromRGBA(rgba2);
      var hex4 = parseColor2(value2, "hex", this.opacity);
      var hsva2 = getHSV(value2);
      this.currentHsva = hsva2;
      this.currentBgColor = getColorFromHue(hsva2.h);
      this.currentRgba = rgba2;
      this.currentHex = hex4;
      this.dispatchChangeEvent(value2, event.event, hex4, value2);
    },
    onAlphaSliderChange: function onAlphaSliderChange(event) {
      this.handleHsvaChange(Object.assign({}, this.hsva, {
        a: event.value / 100
      }), event.event);
    },
    onHueSliderChange: function onHueSliderChange(event) {
      this.handleHsvaChange(Object.assign({}, this.hsva, {
        h: event.value
      }), event.event);
    },
    onDrag: function onDrag(e) {
      this.gradientWrapper.classList.add("k-dragging");
      this.changePosition(e);
    },
    onRelease: function onRelease() {
      this.gradientWrapper.classList.remove("k-dragging");
    },
    onGradientWrapperClick: function onGradientWrapperClick(event) {
      this.firstFocusable = getRef(this, "draghandle");
      if (this.firstFocusable) {
        this.firstFocusable.focus();
      }
      this.changePosition(event);
    },
    move: function move(e, prop, d) {
      var c = this.hsva;
      c[prop] += d * (e.shiftKey ? 0.01 : 0.05);
      if (c[prop] < 0) {
        c[prop] = 0;
      }
      if (c[prop] > 1) {
        c[prop] = 1;
      }
      e.preventDefault();
      this.handleHsvaChange(c, e);
    },
    dragKeyDown: function dragKeyDown(e) {
      switch (e.keyCode) {
        case Keys.left:
          this.move(e, "s", -1);
          break;
        case Keys.right:
          this.move(e, "s", 1);
          break;
        case Keys.up:
          this.move(e, "v", 1);
          break;
        case Keys.down:
          this.move(e, "v", -1);
          break;
        case Keys.enter:
          break;
        case Keys.esc:
          break;
        default:
          break;
      }
    },
    changePosition: function changePosition(event) {
      var gradientRectMetrics = this.getGradientRectMetrics();
      var deltaX = event.clientX - gradientRectMetrics.left;
      var deltaY = event.clientY - gradientRectMetrics.top;
      var left = fitIntoBounds(deltaX, 0, gradientRectMetrics.width);
      var top = fitIntoBounds(deltaY, 0, gradientRectMetrics.height);
      var hsva2 = Object.assign({}, this.hsva, {
        s: left / gradientRectMetrics.width,
        v: 1 - top / gradientRectMetrics.height
      });
      this.handleHsvaChange(hsva2, event, event.event);
    },
    handleHsvaChange: function handleHsvaChange(hsva2, event) {
      var value2 = getColorFromHSV(hsva2);
      var hex4 = parseColor2(value2, "hex", this.opacity);
      var rgba2 = parseColor2(value2, "rgba");
      this.currentHsva = hsva2;
      this.currentBgColor = getColorFromHue(hsva2.h);
      this.currentRgba = getRGBA(value2);
      this.currentHex = hex4;
      this.dispatchChangeEvent(value2, event, hex4, rgba2);
    },
    dispatchChangeEvent: function dispatchChangeEvent2(value2, event, hex4, rgbaValue) {
      this.currentValue = value2;
      this.$emit("changemodel", hex4);
      this.$emit("update:modelRgbaValue", rgbaValue);
      this.$emit("update:modelValue", hex4);
      this.$emit("change", {
        event,
        target: this,
        value: hex4,
        rgbaValue
      });
    },
    onFocus: function onFocus3(event) {
      this.$emit("focus", {
        event,
        target: this
      });
    },
    onBlur: function onBlur3(event) {
      this.$emit("blur", {
        event,
        target: this
      });
    },
    setAlphaSliderBackground: function setAlphaSliderBackground(backgroundColor) {
      if (this.$props.opacity && this.alphaSlider && this.alphaSlider.sliderTrack) {
        this.alphaSlider.sliderTrack.style.background = "linear-gradient(to top, transparent, ".concat(backgroundColor, ")");
      }
    },
    getGradientRectMetrics: function getGradientRectMetrics() {
      var rect = this.gradientWrapper.getBoundingClientRect();
      return {
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      };
    },
    focus: function focus4() {
      var _this = this;
      this.focused = true;
      setTimeout(function() {
        focusFirstFocusableChild(_this.$el);
      }, 1);
    }
  }
};
var ColorGradient = ColorGradientVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/Picker.js
var allVue26 = vue_runtime_esm_bundler_exports;
var gh26 = allVue26.h;
var isV326 = allVue26.version && allVue26.version[0] === "3";
var ANCHOR_VERTICAL_ALIGN = "bottom";
var POPUP_VERTICAL_ALIGN = "top";
var PickerVue2 = {
  name: "KendoPicker",
  props: {
    popupSettings: Object,
    dir: String,
    open: Boolean,
    popupAnchor: String,
    id: String
  },
  computed: {
    horizontalAlign: function horizontalAlign() {
      return this.$props.dir === "rtl" ? "right" : "left";
    },
    anchorAlign: function anchorAlign() {
      return {
        horizontal: this.horizontalAlign,
        vertical: ANCHOR_VERTICAL_ALIGN
      };
    },
    popupAlign: function popupAlign() {
      return {
        horizontal: this.horizontalAlign,
        vertical: POPUP_VERTICAL_ALIGN
      };
    }
  },
  // @ts-ignore
  setup: !isV326 ? void 0 : function() {
    var v3 = !!isV326;
    return {
      v3
    };
  },
  // @ts-ignore
  render: function render13(createElement) {
    var h = gh26 || createElement;
    var defaultSlot = getDefaultSlots(this);
    var _a5 = this.$props.popupSettings, popupClass = _a5.popupClass, appendTo = _a5.appendTo, animate = _a5.animate, className = _a5.className;
    return (
      // @ts-ignore function children
      h(Popup, {
        id: this.id,
        attrs: this.v3 ? void 0 : {
          id: this.id,
          anchor: this.$props.popupAnchor,
          anchorAlign: this.anchorAlign,
          popupAlign: this.popupAlign,
          show: this.$props.open,
          appendTo,
          animate,
          popupClass
        },
        anchor: this.$props.popupAnchor,
        anchorAlign: this.anchorAlign,
        popupAlign: this.popupAlign,
        show: this.$props.open,
        onOpen: this.onOpen,
        on: this.v3 ? void 0 : {
          "open": this.onOpen,
          "close": this.onClose
        },
        onClose: this.onClose,
        appendTo,
        animate,
        popupClass,
        "class": classNames("k-reset", className)
      }, this.v3 ? function() {
        return [defaultSlot];
      } : [defaultSlot])
    );
  },
  methods: {
    onOpen: function onOpen() {
      this.$emit("open");
    },
    onClose: function onClose() {
      this.$emit("close");
    }
  }
};
var Picker = PickerVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/FlatColorPicker.js
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
var allVue27 = vue_runtime_esm_bundler_exports;
var gh27 = allVue27.h;
var isV327 = allVue27.version && allVue27.version[0] === "3";
var FlatColorPickerVue2 = {
  name: "KendoFlatColorPicker",
  // @ts-ignore
  emits: {
    "viewchange": null,
    "changemodel": null,
    "update:modelValue": null,
    "update:modelRgbaValue": null,
    "focus": null,
    "blur": null,
    "focusout": null,
    "keydown": null,
    "change": null
  },
  props: {
    modelValue: String,
    modelRgbaValue: String,
    value: String,
    prevValue: String,
    tabIndex: Number,
    disabled: Boolean,
    view: {
      type: String,
      default: "combo",
      validator: function validator4(value2) {
        return ["gradient", "palette", "combo"].includes(value2);
      }
    },
    selectedView: {
      type: Number,
      default: void 0
    },
    header: [String, Function, Object],
    footer: [String, Function, Object],
    showClearButton: {
      type: Boolean,
      default: true
    },
    showPreview: {
      type: Boolean,
      default: true
    },
    showButtons: {
      type: Boolean,
      default: true
    },
    gradientSettings: {
      type: Object,
      default: function _default6() {
        return DEFAULT_GRADIENT_SETTINGS;
      }
    },
    paletteSettings: {
      type: Object,
      default: function _default7() {
        return DEFAULT_PALETTE_SETTINGS;
      }
    }
  },
  inject: {
    kendoLocalizationService: {
      default: null
    }
  },
  created: function created9() {
    validatePackage(packageMetadata);
  },
  computed: {
    isColorGradient: function isColorGradient() {
      return this.view !== "combo" ? this.view === "gradient" : this.selectedView !== void 0 ? this.selectedView === 0 : this.currentView === "gradient";
    },
    computedColor: function computedColor() {
      return this.value !== void 0 ? this.value : this.modelValue !== void 0 ? this.modelValue : this.modelRgbaValue !== void 0 ? this.modelRgbaValue : this.colorValue;
    },
    computedPrevColor: function computedPrevColor() {
      return this.prevValue !== void 0 ? this.prevValue : this.currentPrevColor;
    },
    previewClass: function previewClass() {
      return {
        "k-coloreditor-preview-color": true,
        "k-color-preview": true,
        "k-no-color": !this.colorValue
      };
    },
    currentClass: function currentClass() {
      return {
        "k-coloreditor-current-color": true,
        "k-color-preview": true,
        "k-no-color": !this.computedPrevColor
      };
    },
    computedTabIndex: function computedTabIndex2() {
      return this.focused ? 0 : -1;
    }
  },
  data: function data8() {
    var initialValue = this.value || this.defaultValue || this.modelValue || this.modelRgbaValue;
    return {
      currentView: "gradient",
      colorValue: initialValue,
      currentPrevColor: initialValue,
      focused: false
    };
  },
  // @ts-ignore
  setup: !isV327 ? void 0 : function() {
    var v3 = !!isV327;
    return {
      v3
    };
  },
  // @ts-ignore
  render: function render14(createElement) {
    var _this2 = this;
    var _this = this;
    var h = gh27 || createElement;
    var localizationService = provideLocalizationService(this);
    var gradientMessage = localizationService.toLanguageString(flatColorPickerGradientBtn, messages2[flatColorPickerGradientBtn]);
    var paletteMessage = localizationService.toLanguageString(flatColorPickerPaletteBtn, messages2[flatColorPickerPaletteBtn]);
    var clearMessage = localizationService.toLanguageString(flatColorPickerClearBtn, messages2[flatColorPickerClearBtn]);
    var cancelMessage = localizationService.toLanguageString(flatColorPickerCancelBtn, messages2[flatColorPickerCancelBtn]);
    var applyMessage = localizationService.toLanguageString(flatColorPickerApplyBtn, messages2[flatColorPickerApplyBtn]);
    var headerTemplate = templateRendering.call(this, this.$props.header, getListeners.call(this));
    var footerTemplate = templateRendering.call(this, this.$props.footer, getListeners.call(this));
    var header = getTemplate.call(this, {
      h,
      template: headerTemplate
    });
    var footer = getTemplate.call(this, {
      h,
      template: footerTemplate
    });
    var renderGradiente = function renderGradiente2() {
      return h(ColorGradient, __assign3({
        attrs: this.v3 ? void 0 : __assign3({
          tabIndex: -1,
          value: this.colorValue,
          innerTabIndex: this.computedTabIndex
        }, this.gradientSettings),
        ref: setRef(this, "gradient"),
        tabIndex: -1,
        value: this.colorValue,
        innerTabIndex: this.computedTabIndex,
        onChange: this.handleColorChange,
        onKeydown: this.innerKeyDown,
        on: this.v3 ? void 0 : {
          "change": this.handleColorChange,
          "keydown": this.innerKeyDown
        }
      }, this.gradientSettings));
    };
    var renderPalette = function renderPalette2() {
      return h(ColorPalette, __assign3({
        on: this.v3 ? void 0 : {
          "change": this.handlePaletteColorChange,
          "keydown": this.gradientKeyDown
        },
        ref: setRef(this, "palette"),
        tabIndex: this.computedTabIndex,
        value: this.colorValue,
        attrs: this.v3 ? void 0 : __assign3({
          tabIndex: this.computedTabIndex,
          value: this.colorValue
        }, this.paletteSettings),
        onChange: this.handlePaletteColorChange,
        onKeydown: this.gradientKeyDown
      }, this.paletteSettings));
    };
    return h("div", {
      tabindex: getTabIndex(this.$props.tabIndex, this.$props.disabled),
      attrs: this.v3 ? void 0 : {
        tabindex: getTabIndex(this.$props.tabIndex, this.$props.disabled),
        "aria-disabled": this.$props.disabled
      },
      onFocus: this.onFocus,
      on: this.v3 ? void 0 : {
        "focus": this.onFocus,
        "blur": this.onBlur,
        "focusout": this.onFocusout,
        "keydown": this.onKeyDownHandler
      },
      onBlur: this.onBlur,
      onFocusout: this.onFocusout,
      onKeydown: this.onKeyDownHandler,
      "class": classNames("k-flatcolorpicker k-coloreditor", {
        "k-disabled": this.$props.disabled
      }),
      "aria-disabled": this.$props.disabled
    }, [header, this.$props.showClearButton && this.$props.showPreview && h("div", {
      "class": "k-coloreditor-header k-hstack"
    }, [this.$props.view === "combo" && h("div", {
      "class": "k-coloreditor-header-actions k-hstack"
    }, [
      // @ts-ignore  function children
      h(ButtonGroup, {
        "class": "k-button-group-flat"
      }, this.v3 ? function() {
        return [
          // @ts-ignore  function children
          h(Button, {
            tabIndex: _this2.computedTabIndex,
            attrs: _this2.v3 ? void 0 : {
              tabIndex: _this2.computedTabIndex,
              type: "button",
              togglable: true,
              fillMode: "flat",
              selected: _this2.isColorGradient,
              ariaLabel: gradientMessage
            },
            type: "button",
            togglable: true,
            fillMode: "flat",
            selected: _this2.isColorGradient,
            onKeydown: _this2.handleButtonKeydown,
            on: _this2.v3 ? void 0 : {
              "keydown": _this2.handleButtonKeydown,
              "click": function click(e) {
                return _this.handleViewChange(e, "gradient");
              }
            },
            ariaLabel: gradientMessage,
            onClick: function click(e) {
              return _this.handleViewChange(e, "gradient");
            }
          }, _this2.v3 ? function() {
            return [h(Icon, {
              name: "droplet-slider",
              attrs: _this2.v3 ? void 0 : {
                name: "droplet-slider",
                icon: dropletSliderIcon
              },
              icon: dropletSliderIcon
            })];
          } : [h(Icon, {
            name: "droplet-slider",
            attrs: _this2.v3 ? void 0 : {
              name: "droplet-slider",
              icon: dropletSliderIcon
            },
            icon: dropletSliderIcon
          })]),
          // @ts-ignore  function children
          h(Button, {
            tabIndex: _this2.computedTabIndex,
            attrs: _this2.v3 ? void 0 : {
              tabIndex: _this2.computedTabIndex,
              type: "button",
              togglable: true,
              fillMode: "flat",
              selected: !_this2.isColorGradient,
              ariaLabel: paletteMessage
            },
            type: "button",
            togglable: true,
            fillMode: "flat",
            selected: !_this2.isColorGradient,
            onKeydown: _this2.handleButtonKeydown,
            on: _this2.v3 ? void 0 : {
              "keydown": _this2.handleButtonKeydown,
              "click": function click(e) {
                return _this.handleViewChange(e, "palette");
              }
            },
            ariaLabel: paletteMessage,
            onClick: function click(e) {
              return _this.handleViewChange(e, "palette");
            }
          }, _this2.v3 ? function() {
            return [h(Icon, {
              name: "palette",
              attrs: _this2.v3 ? void 0 : {
                name: "palette",
                icon: paletteIcon
              },
              icon: paletteIcon
            })];
          } : [h(Icon, {
            name: "palette",
            attrs: _this2.v3 ? void 0 : {
              name: "palette",
              icon: paletteIcon
            },
            icon: paletteIcon
          })])
        ];
      } : [h(Button, {
        tabIndex: _this2.computedTabIndex,
        attrs: _this2.v3 ? void 0 : {
          tabIndex: _this2.computedTabIndex,
          type: "button",
          togglable: true,
          fillMode: "flat",
          selected: _this2.isColorGradient,
          ariaLabel: gradientMessage
        },
        type: "button",
        togglable: true,
        fillMode: "flat",
        selected: _this2.isColorGradient,
        onKeydown: _this2.handleButtonKeydown,
        on: _this2.v3 ? void 0 : {
          "keydown": _this2.handleButtonKeydown,
          "click": function click(e) {
            return _this.handleViewChange(e, "gradient");
          }
        },
        ariaLabel: gradientMessage,
        onClick: function click(e) {
          return _this.handleViewChange(e, "gradient");
        }
      }, _this2.v3 ? function() {
        return [h(Icon, {
          name: "droplet-slider",
          attrs: _this2.v3 ? void 0 : {
            name: "droplet-slider",
            icon: dropletSliderIcon
          },
          icon: dropletSliderIcon
        })];
      } : [h(Icon, {
        name: "droplet-slider",
        attrs: _this2.v3 ? void 0 : {
          name: "droplet-slider",
          icon: dropletSliderIcon
        },
        icon: dropletSliderIcon
      })]), h(Button, {
        tabIndex: _this2.computedTabIndex,
        attrs: _this2.v3 ? void 0 : {
          tabIndex: _this2.computedTabIndex,
          type: "button",
          togglable: true,
          fillMode: "flat",
          selected: !_this2.isColorGradient,
          ariaLabel: paletteMessage
        },
        type: "button",
        togglable: true,
        fillMode: "flat",
        selected: !_this2.isColorGradient,
        onKeydown: _this2.handleButtonKeydown,
        on: _this2.v3 ? void 0 : {
          "keydown": _this2.handleButtonKeydown,
          "click": function click(e) {
            return _this.handleViewChange(e, "palette");
          }
        },
        ariaLabel: paletteMessage,
        onClick: function click(e) {
          return _this.handleViewChange(e, "palette");
        }
      }, _this2.v3 ? function() {
        return [h(Icon, {
          name: "palette",
          attrs: _this2.v3 ? void 0 : {
            name: "palette",
            icon: paletteIcon
          },
          icon: paletteIcon
        })];
      } : [h(Icon, {
        name: "palette",
        attrs: _this2.v3 ? void 0 : {
          name: "palette",
          icon: paletteIcon
        },
        icon: paletteIcon
      })])])
    ]), h("div", {
      "class": "k-spacer"
    }), h("div", {
      "class": "k-coloreditor-header-actions k-hstack"
    }, [this.$props.showClearButton && // @ts-ignore  function children
    h(Button, {
      tabIndex: this.computedTabIndex,
      attrs: this.v3 ? void 0 : {
        tabIndex: this.computedTabIndex,
        type: "button",
        fillMode: "flat",
        ariaLabel: clearMessage
      },
      type: "button",
      fillMode: "flat",
      ariaLabel: clearMessage,
      onKeydown: this.handleButtonKeydown,
      on: this.v3 ? void 0 : {
        "keydown": this.handleButtonKeydown,
        "click": this.handleResetColor
      },
      onClick: this.handleResetColor
    }, this.v3 ? function() {
      return [h(Icon, {
        name: "droplet-slash",
        attrs: _this2.v3 ? void 0 : {
          name: "droplet-slash",
          icon: dropletSlashIcon
        },
        icon: dropletSlashIcon
      })];
    } : [h(Icon, {
      name: "droplet-slash",
      attrs: _this2.v3 ? void 0 : {
        name: "droplet-slash",
        icon: dropletSlashIcon
      },
      icon: dropletSlashIcon
    })]), this.$props.showPreview && h("div", {
      "class": "k-coloreditor-preview k-vstack"
    }, [h("span", {
      "class": this.previewClass,
      style: {
        background: this.colorValue
      }
    }, [!this.colorValue && h("span", {
      "class": "k-color-preview-mask"
    })]), h("span", {
      "class": this.currentClass,
      style: {
        background: this.computedPrevColor
      },
      onClick: this.handlePrevColorClick,
      on: this.v3 ? void 0 : {
        "click": this.handlePrevColorClick
      }
    }, [!this.computedPrevColor && h("span", {
      "class": "k-color-preview-mask"
    })])])])]), h("div", {
      "class": "k-coloreditor-views k-vstack"
    }, [this.isColorGradient ? renderGradiente.call(this) : renderPalette.call(this)]), this.$props.showButtons && h("div", {
      "class": "k-coloreditor-footer k-actions k-actions-end"
    }, [
      // @ts-ignore  function children
      h(Button, {
        tabIndex: this.computedTabIndex,
        attrs: this.v3 ? void 0 : {
          tabIndex: this.computedTabIndex,
          type: "button"
        },
        type: "button",
        "class": "k-coloreditor-cancel",
        onKeydown: this.handleButtonKeydown,
        on: this.v3 ? void 0 : {
          "keydown": this.handleButtonKeydown,
          "click": this.handleCancelBtnClick
        },
        onClick: this.handleCancelBtnClick
      }, this.v3 ? function() {
        return [cancelMessage];
      } : [cancelMessage]),
      // @ts-ignore  function children
      h(Button, {
        tabIndex: this.computedTabIndex,
        attrs: this.v3 ? void 0 : {
          tabIndex: this.computedTabIndex,
          type: "button"
        },
        type: "button",
        "class": "k-coloreditor-apply k-primary",
        onKeydown: this.handleButtonKeydown,
        on: this.v3 ? void 0 : {
          "keydown": this.handleButtonKeydown,
          "click": this.triggerChange
        },
        onClick: this.triggerChange
      }, this.v3 ? function() {
        return [applyMessage];
      } : [applyMessage])
    ]), footer]);
  },
  methods: {
    focus: function focus5() {
      var _this = this;
      this.focused = true;
      setTimeout(function() {
        focusFirstFocusableChild(_this.$el);
      }, 1);
    },
    onKeyDownHandler: function onKeyDownHandler2(e) {
      var element2 = this.$el;
      this.focused = focusContainer(e, element2);
      this.$emit("keydown", e);
    },
    handleViewChange: function handleViewChange(event, viewType) {
      this.currentView = viewType;
      this.$emit("viewchange", {
        event,
        viewType
      });
    },
    handleResetColor: function handleResetColor() {
      this.colorValue = null;
      if (!this.showButtons) {
        this.triggerChange();
      }
    },
    handleColorChange: function handleColorChange(event) {
      this.colorValue = event.value;
      if (!this.showButtons) {
        this.triggerChange(event);
      }
    },
    handlePaletteColorChange: function handlePaletteColorChange(event) {
      this.colorValue = event.value;
      if (!this.showButtons) {
        this.triggerChange(event);
      }
    },
    triggerChange: function triggerChange(event) {
      var rgbaValue = parseColor2(this.colorValue, "rgba");
      this.currentPrevColor = this.colorValue;
      this.$emit("changemodel", this.colorValue);
      this.$emit("update:modelValue", this.colorValue);
      this.$emit("update:modelRgbaValue", rgbaValue);
      this.$emit("change", {
        event,
        value: this.colorValue,
        rgbaValue
      });
    },
    innerKeyDown: function innerKeyDown(event) {
      if (event.keyCode === Keys.enter) {
        this.triggerChange(event);
      }
    },
    gradientKeyDown: function gradientKeyDown(event) {
      event.stopPropagation();
      if (!this.showButtons && event.keyCode === Keys.enter) {
        this.triggerChange(event);
      }
    },
    handleButtonKeydown: function handleButtonKeydown(e) {
      if (e.keyCode === Keys.enter) {
        e.stopPropagation();
      }
    },
    handleCancelBtnClick: function handleCancelBtnClick() {
      this.colorValue = this.computedPrevColor;
    },
    handlePrevColorClick: function handlePrevColorClick() {
      this.colorValue = this.computedPrevColor;
    },
    onFocus: function onFocus4(event) {
      this.$emit("focus", {
        event,
        target: this
      });
    },
    onBlur: function onBlur4(event) {
      this.$emit("blur", {
        event,
        target: this
      });
    },
    onFocusout: function onFocusout(event) {
      this.$emit("focusout", {
        event,
        target: this
      });
    }
  }
};
var FlatColorPicker = FlatColorPickerVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/colors/ColorPicker.js
var __assign4 = function() {
  __assign4 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
var allVue28 = vue_runtime_esm_bundler_exports;
var gh28 = allVue28.h;
var isV328 = allVue28.version && allVue28.version[0] === "3";
var ColorPickerVue2 = {
  name: "KendoColorPicker",
  model: {
    event: "changemodel"
  },
  // @ts-ignore
  emits: {
    "open": null,
    "close": null,
    "changemodel": null,
    "update:modelValue": null,
    "update:modelRgbaValue": null,
    "activecolorclick": null,
    "focus": null,
    "blur": null,
    "change": null,
    "viewchange": null
  },
  props: {
    modelValue: String,
    modelRgbaValue: String,
    value: {
      type: String,
      default: void 0
    },
    defaultValue: String,
    disabled: Boolean,
    dir: String,
    id: String,
    ariaLabelledBy: String,
    ariaDescribedBy: String,
    showClearButton: {
      type: Boolean,
      default: true
    },
    showPreview: {
      type: Boolean,
      default: true
    },
    showButtons: {
      type: Boolean,
      default: true
    },
    paletteSettings: {
      type: Object,
      default: function _default8() {
        return DEFAULT_PALETTE_SETTINGS;
      }
    },
    valid: {
      type: Boolean,
      default: true
    },
    tabIndex: {
      type: Number,
      default: 0
    },
    title: String,
    icon: String,
    svgIcon: Object,
    iconClassName: String,
    popupSettings: {
      type: Object,
      default: function _default9() {
        return {};
      }
    },
    gradientSettings: {
      type: Object,
      default: function _default10() {
        return DEFAULT_GRADIENT_SETTINGS;
      }
    },
    flatColorPickerSettings: {
      type: Object,
      default: function _default11() {
        return {};
      }
    },
    open: {
      type: Boolean,
      default: void 0
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator5(value2) {
        return [null, "small", "medium", "large"].includes(value2);
      }
    },
    rounded: {
      type: String,
      default: "medium",
      validator: function validator6(value2) {
        return [null, "small", "medium", "large", "full"].includes(value2);
      }
    },
    fillMode: {
      type: String,
      default: "solid",
      validator: function validator7(value2) {
        return [null, "solid", "flat", "outline"].includes(value2);
      }
    },
    view: {
      type: String,
      default: "combo",
      validator: function validator8(value2) {
        return ["gradient", "palette", "combo"].includes(value2);
      }
    },
    selectedView: {
      type: Number,
      default: void 0
    }
  },
  inject: {
    kendoLocalizationService: {
      default: null
    }
  },
  data: function data9() {
    return {
      focused: false,
      currentValue: this.$props.defaultValue,
      currentOpen: false
    };
  },
  computed: {
    isValueControlled: function isValueControlled() {
      return this.$props.value !== void 0;
    },
    isOpenControlled: function isOpenControlled() {
      return this.$props.open !== void 0;
    },
    computedValue: function computedValue2() {
      return this.isValueControlled ? this.$props.value : this.$props.modelValue !== void 0 ? this.$props.modelValue : this.$props.modelRgbaValue !== void 0 ? this.$props.modelRgbaValue : this.currentValue !== void 0 ? this.currentValue : this.defaultValue;
    },
    computedOpen: function computedOpen() {
      return this.isOpenControlled ? this.$props.open : this.currentOpen;
    },
    wrapperClassName: function wrapperClassName() {
      var _a5;
      var _b = this.$props, size2 = _b.size, fillMode = _b.fillMode, rounded = _b.rounded;
      return _a5 = {
        "k-picker": true,
        "k-colorpicker": true,
        "k-icon-picker": true
      }, _a5["k-picker-".concat(kendoThemeMaps.sizeMap[size2] || size2)] = size2, _a5["k-picker-".concat(fillMode)] = fillMode, _a5["k-rounded-".concat(kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded, _a5["k-invalid"] = !this.valid, _a5["k-disabled"] = this.disabled, _a5["k-focus"] = this.focused, _a5;
    }
  },
  created: function created10() {
    validatePackage(packageMetadata);
    this._popupId = "popup" + guid();
    this.focusableElementGuid = guid();
  },
  mounted: function mounted6() {
    this.button = getRef(this, "button");
  },
  updated: function updated6() {
  },
  // @ts-ignore
  setup: !isV328 ? void 0 : function() {
    var v3 = !!isV328;
    return {
      v3
    };
  },
  // @ts-ignore
  render: function render15(createElement) {
    var _this2 = this;
    var _this = this;
    var localizationService = provideLocalizationService(this);
    var colorPickerLabelMessage = localizationService.toLanguageString(colorPickerDropdownButtonAriaLabel, messages2[colorPickerDropdownButtonAriaLabel]);
    var h = gh28 || createElement;
    var _a5 = this.$props, disabled = _a5.disabled, tabIndex = _a5.tabIndex, dir = _a5.dir, view = _a5.view, selectedView = _a5.selectedView, showClearButton = _a5.showClearButton, showPreview = _a5.showPreview, showButtons = _a5.showButtons, popupSettings = _a5.popupSettings;
    var renderFlatColorPicker = function renderFlatColorPicker2() {
      return h(FlatColorPicker, __assign4({
        onKeydown: this.onKeyDownHandler,
        on: this.v3 ? void 0 : {
          "keydown": this.onKeyDownHandler,
          "change": this.onFlatChangeHandler,
          "focusout": this.onBlurHandler,
          "viewchange": this.onViewChange
        },
        ref: setRef(this, "flatcolorpicker"),
        view,
        selectedView,
        showClearButton,
        showPreview,
        showButtons,
        value: this.computedValue || void 0,
        attrs: this.v3 ? void 0 : __assign4({
          view,
          selectedView,
          showClearButton,
          showPreview,
          showButtons,
          value: this.computedValue || void 0,
          paletteSettings: this.paletteSettings,
          gradientSettings: this.gradientSettings
        }, this.flatColorPickerSettings),
        onChange: this.onFlatChangeHandler,
        onFocusout: this.onBlurHandler,
        onViewchange: this.onViewChange,
        paletteSettings: this.paletteSettings,
        gradientSettings: this.gradientSettings
      }, this.flatColorPickerSettings));
    };
    return h("span", {
      "class": this.wrapperClassName,
      role: "combobox",
      attrs: this.v3 ? void 0 : {
        role: "combobox",
        dir,
        id: this.$props.id,
        "aria-labelledby": this.$props.ariaLabelledBy,
        "aria-describedby": this.$props.ariaDescribedBy,
        "aria-disabled": this.$props.disabled,
        "aria-haspopup": "dialog",
        "aria-expanded": this.computedOpen,
        tabindex: getTabIndex(tabIndex, disabled),
        title: this.$props.title
      },
      dir,
      id: this.$props.id,
      "aria-labelledby": this.$props.ariaLabelledBy,
      "aria-describedby": this.$props.ariaDescribedBy,
      "aria-disabled": this.$props.disabled,
      "aria-haspopup": "dialog",
      "aria-expanded": this.computedOpen,
      ref: this.focusableElementGuid,
      tabindex: getTabIndex(tabIndex, disabled),
      title: this.$props.title,
      onKeydown: this.onButtonKeyDown,
      on: this.v3 ? void 0 : {
        "keydown": this.onButtonKeyDown,
        "focusin": this.onFocusHandler,
        "focusout": this.onButtonBlur
      },
      onFocusin: this.onFocusHandler,
      onFocusout: this.onButtonBlur
    }, [
      h("span", {
        onClick: this.onActiveColorClickHandler,
        on: this.v3 ? void 0 : {
          "click": this.onActiveColorClickHandler
        },
        "class": "k-input-inner"
      }, [h("span", {
        "class": classNames("k-value-icon", "k-color-preview", {
          "k-no-color": !this.computedValue,
          "k-icon-color-preview": this.icon || this.iconClassName
        })
      }, [(this.iconClassName || this.icon || this.svgIcon) && h(Icon, {
        "class": classNames("k-color-preview-icon", this.iconClassName),
        name: getIconName(this.icon),
        attrs: this.v3 ? void 0 : {
          name: getIconName(this.icon),
          icon: this.svgIcon
        },
        icon: this.svgIcon
      }), h("span", {
        "class": "k-color-preview-mask",
        style: {
          backgroundColor: this.computedValue
        }
      })])]),
      // @ts-ignore
      h(Button, {
        type: "button",
        attrs: this.v3 ? void 0 : {
          type: "button",
          tabindex: -1,
          rounded: null,
          icon: "caret-alt-down",
          svgIcon: caretAltDownIcon,
          "aria-label": colorPickerLabelMessage
        },
        tabindex: -1,
        ref: this.v3 ? function(el) {
          _this.buttonRef = el;
        } : "button",
        onClick: this.onClickHandler,
        on: this.v3 ? void 0 : {
          "click": this.onClickHandler
        },
        rounded: null,
        "class": "k-input-button",
        icon: "caret-alt-down",
        svgIcon: caretAltDownIcon,
        "aria-label": colorPickerLabelMessage
      }),
      // @ts-ignore function children
      h(Picker, {
        dir,
        attrs: this.v3 ? void 0 : {
          dir,
          id: this._popupId,
          open: this.computedOpen,
          popupAnchor: this.focusableElementGuid,
          popupSettings: __assign4({}, popupSettings)
        },
        id: this._popupId,
        open: this.computedOpen,
        onOpen: this.onOpenHandler,
        on: this.v3 ? void 0 : {
          "open": this.onOpenHandler
        },
        popupAnchor: this.focusableElementGuid,
        popupSettings: __assign4({}, popupSettings)
      }, this.v3 ? function() {
        return [renderFlatColorPicker.call(_this2)];
      } : [renderFlatColorPicker.call(_this2)])
    ]);
  },
  methods: {
    focusElement: function focusElement() {
      if (this.$el) {
        this.$el.focus();
      }
    },
    setOpen: function setOpen(nextOpen, isBlur) {
      if (!nextOpen && !isBlur && this.$el) {
        this.$el.focus();
      }
      this.currentOpen = nextOpen;
      this.$emit(nextOpen ? "open" : "close");
    },
    onButtonKeyDown: function onButtonKeyDown(event) {
      var altKey = event.altKey, keyCode = event.keyCode;
      if (keyCode === Keys.esc) {
        event.preventDefault();
        event.stopPropagation();
        this.setOpen(false);
        return;
      }
      if (keyCode === Keys.enter) {
        event.preventDefault();
        event.stopPropagation();
        this.setOpen(!this.computedOpen);
        return;
      }
      if (altKey && keyCode === Keys.down) {
        event.preventDefault();
        event.stopPropagation();
        this.setOpen(true);
      }
    },
    onKeyDownHandler: function onKeyDownHandler3(event) {
      var altKey = event.altKey, keyCode = event.keyCode;
      if (keyCode === Keys.esc) {
        event.preventDefault();
        event.stopPropagation();
        this.setOpen(false);
        return;
      }
      if (keyCode === Keys.enter) {
        event.preventDefault();
        event.stopPropagation();
        this.focusElement();
        return;
      }
      if (altKey && keyCode === Keys.up) {
        event.preventDefault();
        event.stopPropagation();
        this.setOpen(false);
        this.focusElement();
      }
    },
    onOpenHandler: function onOpenHandler() {
      var flatcolorpicker = getRef(this, "flatcolorpicker");
      if (flatcolorpicker) {
        flatcolorpicker.focus();
      }
    },
    onClickHandler: function onClickHandler() {
      this.setOpen(!this.computedOpen, true);
    },
    onActiveColorClickHandler: function onActiveColorClickHandler(event) {
      this.$emit("activecolorclick", {
        event,
        value: this.computedValue
      });
    },
    isViewFocused: function isViewFocused() {
      return !!(document.activeElement && document.activeElement.closest("#".concat(this._popupId)));
    },
    onButtonBlur: function onButtonBlur(event) {
      this.focused = this.isViewFocused();
      this.$emit("blur", {
        event
      });
    },
    onFocusHandler: function onFocusHandler(event) {
      if (this.blurTimeoutRef) {
        clearTimeout(this.blurTimeoutRef);
        this.blurTimeoutRef = void 0;
        if (event.target === this.$el) {
          this.setOpen(false);
        }
      } else {
        this.focused = true;
      }
      this.$emit("focus", {
        event
      });
    },
    onBlurTimeout: function onBlurTimeout() {
      var viewIsFocused = this.isViewFocused();
      if (!viewIsFocused) {
        this.setOpen(false, true);
      }
      this.focused = viewIsFocused;
      this.blurTimeoutRef = void 0;
    },
    onBlurHandler: function onBlurHandler() {
      clearTimeout(this.blurTimeoutRef);
      this.palette = getRef(this, "palette");
      this.gradient = getRef(this, "gradient");
      this.blurTimeoutRef = setTimeout(this.onBlurTimeout, 200);
    },
    onViewChange: function onViewChange(event) {
      this.$emit("viewchange", event);
    },
    onChangeHandler: function onChangeHandler(event, isPalette) {
      var currentValue = event.value;
      if (!this.isValueControlled) {
        this.currentValue = currentValue;
      }
      if (isPalette) {
        this.setOpen(false);
      }
      this.$emit("changemodel", currentValue);
      this.$emit("update:modelRgbaValue", event.rgbaValue);
      this.$emit("update:modelValue", currentValue);
      this.$emit("change", {
        value: currentValue,
        rgbaValue: event.rgbaValue,
        event
      });
    },
    onFlatChangeHandler: function onFlatChangeHandler(event) {
      this.onChangeHandler(event, true);
    }
  }
};
var ColorPicker = ColorPickerVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/switch/Switch.js
var allVue29 = vue_runtime_esm_bundler_exports;
var gh29 = allVue29.h;
var isV329 = allVue29.version && allVue29.version[0] === "3";
var SwitchVue2 = {
  name: "KendoSwitch",
  model: {
    event: "changemodel"
  },
  // @ts-ignore
  emits: {
    "change": null,
    "changemodel": null,
    "update:modelValue": null,
    "focus": null,
    "blur": null
  },
  props: {
    name: String,
    accessKey: String,
    checked: {
      type: Boolean,
      default: void 0
    },
    className: String,
    disabled: {
      type: Boolean,
      default: false
    },
    defaultChecked: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator9(value2) {
        return [null, "small", "medium", "large"].includes(value2);
      }
    },
    trackRounded: {
      type: String,
      default: "full",
      validator: function validator10(value2) {
        return [null, "small", "medium", "large", "full"].includes(value2);
      }
    },
    thumbRounded: {
      type: String,
      default: "full",
      validator: function validator11(value2) {
        return [null, "small", "medium", "large", "full"].includes(value2);
      }
    },
    dir: String,
    id: String,
    ariaLabelledBy: String,
    ariaDescribedBy: String,
    offLabel: {
      type: String,
      default: "OFF"
    },
    onLabel: {
      type: String,
      default: "ON"
    },
    required: {
      type: Boolean,
      default: false
    },
    tabIndex: Number,
    valid: Boolean,
    validityStyles: {
      type: Boolean,
      default: false
    },
    validationMessage: String,
    value: {
      type: [String, Number, Boolean],
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    }
  },
  created: function created11() {
    validatePackage(packageMetadata);
    this._id = guid();
    this.defaultValidationMessage = provideLocalizationService(this);
  },
  data: function data10() {
    return {
      currentChecked: this.$props.defaultChecked,
      valueDuringOnChange: void 0,
      focused: false,
      currentDir: void 0
    };
  },
  computed: {
    computedValue: function computedValue3() {
      return this.valueDuringOnChange !== void 0 ? this.valueDuringOnChange : this.$props.checked !== void 0 ? this.$props.checked : this.$props.value !== void 0 ? this.$props.value : this.$props.modelValue !== void 0 ? this.$props.modelValue : this.currentChecked;
    },
    switchClassName: function switchClassName() {
      var _a5;
      var isValid3 = !this.validityStyles || this.validity().valid;
      var rounded = this.$props.trackRounded;
      return _a5 = {
        "k-switch": true
      }, _a5["k-switch-".concat(kendoThemeMaps.sizeMap[this.$props.size])] = this.$props.size, _a5["k-rounded-".concat(kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded, _a5["k-switch-on"] = this.computedValue, _a5["k-switch-off"] = !this.computedValue, _a5["k-focus"] = this.focused, _a5["k-disabled"] = this.$props.disabled, _a5["k-invalid"] = !isValid3, _a5;
    },
    switchTrackClass: function switchTrackClass() {
      var _a5;
      var rounded = this.$props.trackRounded;
      return _a5 = {
        "k-switch-track": true
      }, _a5["k-rounded-".concat(kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded, _a5;
    },
    switchThumbClass: function switchThumbClass() {
      var _a5;
      var rounded = this.$props.thumbRounded;
      return _a5 = {
        "k-switch-thumb": true
      }, _a5["k-rounded-".concat(kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded, _a5;
    }
  },
  mounted: function mounted7() {
    this._element = getRef(this, "element");
    this.input = getRef(this, "input");
    this.currentDir = this.$props.dir !== void 0 ? this.$props.dir : isRtl(this.$el) ? "rtl" : "ltr";
    this.setValidity();
  },
  updated: function updated7() {
    this.setValidity();
  },
  // @ts-ignore
  setup: !isV329 ? void 0 : function() {
    var v3 = !!isV329;
    return {
      v3
    };
  },
  // @ts-ignore
  render: function render16(createElement) {
    var h = gh29 || createElement;
    var _a5 = this.$props, disabled = _a5.disabled, id = _a5.id, offLabel = _a5.offLabel, onLabel = _a5.onLabel, tabIndex = _a5.tabIndex, required = _a5.required;
    return h("span", {
      "class": this.switchClassName,
      role: "switch",
      attrs: this.v3 ? void 0 : {
        role: "switch",
        "aria-labelledby": this.$props.ariaLabelledBy,
        "aria-describedby": this.$props.ariaDescribedBy,
        "aria-checked": this.computedValue,
        "aria-disabled": disabled || void 0,
        dir: this.currentDir,
        tabindex: getTabIndex(tabIndex, disabled, void 0),
        accesskey: this.$props.accessKey
      },
      "aria-labelledby": this.$props.ariaLabelledBy,
      "aria-describedby": this.$props.ariaDescribedBy,
      "aria-checked": this.computedValue,
      "aria-disabled": disabled || void 0,
      dir: this.currentDir,
      onKeydown: this.handleKeyDown,
      on: this.v3 ? void 0 : {
        "keydown": this.handleKeyDown,
        "click": this.handleClick,
        "focusout": this.handleWrapperBlur,
        "focusin": this.handleWrapperFocus
      },
      onClick: this.handleClick,
      onFocusout: this.handleWrapperBlur,
      onFocusin: this.handleWrapperFocus,
      tabindex: getTabIndex(tabIndex, disabled, void 0),
      accesskey: this.$props.accessKey
    }, [h("span", {
      "class": this.switchTrackClass,
      ref: setRef(this, "element")
    }, [h("input", {
      type: "checkbox",
      attrs: this.v3 ? void 0 : {
        type: "checkbox",
        id: id || this._id,
        tabindex: -1,
        name: this.$props.name,
        required: required !== void 0 ? required : false,
        "aria-hidden": true
      },
      id: id || this._id,
      checked: this.v3 ? this.$props.checked : null,
      domProps: this.v3 ? void 0 : {
        "checked": this.$props.checked,
        "value": this.computedValue
      },
      ref: setRef(this, "input"),
      tabindex: -1,
      name: this.$props.name,
      required: required !== void 0 ? required : false,
      "aria-hidden": true,
      value: this.v3 ? this.computedValue : null,
      style: {
        opacity: 0,
        width: 1,
        border: 0,
        zIndex: -1,
        position: "absolute",
        left: "50%"
      },
      onChange: noop,
      on: this.v3 ? void 0 : {
        "change": noop
      }
    }), h("span", {
      "class": "k-switch-label-on"
    }, [onLabel]), h("span", {
      "class": "k-switch-label-off"
    }, [offLabel])]), h("span", {
      "class": "k-switch-thumb-wrap"
    }, [h("span", {
      "class": this.switchThumbClass
    })])]);
  },
  methods: {
    focus: function focus6() {
      if (this._element) {
        this._element.focus();
      }
    },
    element: function element() {
      return this._element;
    },
    validity: function validity2() {
      var customError = this.$props.validationMessage !== void 0;
      var isValid3 = this.$props.valid !== void 0 ? this.$props.valid : !this.$props.required ? true : this.computedValue ? true : false;
      var valid = this.$props.valid !== void 0 ? this.$props.valid : isValid3;
      return {
        customError,
        valid,
        valueMissing: this.computedValue === null
      };
    },
    setValidity: function setValidity2() {
      if (this.input && this.input.setCustomValidity) {
        this.input.setCustomValidity(this.validity().valid ? "" : this.$props.validationMessage || this.defaultValidationMessage.toLanguageString(switchValidation, messages2[switchValidation]));
      }
    },
    limit: function limit(offset, drag2, wrapper) {
      var wrapperWidth = wrapper.offsetWidth;
      var margin = drag2.offsetWidth;
      if (offset < 0) {
        return 0;
      } else if (offset > wrapperWidth - margin) {
        return wrapperWidth - margin;
      }
      return offset;
    },
    toggle: function toggle(value2, event) {
      this.currentChecked = value2;
      this.valueDuringOnChange = value2;
      this.$emit("changemodel", value2);
      this.$emit("update:modelValue", value2);
      this.$emit("change", {
        event,
        component: this,
        target: {
          value: value2
        },
        name: this.$props.name,
        value: value2,
        validity: this.validity()
      });
      this.valueDuringOnChange = void 0;
    },
    handleClick: function handleClick2(event) {
      if (this.eventTimeStamp === event.timeStamp) {
        return;
      }
      this.eventTimeStamp = event.timeStamp;
      this.toggle(!this.computedValue, event);
    },
    handleKeyDown: function handleKeyDown(event) {
      if (this.$props.disabled) {
        return;
      }
      var keyCode = event.keyCode;
      if (keyCode === Keys.space || keyCode === Keys.enter) {
        this.toggle(!this.computedValue, event);
      }
    },
    handleWrapperFocus: function handleWrapperFocus(event) {
      if (this.$props.disabled) {
        return;
      }
      this.focused = true;
      this.$emit("focus", event);
    },
    handleWrapperBlur: function handleWrapperBlur(event) {
      if (this.$props.disabled) {
        return;
      }
      this.focused = false;
      this.$emit("blur", event);
    }
  }
};
var Switch = SwitchVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/input-separator/InputSeparator.js
var allVue30 = vue_runtime_esm_bundler_exports;
var gh30 = allVue30.h;
var isV330 = allVue30.version && allVue30.version[0] === "3";
var InputSeparatorVue2 = {
  created: function created12() {
    validatePackage(packageMetadata);
  },
  // @ts-ignore
  setup: !isV330 ? void 0 : function() {
    var v3 = !!isV330;
    return {
      v3
    };
  },
  render: function render17(createElement) {
    var h = gh30 || createElement;
    return h("span", {
      "class": "k-input-separator"
    });
  }
};
var InputSeparator = InputSeparatorVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/input/Input.js
var __assign5 = function() {
  __assign5 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return __assign5.apply(this, arguments);
};
var allVue31 = vue_runtime_esm_bundler_exports;
var gh31 = allVue31.h;
var isV331 = allVue31.version && allVue31.version[0] === "3";
var ref8 = allVue31.ref;
var InputVue2 = {
  model: {
    event: "changemodel"
  },
  // @ts-ignore
  emits: {
    "input": null,
    "change": null,
    "changemodel": null,
    "update:modelValue": null,
    "focus": null,
    "blur": null,
    "keyup": null,
    "keydown": null,
    "keypress": null
  },
  props: {
    modelValue: {
      type: [String, Number],
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    defaultValue: {
      type: [String, Number],
      default: ""
    },
    value: {
      type: [String, Number]
    },
    label: {
      type: String
    },
    placeholder: {
      type: String
    },
    required: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator12(value2) {
        return [null, "small", "medium", "large"].includes(value2);
      }
    },
    rounded: {
      type: String,
      default: "medium",
      validator: function validator13(value2) {
        return [null, "small", "medium", "large", "full"].includes(value2);
      }
    },
    fillMode: {
      type: String,
      default: "solid",
      validator: function validator14(value2) {
        return [null, "solid", "flat", "outline"].includes(value2);
      }
    },
    dir: {
      type: String
    },
    id: String,
    valid: {
      type: Boolean,
      default: void 0
    },
    validate: {
      type: Boolean
    },
    validationMessage: {
      type: String
    },
    validityStyles: {
      type: Boolean,
      default: true
    },
    inputClass: String,
    tabIndex: Number,
    ariaLabel: String,
    ariaLabelledBy: String,
    ariaDescribedBy: String
  },
  data: function data11() {
    return {
      hasMounted: false,
      autofill: false,
      currentValue: "",
      valueDuringOnChange: "",
      focused: false
    };
  },
  created: function created13() {
    validatePackage(packageMetadata);
    this._input = void 0;
    this._inputId = guid();
    this.$data.valueDuringOnChange = void 0;
    this.$data.currentValue = this.$props.defaultValue;
  },
  mounted: function mounted8() {
    this._input = this.v3 ? this.inputRef : this.$refs.input;
    this.$data.hasMounted = true;
    this.setValidity();
  },
  updated: function updated8() {
    this.setValidity();
    this.updateValidClass();
  },
  // @ts-ignore
  setup: !isV331 ? void 0 : function() {
    var v3 = !!isV331;
    var inputRef = ref8(null);
    return {
      v3,
      inputRef
    };
  },
  render: function render18(createElement) {
    var _this = this;
    var h = gh31 || createElement;
    var isValid3 = !this.$props.validityStyles || this.validity().valid;
    var _a5 = this.$props, label = _a5.label, id = _a5.id, required = _a5.required, tabIndex = _a5.tabIndex, ariaLabel = _a5.ariaLabel, ariaLabelledBy = _a5.ariaLabelledBy, ariaDescribedBy = _a5.ariaDescribedBy;
    var inputId = id || this._inputId;
    var textbox = h("input", __assign5(__assign5({
      domProps: this.v3 ? null : __assign5(__assign5({}, this.$attrs), {
        placeholder: this.$props.placeholder,
        id: inputId,
        required,
        disabled: this.$props.disabled,
        value: this.computedValue
      }),
      attrs: this.v3 ? void 0 : __assign5(__assign5({}, this.$attrs), {
        tabindex: tabIndex
      })
    }, this.$attrs), {
      placeholder: this.$props.placeholder,
      id: inputId,
      tabindex: tabIndex,
      required,
      ariaLabel,
      ariaLabelledby: ariaLabelledBy,
      ariaDescribedby: ariaDescribedBy,
      ariaDisabled: this.$props.disabled,
      disabled: this.$props.disabled,
      value: this.computedValue,
      class: this.inputInnerClass,
      ref: this.v3 ? function(el) {
        _this.inputRef = el;
      } : "input",
      on: this.v3 ? null : {
        change: this.handleChange,
        focus: this.emitFocus,
        blur: this.emitBlur,
        keydown: this.handleKeydown,
        keyup: this.handleKeyup,
        keypress: this.handleKeypress,
        input: this.handleInput,
        animationstart: this.handleAutoFill,
        animationend: this.handleAutoFillEnd
      },
      onKeydown: this.handleKeydown,
      onKeyup: this.handleKeyup,
      onKeypress: this.handleKeypress,
      onChange: this.handleChange,
      onFocus: this.emitFocus,
      onBlur: this.emitBlur,
      onInput: this.handleInput,
      onAnimationstart: this.handleAutoFill,
      onAnimationend: this.handleAutoFillEnd
    }));
    return label ? (
      // @ts-ignore function children
      h(FloatingLabel, {
        label,
        attrs: this.v3 ? void 0 : {
          label,
          editorId: inputId,
          editorValue: this.computedValue,
          editorValid: isValid3,
          editorDisabled: this.$props.disabled,
          editorPlaceholder: this.$data.focused ? this.$props.placeholder : "",
          dir: this.$props.dir
        },
        editorId: inputId,
        editorValue: this.computedValue,
        editorValid: isValid3,
        editorDisabled: this.$props.disabled,
        editorPlaceholder: this.$data.focused ? this.$props.placeholder : "",
        dir: this.$props.dir
      }, this.v3 ? function() {
        return [textbox];
      } : [textbox])
    ) : textbox;
  },
  methods: {
    updateValidClass: function updateValidClass2() {
      this._input.classList.toggle("k-invalid", !this.validity().valid);
    },
    emitFocus: function emitFocus2(e) {
      this.$emit("focus", e);
      this.$data.focused = true;
    },
    emitBlur: function emitBlur2(e) {
      this.$emit("blur", e);
      this.$data.focused = false;
    },
    handleKeydown: function handleKeydown3(e) {
      this.$emit("keydown", e);
    },
    handleKeyup: function handleKeyup2(e) {
      this.$emit("keyup", e);
    },
    handleKeypress: function handleKeypress3(e) {
      this.$emit("keypress", e);
    },
    clearClick: function clearClick2(event) {
      this.emitUpdate(event, "change", "");
    },
    focus: function focus7() {
      if (this._input) {
        this._input.focus();
      }
    },
    validity: function validity3() {
      var result = {
        badInput: this._input ? this._input.validity.badInput : false,
        patternMismatch: this._input ? this._input.validity.patternMismatch : false,
        rangeOverflow: this._input ? this._input.validity.rangeOverflow : false,
        rangeUnderflow: this._input ? this._input.validity.rangeUnderflow : false,
        stepMismatch: this._input ? this._input.validity.stepMismatch : false,
        tooLong: this._input ? this._input.validity.tooLong : false,
        tooShort: this._input ? this._input.validity.tooShort : false,
        typeMismatch: this._input ? this._input.validity.typeMismatch : false,
        valueMissing: this._input ? this._input.validity.valueMissing : false
      };
      return __assign5(__assign5({}, result), {
        customError: this.$props.validationMessage !== void 0,
        valid: this.$props.valid !== void 0 ? this.$props.valid : this._input ? !this.isInvalid(result) : true
      });
    },
    isInvalid: function isInvalid2(state) {
      var result = false;
      for (var prop in state) {
        if (state.hasOwnProperty(prop)) {
          result = result || state[prop];
        }
      }
      return result;
    },
    setValidity: function setValidity3() {
      if (this._input && this._input.setCustomValidity) {
        this._input.setCustomValidity(this.validity().valid ? "" : this.$props.validationMessage || "");
      }
    },
    handleInput: function handleInput2(event) {
      this.emitUpdate(event, "input", event.target.value);
    },
    handleChange: function handleChange2(event) {
      this.emitUpdate(event, "change", event.target.value);
    },
    emitUpdate: function emitUpdate2(event, eventName, value2) {
      var that = this;
      if (this.disabled) {
        return;
      }
      this.$data.currentValue = value2;
      this.$data.valueDuringOnChange = value2;
      this.$nextTick(function() {
        that.$emit("changemodel", value2);
        that.$emit("update:modelValue", value2);
        that.$emit(eventName, {
          event,
          value: value2,
          component: that,
          target: event.target,
          validity: that.validity()
        });
        that.$data.valueDuringOnChange = void 0;
      });
    },
    handleAutoFill: function handleAutoFill2(e) {
      if (e.animationName === "autoFillStart") {
        var parent_1 = e.target.parentNode;
        if (parent_1 && parent_1.classList.contains("k-empty")) {
          this.$data.autofill = true;
          parent_1.classList.remove("k-empty");
        }
      }
    },
    handleAutoFillEnd: function handleAutoFillEnd2(e) {
      if (e.animationName === "autoFillEnd") {
        var parent_2 = e.target.parentNode;
        if (parent_2) {
          this.$data.autofill = false;
        }
      }
    },
    name: function name2() {
      return this.$props.name;
    }
  },
  computed: {
    spanClassNames: {
      get: function get3() {
        var isValid3 = !this.$data.hasMounted || !this.$props.validityStyles || this.validity().valid;
        return {
          "k-floating-label-container": true,
          "k-focus": this.$data.focused,
          "k-empty": !((this.computedValue === 0 ? true : this.computedValue) || this.$props.placeholder || this.$data.autofill),
          "k-autofill": this.$data.autofill,
          "k-invalid": !isValid3 && isValid3 !== void 0,
          "k-rtl": this.$props.dir === "rtl"
        };
      }
    },
    inputInnerClass: function inputInnerClass2() {
      var _a5;
      var _b = this.$props, size2 = _b.size, fillMode = _b.fillMode, rounded = _b.rounded;
      var isValid3 = !this.$data.hasMounted || !this.$props.validityStyles || this.validity().valid;
      return _a5 = {
        "k-input": true
      }, _a5["k-input-".concat(kendoThemeMaps.sizeMap[size2] || size2)] = size2, _a5["k-input-".concat(fillMode)] = fillMode, _a5["k-rounded-".concat(kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded, _a5["k-invalid"] = !isValid3, _a5["k-required"] = this.required, _a5["k-disabled"] = this.$props.disabled, _a5[this.inputClass] = this.inputClass, _a5;
    },
    computedValue: {
      get: function get4() {
        return this.$data.valueDuringOnChange !== void 0 ? this.$data.valueDuringOnChange : this.$props.value !== void 0 ? this.$props.value : this.$props.modelValue !== void 0 ? this.$props.modelValue : this.$data.currentValue;
      }
    }
  }
};
var Input = InputVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/numerictextbox/utils/main.js
var __assign6 = function() {
  __assign6 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return __assign6.apply(this, arguments);
};
var DEFAULT_NUMBER = 11111111111111e-7;
var MAX_DECIMAL = 0.31111111111111117;
var MIN_DECIMAL = 1;
var ONE_NUMBER = 1;
var ZERO_NUMBER = 0;
var DIGITS_REGEX = /\d/;
var MAX_PRECISION = 15;
var getStateOrPropsValue = function getStateOrPropsValue2(value2, stateValue) {
  return value2 !== void 0 ? value2 : stateValue;
};
var formatValue = function formatValue2(value2, format, intlService) {
  if (value2 === null && value2 === void 0) {
    return "";
  }
  if (typeof value2 === "string") {
    return value2;
  }
  return intlService.formatNumber(value2, format);
};
var fractionLength = function fractionLength2(value2) {
  return (String(value2).split(".")[1] || "").length;
};
var maxFractionLength = function maxFractionLength2(value1, value2) {
  return Math.max(fractionLength(value1), fractionLength(value2));
};
var limitPrecision = function limitPrecision2(precision) {
  return Math.min(precision, MAX_PRECISION);
};
var toFixedPrecision = function toFixedPrecision2(value2, precision) {
  var maxPrecision = limitPrecision(precision);
  return parseFloat(value2.toFixed(maxPrecision));
};
var increaseValue = function increaseValue2(value2, newState, step, min, max, format, intlService) {
  var maxPrecision = maxFractionLength(value2 || 0, step || 0);
  var increasedValue = rangeValue(toFixedPrecision((value2 || 0) + (step || 0), maxPrecision), min, max);
  newState.eventValue = increasedValue;
  newState.currentLooseValue = formatValue(increasedValue, format, intlService);
  newState.selectionStart = newState.selectionEnd = getLastNumberIndex(newState.currentLooseValue, DIGITS_REGEX);
};
var decreaseValue = function decreaseValue2(value2, newState, step, min, max, format, intlService) {
  var maxPrecision = maxFractionLength(value2 || 0, step || 0);
  var decreasedValue = rangeValue(toFixedPrecision((value2 || 0) - (step || 0), maxPrecision), min, max);
  newState.eventValue = decreasedValue;
  newState.currentLooseValue = formatValue(decreasedValue, format, intlService);
  newState.selectionStart = newState.selectionEnd = getLastNumberIndex(newState.currentLooseValue, DIGITS_REGEX);
};
var rangeValue = function rangeValue2(value2, min, max) {
  if (value2 == null) {
    return value2;
  }
  if (!(value2 > 1 || value2 < 1 || value2 === 1)) {
    return null;
  }
  if (max !== void 0 && min !== void 0 && max < min) {
    return null;
  }
  if (max !== void 0 && value2 > max) {
    value2 = max;
  }
  if (min !== void 0 && value2 < min) {
    value2 = min;
  }
  return value2;
};
var getMaxCursorPosition = function getMaxCursorPosition2(nextValue, formatInfo) {
  var formatSuffixIndex = formatInfo.findIndex(function(_a5) {
    var _ = _a5[0], currSuffix = _a5[1];
    return Boolean(currSuffix) && nextValue.indexOf(currSuffix) === nextValue.length - currSuffix.length;
  });
  if (formatSuffixIndex === -1) {
    return -1;
  }
  var suffix = formatInfo[formatSuffixIndex][1];
  return nextValue.length - suffix.length;
};
var getMinCursorPosition = function getMinCursorPosition2(nextValue, formatInfo) {
  var formatPrefixIndex = formatInfo.findIndex(function(_a5) {
    var currPrefix = _a5[0], _ = _a5[1];
    return Boolean(currPrefix) && nextValue.indexOf(currPrefix) === 0;
  });
  if (formatPrefixIndex === -1) {
    return -1;
  }
  var prefix = formatInfo[formatPrefixIndex][0];
  return prefix.length;
};
var rangeSelection = function rangeSelection2(nextLooseValue, formatInfo, newState) {
  var maxPosition = getMaxCursorPosition(nextLooseValue, formatInfo);
  if (maxPosition !== -1 && newState.selectionStart > maxPosition) {
    newState.selectionStart = newState.selectionEnd = maxPosition;
    return;
  }
  if (newState.selectionStart > nextLooseValue.length) {
    newState.selectionStart = newState.selectionEnd = nextLooseValue.length;
  }
  var minPosition = getMinCursorPosition(nextLooseValue, formatInfo);
  if (minPosition !== -1 && newState.selectionStart < minPosition) {
    newState.selectionStart = newState.selectionEnd = minPosition;
  }
  if (newState.selectionStart === -1) {
    newState.selectionStart = newState.selectionEnd = 0;
  }
};
var setSelection = function setSelection2(newState, newIndex, nextLooseValue, formatInfo) {
  newState.selectionStart = newState.selectionEnd = newIndex;
  rangeSelection(nextLooseValue, formatInfo, newState);
};
var setInvalid = function setInvalid2(newState, format, formatInfo, intlService) {
  newState.eventValue = intlService.parseNumber(newState.prevLooseValue, format);
  newState.currentLooseValue = newState.prevLooseValue;
  newState.valueIsCorrected = true;
  setSelection(newState, newState.selectionStart, newState.currentLooseValue, formatInfo);
};
var isMinusSymbolAdded = function isMinusSymbolAdded2(newState, symbols) {
  var newText = String(newState.currentLooseValue);
  var oldText = String(newState.prevLooseValue);
  return newText.split(symbols.minusSign).length !== oldText.split(symbols.minusSign).length && newText.length === oldText.length + symbols.minusSign.length;
};
var isMinusSymbolRemoved = function isMinusSymbolRemoved2(newState, symbols) {
  var newText = String(newState.currentLooseValue);
  var oldText = String(newState.prevLooseValue);
  return newText.indexOf(symbols.minusSign) === -1 && oldText.indexOf(symbols.minusSign) !== -1;
};
var isDecimalDuplicated = function isDecimalDuplicated2(newState, symbols) {
  var newText = String(newState.currentLooseValue);
  return newText.split(symbols.decimal).length > 2;
};
var getFormatPrefixSufix = function getFormatPrefixSufix2(format, intlService) {
  var positiveResult = intlService.formatNumber(DEFAULT_NUMBER, format);
  var negativeResult = intlService.formatNumber(-DEFAULT_NUMBER, format);
  var zeroResult = intlService.formatNumber(ZERO_NUMBER, format);
  var oneResult = intlService.formatNumber(ONE_NUMBER, format);
  var positivePrefix = getPrefix(positiveResult);
  var negativePrefix = getPrefix(negativeResult);
  var zeroPrefix = getPrefix(zeroResult);
  var onePrefix = getPrefix(oneResult);
  var positiveSuffix = getSuffix(positiveResult);
  var negativeSuffix = getSuffix(negativeResult);
  var zeroSuffix = getSuffix(zeroResult);
  var oneSuffix = getSuffix(oneResult);
  return {
    positiveInfo: [positivePrefix, positiveSuffix],
    negativeInfo: [negativePrefix, negativeSuffix],
    zeroInfo: [zeroPrefix, zeroSuffix],
    oneInfo: [onePrefix, oneSuffix]
  };
};
var getFormatSymbols = function getFormatSymbols2(format, intlService) {
  var positiveResult = intlService.formatNumber(DEFAULT_NUMBER, format);
  var negativeResult = intlService.formatNumber(-DEFAULT_NUMBER, format);
  var zeroResult = intlService.formatNumber(ZERO_NUMBER, format);
  var oneResult = intlService.formatNumber(ONE_NUMBER, format);
  var symbols = intlService.numberSymbols();
  var sanitizeRegex = new RegExp("[\\d\\".concat(symbols.decimal).concat(symbols.group, "]"), "g");
  var resultWithDuplicates = [positiveResult, negativeResult, zeroResult, oneResult].map(function(result) {
    return result.replace(sanitizeRegex, "");
  }).join("");
  return resultWithDuplicates.split("").filter(function(x, n, s) {
    return s.indexOf(x) === n;
  }).join("");
};
var getInitialPosition = function getInitialPosition2(nextLooseValue, symbols) {
  var decimalIdex = nextLooseValue.indexOf(symbols.decimal);
  if (decimalIdex > -1) {
    return decimalIdex;
  }
  return getLastNumberIndex(nextLooseValue, DIGITS_REGEX);
};
var reverseString = function reverseString2(str) {
  return str.split("").reverse().join("");
};
var getLastNumberIndex = function getLastNumberIndex2(currentLooseValue, inputRegex) {
  return currentLooseValue.length - reverseString(currentLooseValue).search(inputRegex);
};
var getPrefix = function getPrefix2(str) {
  return str.split(str[str.search(DIGITS_REGEX)])[0];
};
var getSuffix = function getSuffix2(str) {
  var reversedString = reverseString(str);
  return reverseString(reversedString.split(reversedString[reversedString.search(DIGITS_REGEX)])[0]);
};
var getFirstNumberIndex = function getFirstNumberIndex2(prevLooseValue, inputRegex) {
  return prevLooseValue.search(inputRegex);
};
var getDecimalCount = function getDecimalCount2(value2, decimal) {
  var currentDecimalPlace = value2.indexOf(decimal);
  return currentDecimalPlace > -1 ? value2.length - currentDecimalPlace - 1 : 0;
};
var changeBasedSelection = function changeBasedSelection2(currentValue, nextValue, selectionPosition, isDelete, sanitizeRegex) {
  var isCurrentLeadingZero = currentValue.replace(sanitizeRegex, "")[0] === "0";
  var isNextLeadingZero = nextValue.replace(sanitizeRegex, "")[0] === "0";
  if (isCurrentLeadingZero && !isNextLeadingZero) {
    return selectionPosition - 1;
  }
  if (isNextLeadingZero && isDelete) {
    return selectionPosition + 1;
  }
  var numberCounter = 0;
  for (var idx = 0; idx < selectionPosition; idx++) {
    if (DIGITS_REGEX.test(currentValue.charAt(idx))) {
      numberCounter++;
    }
  }
  var newSelection = 0;
  while (numberCounter > 0 && nextValue.length > newSelection) {
    if (DIGITS_REGEX.test(nextValue.charAt(newSelection))) {
      numberCounter--;
    }
    newSelection++;
  }
  return newSelection;
};
var sanitizeNumber = function sanitizeNumber2(state, format, intlService) {
  var newState = __assign6({}, state);
  var prevLooseValue = newState.prevLooseValue;
  var symbols = intlService.numberSymbols();
  var restrictedSymbols = getFormatSymbols(format, intlService);
  var currentLooseValueAsString = String(newState.currentLooseValue);
  var prevLooseValueAsString = String(prevLooseValue);
  var sanitizeRegex = new RegExp("[^\\d\\".concat(symbols.decimal, "]"), "g");
  var sanitizeGroupRegex = new RegExp("[^\\d\\".concat(symbols.decimal, "\\").concat(symbols.group, "]"), "g");
  var allSymbolsRegex = new RegExp("[\\d\\".concat(symbols.decimal, "\\").concat(symbols.group, "]"));
  var sanitizedString = currentLooseValueAsString.replace(sanitizeRegex, "");
  var numberStart = getFirstNumberIndex(currentLooseValueAsString, DIGITS_REGEX);
  var numberEnd = numberStart === -1 ? -1 : getLastNumberIndex(currentLooseValueAsString, DIGITS_REGEX);
  var decimalIndex = currentLooseValueAsString.indexOf(symbols.decimal);
  var sanitizedFormattedString = (currentLooseValueAsString.substring(0, numberStart) + currentLooseValueAsString.substring(numberStart, numberEnd).replace(sanitizeGroupRegex, "") + currentLooseValueAsString.substring(numberEnd, currentLooseValueAsString.length)).split("").filter(function(s) {
    return restrictedSymbols.indexOf(s) !== -1 || s.search(allSymbolsRegex) !== -1;
  }).join("");
  var formattedMax = intlService.formatNumber(MAX_DECIMAL, format).replace(sanitizeRegex, "");
  var maxDecimalIndex = formattedMax.indexOf(symbols.decimal);
  var maxDecimalCount = maxDecimalIndex > -1 ? formattedMax.length - maxDecimalIndex - 1 : 0;
  var formattedMin = intlService.formatNumber(MIN_DECIMAL, format).replace(sanitizeRegex, "");
  var minDecimalIndex = formattedMin.indexOf(symbols.decimal);
  var minDecimalCount = minDecimalIndex > -1 ? formattedMin.length - minDecimalIndex - 1 : 0;
  var _a5 = getFormatPrefixSufix(format, intlService), positiveInfo = _a5.positiveInfo, negativeInfo = _a5.negativeInfo, zeroInfo = _a5.zeroInfo, oneInfo = _a5.oneInfo;
  var formatInfo = [positiveInfo, negativeInfo, zeroInfo, oneInfo];
  var isFormatContainPrefixSuffix = formatInfo.findIndex(function(info) {
    return info.findIndex(function(nestedInfo) {
      return Boolean(nestedInfo);
    }) !== -1;
  }) !== 1;
  var isDelete = currentLooseValueAsString.length > 0 && currentLooseValueAsString.length < prevLooseValueAsString.length;
  var isPercentFormat = format && format[0] === "p" && currentLooseValueAsString && currentLooseValueAsString.indexOf(symbols.percentSign) === -1;
  if (!newState.isPaste) {
    if (currentLooseValueAsString === "") {
      newState.eventValue = null;
      newState.currentLooseValue = "";
      return newState;
    }
    if (newState.currentLooseValue === symbols.minusSign && intlService.formatNumber(-0, format) !== prevLooseValueAsString) {
      newState.eventValue = -0;
      newState.currentLooseValue = formatValue(newState.eventValue, format, intlService);
      setSelection(newState, getInitialPosition(newState.currentLooseValue, symbols), newState.currentLooseValue, formatInfo);
      return newState;
    }
    if (isMinusSymbolAdded(newState, symbols)) {
      var nextValue = intlService.parseNumber(prevLooseValue, format);
      newState.eventValue = -(nextValue !== null ? nextValue : 0);
      newState.currentLooseValue = formatValue(newState.eventValue, format, intlService);
      var currentNumberStart = getFirstNumberIndex(newState.currentLooseValue, DIGITS_REGEX);
      var oldNumberStart = getFirstNumberIndex(prevLooseValueAsString, DIGITS_REGEX);
      setSelection(newState, newState.selectionEnd - 1 + (currentNumberStart - oldNumberStart), newState.currentLooseValue, formatInfo);
      return newState;
    }
    if (isMinusSymbolRemoved(newState, symbols)) {
      newState.eventValue = intlService.parseNumber(newState.currentLooseValue, format);
      setSelection(newState, newState.selectionStart, newState.currentLooseValue, formatInfo);
      return newState;
    }
    if (newState.currentLooseValue === symbols.decimal) {
      newState.eventValue = 0;
      var valueCandidate = formatValue(newState.eventValue, format, intlService);
      if (minDecimalCount === 0 && maxDecimalCount > 0) {
        var currentLastNumberIndex = getLastNumberIndex(valueCandidate, DIGITS_REGEX);
        newState.currentLooseValue = valueCandidate.substring(0, currentLastNumberIndex) + symbols.decimal + valueCandidate.substring(currentLastNumberIndex);
      } else {
        newState.currentLooseValue = valueCandidate;
      }
      setSelection(newState, getInitialPosition(newState.currentLooseValue, symbols) + 1, newState.currentLooseValue, formatInfo);
      return newState;
    }
    if (isDecimalDuplicated(newState, symbols)) {
      setInvalid(newState, format, formatInfo, intlService);
      return newState;
    }
    if (isPercentFormat) {
      newState.eventValue = intlService.parseNumber(currentLooseValueAsString, format) / 100;
      newState.currentLooseValue = formatValue(newState.eventValue, format, intlService);
      return newState;
    }
    var numericSymbols = String(newState.currentLooseValue).replace(/[^\d]/g, "");
    if (numericSymbols.length > MAX_PRECISION) {
      setInvalid(newState, format, formatInfo, intlService);
      return newState;
    }
    if (sanitizedString !== currentLooseValueAsString && currentLooseValueAsString && isFormatContainPrefixSuffix) {
      var formatInfoIndex = formatInfo.findIndex(function(_a6) {
        var prefix = _a6[0], suffix = _a6[1];
        var prefixIndex = currentLooseValueAsString.indexOf(prefix);
        var suffixIndex = currentLooseValueAsString.indexOf(suffix);
        var prefixFound = prefixIndex === 0;
        var suffixFound = suffixIndex === currentLooseValueAsString.length - suffix.length;
        var prefixGap = prefixIndex + prefix.length !== numberStart && numberStart !== -1 && currentLooseValueAsString[prefixIndex + prefix.length] !== symbols.decimal;
        var suffixGap = suffixIndex !== numberEnd && numberEnd !== -1 && currentLooseValueAsString[suffixIndex - 1] !== symbols.decimal;
        if (prefix && suffix) {
          if (prefixGap || suffixGap) {
            return false;
          }
          return prefixFound && suffixFound;
        }
        if (prefix) {
          if (prefixGap) {
            return false;
          }
          return prefixFound;
        }
        if (suffix) {
          if (suffixGap) {
            return false;
          }
          return suffixFound;
        }
        return false;
      });
      if (formatInfoIndex === -1) {
        setInvalid(newState, format, formatInfo, intlService);
        return newState;
      }
    }
    if (sanitizedString[sanitizedString.length - 1] === symbols.decimal && maxDecimalCount > 0) {
      newState.eventValue = intlService.parseNumber(currentLooseValueAsString, format);
      newState.currentLooseValue = sanitizedFormattedString;
      return newState;
    }
    if (newState.currentLooseValue && prevLooseValue) {
      var isSpecialSymbolDeleted = (restrictedSymbols + symbols.decimal + symbols.group).split("").findIndex(function(s) {
        if (currentLooseValueAsString.split("").filter(function(x) {
          return x === s;
        }).length < prevLooseValueAsString.split("").filter(function(x) {
          return x === s;
        }).length && currentLooseValueAsString.length + 1 === prevLooseValueAsString.length) {
          if (s === symbols.decimal && getDecimalCount(prevLooseValueAsString.replace(sanitizeRegex, ""), symbols.decimal) === 0) {
            return false;
          }
          return true;
        }
        return false;
      }) > -1;
      if (isSpecialSymbolDeleted) {
        newState.eventValue = intlService.parseNumber(state.prevLooseValue, format);
        newState.currentLooseValue = state.prevLooseValue;
        return newState;
      }
    }
    var currentDecimalCount = getDecimalCount(sanitizedString, symbols.decimal);
    var endsOnDecimal = sanitizedString[sanitizedString.length - 1] === "0";
    if (isDelete && endsOnDecimal && currentDecimalCount < minDecimalCount) {
      newState.eventValue = intlService.parseNumber(newState.currentLooseValue, format);
      newState.currentLooseValue = formatValue(newState.eventValue, format, intlService);
      return newState;
    }
    if (currentDecimalCount > 0) {
      var valueUntillDecimal = currentLooseValueAsString.substring(0, decimalIndex);
      if (endsOnDecimal && (!valueUntillDecimal || prevLooseValueAsString.indexOf(valueUntillDecimal) !== 0)) {
        newState.eventValue = intlService.parseNumber(newState.currentLooseValue, format);
        var nextLooseValue = formatValue(newState.eventValue, format, intlService);
        setSelection(newState, changeBasedSelection(currentLooseValueAsString, nextLooseValue, newState.selectionEnd, isDelete, sanitizeRegex), nextLooseValue, formatInfo);
        newState.currentLooseValue = nextLooseValue;
        return newState;
      }
      if (currentDecimalCount > maxDecimalCount) {
        var looseDecimalPlace = currentLooseValueAsString.indexOf(symbols.decimal);
        var result = currentLooseValueAsString.substring(0, looseDecimalPlace) + currentLooseValueAsString.substring(looseDecimalPlace, looseDecimalPlace + 1 + maxDecimalCount) + currentLooseValueAsString.substring(numberEnd, String(newState.currentLooseValue).length);
        newState.eventValue = intlService.parseNumber(result, format);
        newState.currentLooseValue = result;
        setSelection(newState, newState.selectionStart, result, formatInfo);
        return newState;
      }
      if (minDecimalCount !== maxDecimalCount && currentDecimalCount <= maxDecimalCount && endsOnDecimal) {
        newState.eventValue = intlService.parseNumber(newState.currentLooseValue, format);
        newState.currentLooseValue = sanitizedFormattedString;
        return newState;
      }
      if (currentDecimalCount < minDecimalCount) {
        newState.eventValue = intlService.parseNumber(newState.currentLooseValue, format);
        newState.currentLooseValue = formatValue(newState.eventValue, format, intlService);
        return newState;
      }
    }
  }
  newState.eventValue = intlService.parseNumber(newState.currentLooseValue, format);
  if (isPercentFormat) {
    newState.eventValue = newState.eventValue / 100;
  }
  if (typeof newState.eventValue === "number") {
    var nextLooseValue = formatValue(newState.eventValue, format, intlService);
    if (currentLooseValueAsString.length === 1) {
      setSelection(newState, getInitialPosition(nextLooseValue, symbols), nextLooseValue, formatInfo);
    } else {
      setSelection(newState, changeBasedSelection(currentLooseValueAsString, nextLooseValue, newState.selectionEnd, isDelete, sanitizeRegex), nextLooseValue, formatInfo);
    }
    newState.currentLooseValue = nextLooseValue;
  } else {
    newState.currentLooseValue = formatValue(intlService.parseNumber(sanitizedString), format, intlService);
  }
  return newState;
};

// node_modules/@progress/kendo-vue-inputs/dist/es/numerictextbox/NumericTextBox.js
var allVue32 = vue_runtime_esm_bundler_exports;
var gh32 = allVue32.h;
var isV332 = allVue32.version && allVue32.version[0] === "3";
var ref9 = allVue32.ref;
var inject3 = allVue32.inject;
var VALIDATION_MESSAGE = "Please enter a valid value!";
var NumericTextBoxVue2 = {
  model: {
    event: "changemodel"
  },
  // @ts-ignore
  emits: {
    "change": null,
    "changemodel": null,
    "update:modelValue": null,
    "focus": null,
    "blur": null
  },
  props: {
    modelValue: Number,
    value: Number,
    defaultValue: Number,
    step: {
      type: Number,
      default: 1
    },
    format: [String, Object],
    tabIndex: Number,
    accessKey: String,
    title: String,
    placeholder: String,
    min: Number,
    max: Number,
    spinners: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: false
    },
    dir: String,
    name: String,
    label: String,
    validationMessage: String,
    validityStyles: {
      type: Boolean,
      default: true
    },
    valid: {
      type: Boolean,
      default: void 0
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator15(value2) {
        return [null, "small", "medium", "large"].includes(value2);
      }
    },
    rounded: {
      type: String,
      default: "medium",
      validator: function validator16(value2) {
        return [null, "small", "medium", "large", "full"].includes(value2);
      }
    },
    fillMode: {
      type: String,
      default: "solid",
      validator: function validator17(value2) {
        return [null, "solid", "flat", "outline"].includes(value2);
      }
    },
    required: {
      type: Boolean,
      default: false
    },
    id: String,
    ariaLabel: String,
    iconName: String,
    inputPrefix: templateDefinition,
    inputSuffix: templateDefinition,
    showValidationIcon: Boolean,
    showLoadingIcon: Boolean,
    showClearButton: Boolean,
    inputClass: String,
    inputType: {
      type: String,
      default: "tel"
    },
    wrapperClass: String
  },
  inject: {
    kendoIntlService: {
      default: null
    },
    kendoLocalizationService: {
      default: null
    }
  },
  data: function data12() {
    return {
      hasMounted: false,
      isInvalid: false,
      isEmpty: false,
      currentValue: 0,
      valueDuringOnChange: 0,
      currentLooseValue: "",
      selectionStart: 0,
      selectionEnd: 0,
      decimalSelect: false,
      focused: false,
      forceUpdate: false
    };
  },
  created: function created14() {
    validatePackage(packageMetadata);
    this._textBeforeInput = "";
    this._inputId = guid();
    this.$data.currentLooseValue = null;
    this.$data.valueDuringOnChange = void 0;
    this._intl = provideIntlService(this);
    this._symbols = this._intl.numberSymbols();
    if (this.$props.value !== void 0) {
      this.$data.currentValue = this.$props.value;
    } else if (this.$props.modelValue !== void 0) {
      this.$data.currentValue = this.$props.modelValue;
    } else if (this.$props.defaultValue !== void 0) {
      this.$data.currentValue = this.$props.defaultValue;
    } else {
      this.$data.currentValue = null;
    }
  },
  mounted: function mounted9() {
    this._input = getRef(this, "input");
    this._elementWrapper = this.v3 ? this.elementWrapperRef : this.$refs.elementWrapper;
    this.$data.hasMounted = true;
    if (this._input) {
      this._textBeforeInput = this._input.value;
    }
    this.setValidity();
  },
  updated: function updated9() {
    if (!(canUseDOM && document.activeElement !== this._input || !this._input) && this.$data.currentLooseValue !== null) {
      if (this.$data.forceUpdate) {
        this._input.selectionStart = this.$data.selectionStart;
        this._input.selectionEnd = this.$data.selectionEnd;
        this.$data.forceUpdate = false;
      }
    }
    if (this._input) {
      this._textBeforeInput = this._input.value;
    }
    this.setValidity();
  },
  computed: {
    computedValue: {
      get: function get5() {
        if (this.$data.valueDuringOnChange !== void 0) {
          return this.$data.valueDuringOnChange;
        } else {
          return this.$data.currentValue;
        }
      }
    },
    looseValue: {
      get: function get6() {
        return formatValue(this.$data.focused ? this.$data.currentLooseValue : getStateOrPropsValue(this.$props.value, this.$data.currentValue), this.$props.format, this._intl);
      }
    },
    spanClassNames: {
      get: function get7() {
        var _a5;
        var isValid3 = !this.$data.hasMounted || !this.$props.validityStyles || this.validity().valid;
        var compValue = this.computedValue;
        return _a5 = {
          "k-floating-label-container": true,
          "k-focus": this.$data.focused,
          "k-empty": !(compValue === 0 ? true : compValue || this.$props.placeholder),
          "k-invalid": !isValid3 && isValid3 !== void 0,
          "k-rtl": this.$props.dir === "rtl"
        }, _a5[this.inputClass] = this.inputClass, _a5;
      }
    },
    wrapperClassNames: function wrapperClassNames() {
      var _a5;
      var _b = this.$props, size2 = _b.size, fillMode = _b.fillMode, rounded = _b.rounded, required = _b.required, disabled = _b.disabled;
      var isValid3 = !this.$props.validityStyles || this.validity().valid;
      return _a5 = {
        "k-input": true,
        "k-numerictextbox": true
      }, _a5["k-input-".concat(kendoThemeMaps.sizeMap[size2] || size2)] = size2, _a5["k-input-".concat(fillMode)] = fillMode, _a5["k-rounded-".concat(kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded, _a5["k-invalid"] = !isValid3, _a5["k-required"] = required, _a5["k-disabled"] = disabled, _a5["k-loading"] = this.showLoadingIcon, _a5[this.wrapperClass] = this.wrapperClass, _a5;
    },
    inputInnerClass: function inputInnerClass3() {
      var _a5;
      return _a5 = {
        "k-input-inner": true
      }, _a5[this.inputClass] = this.inputClass, _a5;
    }
  },
  methods: {
    validity: function validity4() {
      var customError = this.$props.validationMessage !== void 0;
      var isValid3 = !this.$data.valueIsOutOfRange && (!this.$props.required || this.computedValue !== null);
      var valid = this.$props.valid !== void 0 ? this.$props.valid : isValid3;
      return {
        customError,
        valid,
        valueMissing: this.computedValue === null
      };
    },
    clearClick: function clearClick3(event) {
      if (this.$props.value !== void 0) {
        this.$data.currentValue = this.$props.value;
      } else if (this.$props.modelValue !== void 0) {
        this.$data.currentValue = this.$props.modelValue;
      } else {
        this.$data.currentValue = null;
      }
      this.$emit("changemodel", null);
      this.$emit("update:modelValue", null);
      this.$emit("change", {
        event,
        value: null,
        component: this,
        target: {
          name: this.$props.name,
          value: null
        },
        validity: this.validity()
      });
    },
    focus: function focus8() {
      if (this._input) {
        this._input.focus();
      }
    },
    emitFocus: function emitFocus3(e) {
      this.$data.currentLooseValue = this._prevLooseValue;
      this.$data.focused = true;
      this.$emit("focus", e);
      this.$data.forceUpdate = true;
    },
    emitBlur: function emitBlur3(e) {
      this.$data.eventValue = null;
      this.$data.prevLooseValue = "";
      this.$data.currentLooseValue = "";
      this.$data.focused = false;
      this.$data.selectionStart = void 0;
      this.$data.selectionEnd = void 0;
      this.$data.decimalSelect = false;
      this.$data.valueIsCorrected = false;
      this.$data.valueIsOutOfRange = false;
      this.$emit("blur", e);
      this.$data.forceUpdate = true;
    },
    handleFocus: function handleFocus3(_) {
      this.$data.focused = true;
    },
    handleBlur: function handleBlur3(_) {
      this.$data.focused = false;
    },
    setValidity: function setValidity4() {
      if (this._input && this._input.setCustomValidity) {
        this._input.setCustomValidity(this.validity().valid ? "" : this.$props.validationMessage || VALIDATION_MESSAGE);
      }
    },
    getCurrentState: function getCurrentState() {
      return {
        eventValue: getStateOrPropsValue(this.$props.value, this.$data.currentValue),
        prevLooseValue: this._prevLooseValue,
        currentLooseValue: this._input.value,
        selectionStart: this._input.selectionStart,
        selectionEnd: this._input.selectionEnd,
        decimalSelect: false,
        valueIsCorrected: false,
        valueIsOutOfRange: false,
        isPaste: this._isPaste,
        focused: this.$data.focused
      };
    },
    parseNumber: function parseNumber(text) {
      return this._intl.parseNumber(text, this.$props.format);
    },
    elementChange: function elementChange(event) {
      var newState = this.getCurrentState();
      this._isPaste = false;
      this.triggerChange(event, sanitizeNumber(newState, this.$props.format, this._intl));
    },
    triggerChange: function triggerChange2(event, newState) {
      var _this = this;
      if (this.$props.disabled) {
        return;
      }
      this.$data.valueDuringOnChange = newState.eventValue;
      this.$data.currentValue = newState.eventValue;
      var formattedValue = formatValue(rangeValue(newState.eventValue, this.$props.min, this.$props.max), this.$props.format, this._intl);
      var rangedValue = rangeValue(this.parseNumber(formattedValue), this.$props.min, this.$props.max);
      if (rangedValue !== newState.eventValue) {
        newState.valueIsOutOfRange = true;
        newState.eventValue = rangedValue;
        this.$data.valueDuringOnChange = rangedValue;
        this.$data.currentValue = rangedValue;
      }
      if (newState.valueIsCorrected) {
        var wrapper = this._elementWrapper;
        if (wrapper && wrapper.className.indexOf("k-invalid") === -1) {
          this.$data.isInvalid = true;
          setTimeout(function() {
            _this.$data.isInvalid = false;
          }, 50);
        }
      }
      var shouldFireEvent = this.$props.value !== newState.eventValue;
      if (this.$props.value !== void 0) {
        this.$data.currentValue = this.$props.value;
      } else if (this.$props.modelValue !== void 0) {
        this.$data.currentValue = this.$props.modelValue;
      } else {
        this.$data.currentValue = this.$data.valueDuringOnChange;
      }
      this.$data.prevLooseValue = newState.prevLooseValue;
      this.$data.currentLooseValue = void 0;
      this.$data.currentLooseValue = newState.currentLooseValue;
      this.$data.selectionStart = newState.selectionStart;
      this.$data.selectionEnd = newState.selectionEnd;
      this.$data.decimalSelect = newState.decimalSelect;
      this.$data.valueIsCorrected = newState.valueIsCorrected;
      this.$data.valueIsOutOfRange = newState.valueIsOutOfRange;
      this.$data.focused = newState.focused;
      this.$data.isPaste = newState.isPaste;
      this.$data.forceUpdate = !this.$data.forceUpdate;
      if (shouldFireEvent) {
        this.$emit("changemodel", this.$data.valueDuringOnChange);
        this.$emit("update:modelValue", this.$data.valueDuringOnChange);
        this.$emit("change", {
          event,
          value: this.$data.valueDuringOnChange,
          component: this,
          target: {
            name: this.$props.name,
            value: this.$data.valueDuringOnChange
          },
          validity: this.validity()
        });
      }
      this.$data.valueDuringOnChange = void 0;
    },
    onPasteHandler: function onPasteHandler(_event) {
      this._isPaste = true;
    },
    increase: function increase(event) {
      var newState = this.getCurrentState();
      increaseValue(this.parseNumber(String(newState.currentLooseValue)), newState, this.$props.step, this.$props.min, this.$props.max, this.$props.format, this._intl);
      this.triggerChange(event, newState);
    },
    decrease: function decrease(event) {
      var newState = this.getCurrentState();
      decreaseValue(this.parseNumber(String(newState.currentLooseValue)), newState, this.$props.step, this.$props.min, this.$props.max, this.$props.format, this._intl);
      this.triggerChange(event, newState);
    },
    wheel: function wheel(event) {
      if (!canUseDOM || document.activeElement !== this._input || !this._input) {
        return;
      }
      if (event.deltaY < 0) {
        event.preventDefault();
        this.increase(event);
      }
      if (event.deltaY > 0) {
        event.preventDefault();
        this.decrease(event);
      }
    },
    keyDown: function keyDown(event) {
      var newState = this.getCurrentState();
      var currentValue = this.parseNumber(String(newState.currentLooseValue));
      if (newState.selectionEnd > newState.selectionStart && newState.selectionEnd - newState.selectionStart === String(newState.currentLooseValue).length) {
        return;
      }
      switch (event.keyCode) {
        case 38:
          increaseValue(currentValue, newState, this.$props.step, this.$props.min, this.$props.max, this.$props.format, this._intl);
          break;
        case 40:
          decreaseValue(currentValue, newState, this.$props.step, this.$props.min, this.$props.max, this.$props.format, this._intl);
          break;
        case 13:
          var formattedValue = formatValue(rangeValue(currentValue, this.$props.min, this.$props.max), this.$props.format, this._intl);
          var rangedValue = rangeValue(this.parseNumber(formattedValue), this.$props.min, this.$props.max);
          newState.eventValue = rangedValue;
          newState.currentLooseValue = formatValue(rangedValue, this.$props.format, this._intl);
          newState.selectionStart = newState.selectionEnd = newState.currentLooseValue.length;
          break;
        case 110:
          var element2 = this._input;
          var symbols = this._intl.numberSymbols();
          if (element2) {
            newState.currentLooseValue = newState.currentLooseValue.slice(0, newState.selectionStart) + symbols.decimal + newState.currentLooseValue.slice(newState.selectionEnd);
            newState.selectionStart = newState.selectionEnd = newState.selectionStart + 1;
            newState = sanitizeNumber(newState, this.$props.format, this._intl);
          }
          break;
        default:
          return;
      }
      event.preventDefault();
      this.triggerChange(event, newState);
    },
    spinnersWrapperMouseDown: function spinnersWrapperMouseDown(e) {
      if (canUseDOM && this._input) {
        e.preventDefault();
        if (document.activeElement !== this._input) {
          this._input.focus();
        }
      }
    }
  },
  // @ts-ignore
  setup: !isV332 ? void 0 : function() {
    var v3 = !!isV332;
    var inputRef = ref9(null);
    var elementWrapperRef = ref9(null);
    var kendoLocalizationService = inject3("kendoLocalizationService", {});
    var kendoIntlService = inject3("kendoIntlService", {});
    return {
      v3,
      inputRef,
      elementWrapperRef,
      kendoLocalizationService,
      kendoIntlService
    };
  },
  // @ts-ignore
  render: function render19(createElement) {
    var h = gh32 || createElement;
    var _a5 = this.$props, iconName = _a5.iconName, showValidationIcon = _a5.showValidationIcon, showLoadingIcon = _a5.showLoadingIcon, showClearButton = _a5.showClearButton;
    var inputId = this.$props.id || this._inputId;
    var defaultSlot = getDefaultSlots(this);
    var localizationService = provideLocalizationService(this);
    var isValid3 = this.validity().valid;
    if (this.$props.value !== void 0 && this.$props.value !== this.$data.currentValue) {
      this.$data.currentValue = this.$props.value;
    } else if (this.$props.modelValue !== void 0 && this.$props.modelValue !== this.$data.currentValue) {
      this.$data.currentValue = this.$props.modelValue;
    }
    this._prevLooseValue = this.$data.currentLooseValue ? this.looseValue : this.looseValue;
    var inputPrefixTemplate = templateRendering.call(this, this.$props.inputPrefix, getListeners.call(this));
    var inputSuffixTemplate = templateRendering.call(this, this.$props.inputSuffix, getListeners.call(this));
    var inputPrefix = getTemplate.call(this, {
      h,
      template: inputPrefixTemplate,
      additionalProps: {
        value: this.computedValue,
        valid: isValid3
      }
    });
    var inputSuffix = getTemplate.call(this, {
      h,
      template: inputSuffixTemplate,
      additionalProps: {
        value: this.computedValue,
        valid: isValid3
      }
    });
    var numerictextbox = h("span", {
      dir: this.$props.dir,
      attrs: this.v3 ? void 0 : {
        dir: this.$props.dir
      },
      "class": this.wrapperClassNames,
      style: this.$attrs.style
    }, [iconName && h(Icon, {
      name: iconName,
      attrs: this.v3 ? void 0 : {
        name: iconName
      },
      "class": "k-input-icon"
    }), this.$props.inputPrefix && h("span", {
      "class": "k-input-prefix"
    }, [inputPrefix]), h("input", {
      tabindex: this.$props.tabIndex,
      attrs: this.v3 ? void 0 : {
        tabindex: this.$props.tabIndex,
        accesskey: this.$props.accessKey,
        disabled: this.$props.disabled,
        title: this.$props.title,
        "aria-label": this.$props.ariaLabel,
        "aria-valuemin": this.$props.min,
        "aria-valuemax": this.$props.max,
        "aria-disabled": this.$props.disabled ? "true" : void 0,
        placeholder: this.$props.placeholder,
        type: this.$props.inputType,
        spellcheck: false,
        autocomplete: "off",
        autocorrect: "off",
        id: inputId,
        role: "spinbutton",
        name: this.$props.name
      },
      accesskey: this.$props.accessKey,
      disabled: this.$props.disabled,
      title: this.$props.title,
      "aria-label": this.$props.ariaLabel,
      "aria-valuemin": this.$props.min,
      "aria-valuemax": this.$props.max,
      "aria-disabled": this.$props.disabled ? "true" : void 0,
      placeholder: this.$props.placeholder,
      type: this.$props.inputType,
      spellcheck: false,
      autocomplete: "off",
      autocorrect: "off",
      "class": this.inputInnerClass,
      id: inputId,
      role: "spinbutton",
      value: this.v3 ? this.looseValue : null,
      domProps: this.v3 ? void 0 : {
        "value": this.looseValue
      },
      name: this.$props.name,
      onWheel: this.wheel,
      on: this.v3 ? void 0 : {
        "wheel": this.wheel,
        "keydown": this.keyDown,
        "input": this.elementChange,
        "focus": this.emitFocus,
        "blur": this.emitBlur,
        "paste": this.onPasteHandler
      },
      onKeydown: this.keyDown,
      onInput: this.elementChange,
      onFocus: this.emitFocus,
      onBlur: this.emitBlur,
      onPaste: this.onPasteHandler,
      ref: setRef(this, "input")
    }), this.$props.inputSuffix && h("span", {
      "class": "k-input-suffix"
    }, [inputSuffix]), showValidationIcon && isValid3 && h(Icon, {
      name: "check",
      attrs: this.v3 ? void 0 : {
        name: "check",
        icon: checkIcon
      },
      icon: checkIcon,
      "class": "k-input-validation-icon"
    }), showValidationIcon && !isValid3 && h(Icon, {
      name: "exclamation-circle",
      attrs: this.v3 ? void 0 : {
        name: "exclamation-circle",
        icon: exclamationCircleIcon
      },
      icon: exclamationCircleIcon,
      "class": "k-input-validation-icon"
    }), showLoadingIcon && h(Icon, {
      name: "loading",
      attrs: this.v3 ? void 0 : {
        name: "loading"
      },
      "class": "k-input-loading-icon"
    }), showClearButton && this.computedValue !== void 0 && this.computedValue !== null && h("span", {
      onClick: this.clearClick,
      on: this.v3 ? void 0 : {
        "click": this.clearClick
      },
      "class": "k-clear-value"
    }, [h(Icon, {
      name: "x",
      attrs: this.v3 ? void 0 : {
        name: "x",
        icon: xIcon
      },
      icon: xIcon
    })]), defaultSlot, this.$props.spinners && h("span", {
      "class": "k-input-spinner k-spin-button",
      onMousedown: this.spinnersWrapperMouseDown,
      on: this.v3 ? void 0 : {
        "mousedown": this.spinnersWrapperMouseDown
      }
    }, [
      // @ts-ignore
      h(Button, {
        type: "button",
        attrs: this.v3 ? void 0 : {
          type: "button",
          tabIndex: -1,
          icon: "caret-alt-up",
          svgIcon: caretAltUpIcon,
          rounded: null,
          "aria-label": localizationService.toLanguageString(numericIncreaseValue, messages2[numericIncreaseValue]),
          title: localizationService.toLanguageString(numericIncreaseValue, messages2[numericIncreaseValue])
        },
        tabIndex: -1,
        icon: "caret-alt-up",
        svgIcon: caretAltUpIcon,
        "class": "k-spinner-increase",
        rounded: null,
        "aria-label": localizationService.toLanguageString(numericIncreaseValue, messages2[numericIncreaseValue]),
        title: localizationService.toLanguageString(numericIncreaseValue, messages2[numericIncreaseValue]),
        onClick: this.increase,
        on: this.v3 ? void 0 : {
          "click": this.increase
        }
      }),
      // @ts-ignore
      h(Button, {
        type: "button",
        attrs: this.v3 ? void 0 : {
          type: "button",
          tabIndex: -1,
          icon: "caret-alt-down",
          svgIcon: caretAltDownIcon,
          rounded: null,
          "aria-label": localizationService.toLanguageString(numericDecreaseValue, messages2[numericDecreaseValue]),
          title: localizationService.toLanguageString(numericDecreaseValue, messages2[numericDecreaseValue])
        },
        tabIndex: -1,
        "class": "k-spinner-decrease",
        icon: "caret-alt-down",
        svgIcon: caretAltDownIcon,
        rounded: null,
        "aria-label": localizationService.toLanguageString(numericDecreaseValue, messages2[numericDecreaseValue]),
        title: localizationService.toLanguageString(numericDecreaseValue, messages2[numericDecreaseValue]),
        onClick: this.decrease,
        on: this.v3 ? void 0 : {
          "click": this.decrease
        }
      })
    ])]);
    return this.$props.label ? h("span", {
      "class": this.spanClassNames,
      onFocusin: this.handleFocus,
      on: this.v3 ? void 0 : {
        "focusin": this.handleFocus,
        "focusout": this.handleBlur
      },
      onFocusout: this.handleBlur,
      dir: this.$props.dir,
      attrs: this.v3 ? void 0 : {
        dir: this.$props.dir
      }
    }, [numerictextbox, this.$props.label ? inputId ? h("label", {
      "for": inputId,
      attrs: this.v3 ? void 0 : {
        "for": inputId
      },
      "class": "k-label"
    }, [this.$props.label]) : h("span", {
      "class": "k-label"
    }, [this.$props.label]) : null]) : numerictextbox;
  }
};
var NumericTextBox = NumericTextBoxVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/maskedtextbox/parsing/result.js
var ResultType;
(function(ResultType3) {
  ResultType3[ResultType3["Literal"] = 0] = "Literal";
  ResultType3[ResultType3["Mask"] = 1] = "Mask";
  ResultType3[ResultType3["Undefined"] = 2] = "Undefined";
})(ResultType || (ResultType = {}));
var Result = (
  /** @class */
  function() {
    function Result3(value2, rest, type) {
      if (type === void 0) {
        type = ResultType.Undefined;
      }
      this.value = value2;
      this.rest = rest;
      this.type = type;
    }
    Result3.prototype.map = function(fn) {
      return new Result3(fn(this.value), this.rest);
    };
    Result3.prototype.chain = function(fn) {
      return fn(this.value, this.rest);
    };
    Result3.prototype.fold = function(s, _) {
      return s(this.value, this.rest);
    };
    Result3.prototype.concat = function(r) {
      return this.map(function(vs, _) {
        return r.chain(function(v, __) {
          return vs.concat([v]);
        });
      });
    };
    Result3.prototype.toString = function() {
      return "Result({ value: '".concat(this.value, "', rest: ").concat(this.rest, " })");
    };
    return Result3;
  }()
);

// node_modules/@progress/kendo-vue-inputs/dist/es/maskedtextbox/parsing/stream.js
var Stream = (
  /** @class */
  function() {
    function Stream3(input, control) {
      if (input === void 0) {
        input = [];
      }
      if (control === void 0) {
        control = [];
      }
      this.input = input;
      this.control = control;
      this.inputCursor = 0;
      this.controlCursor = 0;
    }
    Stream3.prototype.eof = function() {
      return this.inputCursor >= this.input.length;
    };
    Stream3.prototype.next = function() {
      return {
        char: this.input[this.inputCursor++],
        control: this.control[this.controlCursor++]
      };
    };
    Stream3.prototype.peek = function() {
      return {
        char: this.input[this.inputCursor],
        control: this.control[this.controlCursor]
      };
    };
    Stream3.prototype.eat_input = function() {
      this.inputCursor++;
    };
    Stream3.prototype.eat_control = function() {
      this.controlCursor++;
    };
    Stream3.prototype.eat = function() {
      this.inputCursor++;
      this.controlCursor++;
    };
    return Stream3;
  }()
);

// node_modules/@progress/kendo-vue-inputs/dist/es/maskedtextbox/parsing/parsers.js
var toArray = function(value2) {
  return (value2 || "").split("");
};
var ESCAPE_CHARACTER = "\\";
var Parser = (
  /** @class */
  function() {
    function Parser3(parse) {
      this.parse = parse;
    }
    Parser3.prototype.run = function(input, control) {
      if (control === void 0) {
        control = "";
      }
      if (input instanceof Stream) {
        return this.parse(input);
      } else {
        return this.parse(new Stream(toArray(input), toArray(control)));
      }
    };
    Parser3.prototype.map = function(f) {
      var _this = this;
      return new Parser3(function(stream) {
        return _this.parse(stream).map(f);
      });
    };
    Parser3.prototype.chain = function(f) {
      var _this = this;
      return new Parser3(function(stream) {
        return _this.parse(stream).chain(function(v, s) {
          return f(v).run(s);
        });
      });
    };
    Parser3.prototype.isLiteral = function(c) {
      return this.run(c).type === ResultType.Literal;
    };
    return Parser3;
  }()
);
var mask = function(_a5) {
  var prompt2 = _a5.prompt, promptPlaceholder2 = _a5.promptPlaceholder;
  return function(rule) {
    return new Parser(function(stream) {
      while (!stream.eof()) {
        var _a6 = stream.peek(), char = _a6.char, control = _a6.control;
        if (char === control && control === prompt2) {
          stream.eat();
          return new Result(prompt2, stream, ResultType.Mask);
        }
        if (rule.test(char)) {
          stream.eat();
          return new Result(char, stream, ResultType.Mask);
        }
        if (char === promptPlaceholder2) {
          stream.eat();
          return new Result(prompt2, stream, ResultType.Mask);
        }
        stream.eat_input();
      }
      stream.eat();
      return new Result(prompt2, stream, ResultType.Mask);
    });
  };
};
var literal = function(_token) {
  return new Parser(function(stream) {
    var char = stream.peek().char;
    if (char === _token) {
      stream.eat();
      return new Result(_token, stream, ResultType.Literal);
    }
    return new Result(_token, stream, ResultType.Literal);
  });
};
var unmask = function(prompt2) {
  return function(rule) {
    return new Parser(function(stream) {
      while (!stream.eof()) {
        var _a5 = stream.peek(), char = _a5.char, control = _a5.control;
        if (char === prompt2 && control === prompt2) {
          stream.eat();
          return new Result(char, stream);
        }
        if (rule.test(char)) {
          stream.eat();
          return new Result(char, stream);
        }
        stream.eat_input();
      }
      stream.eat();
      return new Result("", stream);
    });
  };
};
var unliteral = function(_token) {
  return new Parser(function(stream) {
    if (stream.eof()) {
      return new Result("", stream);
    }
    var char = stream.peek().char;
    if (char === _token) {
      stream.eat();
    }
    return new Result(_token, stream);
  });
};
var token = function(rules2, creator) {
  return new Parser(function(stream) {
    var char = stream.next().char;
    var rule = rules2[char];
    if (char === ESCAPE_CHARACTER) {
      char = stream.next().char;
      return new Result(creator.literal(char), stream);
    }
    if (!rule) {
      return new Result(creator.literal(char), stream);
    }
    return new Result(creator.mask(rule), stream);
  });
};
var rawMask = function(_a5) {
  var prompt2 = _a5.prompt, promptPlaceholder2 = _a5.promptPlaceholder;
  return new Parser(function(stream) {
    var char = stream.next().char;
    if (char === prompt2) {
      return new Result(promptPlaceholder2, stream);
    }
    return new Result(char, stream);
  });
};
var rawLiteral = function(includeLiterals2) {
  return new Parser(function(stream) {
    var char = stream.next().char;
    if (includeLiterals2) {
      return new Result(char, stream);
    }
    return new Result("", stream);
  });
};

// node_modules/@progress/kendo-vue-inputs/dist/es/maskedtextbox/parsing/combinators.js
var always = function(value2) {
  return new Parser(function(stream) {
    return new Result(value2, stream);
  });
};
var append2 = function(p1, p2) {
  return p1.chain(function(vs) {
    return p2.map(function(v) {
      return vs.concat([v]);
    });
  });
};
var sequence = function(list) {
  return list.reduce(function(acc, parser) {
    return append2(acc, parser);
  }, always([]));
};
var greedy = function(parser) {
  return new Parser(function(stream) {
    var result = new Result([], stream);
    while (!stream.eof()) {
      result = result.concat(parser.run(stream));
    }
    return result;
  });
};

// node_modules/@progress/kendo-vue-inputs/dist/es/maskedtextbox/masking.service.js
var MaskingService = (
  /** @class */
  function() {
    function MaskingService3() {
      this.rules = {};
      this.prompt = "_";
      this.mask = "";
      this.promptPlaceholder = " ";
      this.includeLiterals = false;
      this.maskTokens = [];
      this.unmaskTokens = [];
      this.rawTokens = [];
      this.validationTokens = [];
    }
    MaskingService3.prototype.update = function(_a5) {
      var _b = _a5.mask, mask4 = _b === void 0 ? "" : _b, _c = _a5.prompt, prompt2 = _c === void 0 ? "" : _c, _d = _a5.promptPlaceholder, promptPlaceholder2 = _d === void 0 ? " " : _d, _e = _a5.rules, rules2 = _e === void 0 ? {} : _e, _f = _a5.includeLiterals, includeLiterals2 = _f === void 0 ? false : _f;
      this.mask = mask4;
      this.prompt = prompt2;
      this.promptPlaceholder = promptPlaceholder2;
      this.rules = rules2;
      this.includeLiterals = includeLiterals2;
      this.tokenize();
    };
    MaskingService3.prototype.validationValue = function(maskedValue) {
      if (maskedValue === void 0) {
        maskedValue = "";
      }
      var value2 = maskedValue;
      sequence(this.validationTokens).run(maskedValue).fold(function(unmasked) {
        value2 = unmasked.join("");
      });
      return value2;
    };
    MaskingService3.prototype.rawValue = function(maskedValue) {
      if (maskedValue === void 0) {
        maskedValue = "";
      }
      var value2 = maskedValue;
      if (!this.rawTokens.length) {
        return value2;
      }
      sequence(this.rawTokens).run(maskedValue).fold(function(unmasked) {
        value2 = unmasked.join("");
      });
      return value2;
    };
    MaskingService3.prototype.maskRaw = function(rawValue2) {
      if (rawValue2 === void 0) {
        rawValue2 = "";
      }
      var value2 = rawValue2;
      if (!this.maskTokens.length) {
        return value2;
      }
      sequence(this.maskTokens).run(rawValue2).fold(function(masked) {
        value2 = masked.join("");
      });
      return value2;
    };
    MaskingService3.prototype.maskInput = function(input, control, splitPoint) {
      if (input.length < control.length) {
        return this.maskRemoved(input, control, splitPoint);
      }
      return this.maskInserted(input, control, splitPoint);
    };
    MaskingService3.prototype.maskInRange = function(pasted, oldValue, start, end) {
      var value2 = "";
      var selection2 = end;
      var beforeChange = oldValue.split("").slice(0, start);
      var afterChange = oldValue.split("").slice(end);
      sequence(this.maskTokens.slice(start, end)).run(pasted).fold(function(masked) {
        value2 = beforeChange.concat(masked).concat(afterChange).join("");
      });
      return {
        selection: selection2,
        value: value2
      };
    };
    MaskingService3.prototype.maskRemoved = function(input, control, splitPoint) {
      var _this = this;
      var value2 = "";
      var selection2 = splitPoint;
      var unchanged = input.split("").slice(splitPoint);
      var changed = input.split("").slice(0, splitPoint).join("");
      var take = this.maskTokens.length - (input.length - splitPoint);
      sequence(this.maskTokens.slice(0, take)).run(changed, control).fold(function(masked) {
        selection2 = _this.adjustPosition(masked, selection2);
        value2 = masked.concat(unchanged).join("");
      });
      return {
        selection: selection2,
        value: value2
      };
    };
    MaskingService3.prototype.adjustPosition = function(input, selection2) {
      var caretChar = input[selection2];
      var isLiteral = this.maskTokens[selection2].isLiteral(caretChar);
      if (!isLiteral && caretChar !== this.prompt) {
        return selection2 + 1;
      }
      return selection2;
    };
    MaskingService3.prototype.maskInserted = function(input, control, splitPoint) {
      var _this = this;
      var value2 = "";
      var selection2 = splitPoint;
      var changed = input.slice(0, splitPoint);
      sequence(this.unmaskTokens).run(changed, control).chain(function(unmasked) {
        selection2 = unmasked.join("").length;
        var unchanged = control.slice(selection2);
        return sequence(_this.maskTokens).run(unmasked.join("") + unchanged, control);
      }).fold(function(masked) {
        value2 = masked.join("");
      });
      return {
        selection: selection2,
        value: value2
      };
    };
    Object.defineProperty(MaskingService3.prototype, "maskTokenCreator", {
      get: function() {
        var _a5 = this, prompt2 = _a5.prompt, promptPlaceholder2 = _a5.promptPlaceholder;
        return {
          literal: function(rule) {
            return literal(rule);
          },
          mask: function(rule) {
            return mask({ prompt: prompt2, promptPlaceholder: promptPlaceholder2 })(rule);
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MaskingService3.prototype, "unmaskTokenCreator", {
      get: function() {
        var _this = this;
        return {
          literal: function(rule) {
            return unliteral(rule);
          },
          mask: function(rule) {
            return unmask(_this.prompt)(rule);
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MaskingService3.prototype, "rawTokenCreator", {
      get: function() {
        var _a5 = this, prompt2 = _a5.prompt, promptPlaceholder2 = _a5.promptPlaceholder, includeLiterals2 = _a5.includeLiterals;
        return {
          literal: function(_) {
            return rawLiteral(includeLiterals2);
          },
          mask: function(_) {
            return rawMask({ prompt: prompt2, promptPlaceholder: promptPlaceholder2 });
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MaskingService3.prototype, "validationTokenCreator", {
      get: function() {
        var prompt2 = this.prompt;
        return {
          literal: function(_) {
            return rawLiteral(false);
          },
          mask: function(_) {
            return rawMask({ prompt: prompt2, promptPlaceholder: "" });
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MaskingService3.prototype.tokenize = function() {
      var _this = this;
      greedy(token(this.rules, this.maskTokenCreator)).run(this.mask).fold(function(tokens, _) {
        _this.maskTokens = tokens;
      });
      greedy(token(this.rules, this.unmaskTokenCreator)).run(this.mask).fold(function(tokens, _) {
        _this.unmaskTokens = tokens;
      });
      greedy(token(this.rules, this.rawTokenCreator)).run(this.mask).fold(function(tokens, _) {
        _this.rawTokens = tokens;
      });
      greedy(token(this.rules, this.validationTokenCreator)).run(this.mask).fold(function(tokens, _) {
        _this.validationTokens = tokens;
      });
    };
    return MaskingService3;
  }()
);

// node_modules/@progress/kendo-vue-inputs/dist/es/maskedtextbox/utils.js
var defaultRules = {
  "#": /[\d\s\+\-]/,
  "&": /[\S]/,
  "0": /[\d]/,
  "9": /[\d\s]/,
  "?": /[a-zA-Z\s]/,
  "A": /[a-zA-Z0-9]/,
  "C": /./,
  "L": /[a-zA-Z]/,
  "a": /[a-zA-Z0-9\s]/
};
var returnFalse = function() {
  return false;
};
var maskingChanged = function(prev, next) {
  return prev.includeLiterals !== next.includeLiterals || prev.mask !== next.mask || prev.prompt !== next.prompt || prev.promptPlaceholder !== next.promptPlaceholder || !sameRules(prev.rules, next.rules);
};
var sameRules = function(rules1, rules2) {
  if (!!rules1 !== !!rules2) {
    return false;
  }
  if (rules1 === rules2 || (!rules1 || !rules2)) {
    return true;
  }
  var same = true;
  for (var key in rules1) {
    if (rules1[key] !== rules2[key]) {
      same = false;
      break;
    }
  }
  if (same) {
    for (var key in rules2) {
      if (!rules1.hasOwnProperty(key)) {
        same = false;
        break;
      }
    }
  }
  return same;
};

// node_modules/@progress/kendo-vue-inputs/dist/es/maskedtextbox/MaskedTextBox.js
var allVue33 = vue_runtime_esm_bundler_exports;
var gh33 = allVue33.h;
var isV333 = allVue33.version && allVue33.version[0] === "3";
var ref10 = allVue33.ref;
var MaskedTextBoxVue2 = {
  model: {
    event: "changemodel"
  },
  // @ts-ignore
  emits: ["change", "focus", "blur", "update:modelValue", "update:modelRawValue", "changemodel"],
  props: {
    type: {
      type: String,
      default: "text"
    },
    modelValue: String,
    modelRawValue: String,
    value: String,
    defaultValue: String,
    placeholder: String,
    title: String,
    dir: String,
    id: String,
    ariaLabelledBy: String,
    ariaDescribedBy: String,
    tabIndex: Number,
    accessKey: String,
    disabled: Boolean,
    readonly: Boolean,
    size: {
      type: String,
      default: "medium",
      validator: function validator18(value2) {
        return [null, "small", "medium", "large"].includes(value2);
      }
    },
    rounded: {
      type: String,
      default: "medium",
      validator: function validator19(value2) {
        return [null, "small", "medium", "large", "full"].includes(value2);
      }
    },
    fillMode: {
      type: String,
      default: "solid",
      validator: function validator20(value2) {
        return [null, "solid", "flat", "outline"].includes(value2);
      }
    },
    prompt: {
      type: String,
      default: "_"
    },
    promptPlaceholder: {
      type: String,
      default: " "
    },
    includeLiterals: {
      type: Boolean,
      default: false
    },
    maskValidation: {
      type: Boolean,
      default: true
    },
    mask: String,
    rules: {
      type: Object,
      default: function _default12() {
        return defaultRules;
      }
    },
    selection: Object,
    name: String,
    label: String,
    validationMessage: String,
    required: {
      type: Boolean,
      default: false
    },
    valid: {
      type: Boolean,
      default: void 0
    },
    validityStyles: {
      type: Boolean,
      default: true
    },
    iconName: String,
    inputPrefix: templateDefinition,
    inputSuffix: templateDefinition,
    showValidationIcon: Boolean,
    showLoadingIcon: Boolean,
    showClearButton: Boolean,
    inputClass: String,
    wrapperClass: String
  },
  data: function data13() {
    return {
      currentValue: void 0,
      currentFocused: false,
      inputValue: void 0,
      currentSelection: [null, null]
    };
  },
  created: function created15() {
    validatePackage(packageMetadata);
    this.hasMounted = false;
    this.valueDuringOnChange = void 0;
    this.inputId = "k-".concat(guid());
    this.service = new MaskingService();
    this.isPasted = false;
  },
  // @ts-ignore
  setup: !isV333 ? void 0 : function() {
    var v3 = !!isV333;
    var inputRef = ref10(null);
    return {
      v3,
      inputRef
    };
  },
  mounted: function mounted10() {
    this.hasMounted = true;
    this.element = this.input = this.v3 ? this.inputRef : this.$refs.input;
    this.updateService();
    this.setValidity();
  },
  watch: {
    currentFocused: function currentFocused(_, oldValue) {
      this.prevCurrentFocused = oldValue;
    },
    selection: function selection(_, oldValue) {
      this.prevSelection = oldValue;
    },
    includeLiterals: function includeLiterals(_, oldValue) {
      this.prevIncludeLiterals = oldValue;
    },
    mask: function mask2(_, oldValue) {
      this.prevMask = oldValue;
    },
    prompt: function prompt(_, oldValue) {
      this.prevPrompt = oldValue;
    },
    promptPlaceholder: function promptPlaceholder(_, oldValue) {
      this.prevPromptPlaceholder = oldValue;
    },
    rules: function rules(_, oldValue) {
      this.prevRules = oldValue;
    }
  },
  updated: function updated10() {
    if (this.element && this.currentFocused) {
      var _a5 = this.currentSelection, start = _a5[0], end = _a5[1];
      var prevSelection = this.prevSelection;
      var nextSelection = this.$props.selection;
      if (!prevSelection && nextSelection || prevSelection && nextSelection && (prevSelection.start !== nextSelection.start || prevSelection.end !== nextSelection.end)) {
        start = nextSelection.start;
        end = nextSelection.end;
      }
      if (start !== null && end !== null) {
        this.element.setSelectionRange(start, end);
      }
    }
    var prevProps = {
      includeLiterals: this.prevIncludeLiterals,
      mask: this.prevMask,
      prompt: this.prevPrompt,
      promptPlaceholder: this.prevPromptPlaceholder,
      rules: this.prevRules
    };
    if (maskingChanged(prevProps, this.$props)) {
      this.updateService();
    }
    this.setValidity();
  },
  computed: {
    computedRules: {
      get: function get8() {
        return Object.assign({}, defaultRules, this.$props.rules);
      }
    },
    spanClassNames: {
      get: function get9() {
        var _a5;
        var isValid3 = !this.hasMounted || !this.$props.validityStyles || this.validity().valid;
        return _a5 = {
          "k-floating-label-container": true,
          "k-focus": this.currentFocused,
          "k-empty": !this.computedValue(),
          "k-invalid": !isValid3 && isValid3 !== void 0,
          "k-rtl": this.$props.dir === "rtl",
          "k-loading": this.showLoadingIcon
        }, _a5[this.wrapperClass] = this.wrapperClass, _a5;
      }
    },
    wrapperSpanClass: function wrapperSpanClass() {
      var _a5;
      var _b = this.$props, size2 = _b.size, fillMode = _b.fillMode, rounded = _b.rounded;
      var isValid3 = !this.$props.validityStyles || this.validity().valid;
      return _a5 = {
        "k-maskedtextbox": true,
        "k-input": true
      }, _a5["k-input-".concat(kendoThemeMaps.sizeMap[size2] || size2)] = size2, _a5["k-input-".concat(fillMode)] = fillMode, _a5["k-rounded-".concat(kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded, _a5["k-invalid"] = !isValid3, _a5["k-required"] = this.required, _a5["k-disabled"] = this.$props.disabled, _a5["k-loading"] = this.showLoadingIcon, _a5[this.wrapperClass] = this.wrapperClass, _a5;
    },
    inputInnerClass: function inputInnerClass4() {
      var _a5;
      return _a5 = {
        "k-input-inner": true
      }, _a5[this.inputClass] = this.inputClass, _a5;
    }
  },
  methods: {
    focus: function focus9() {
      if (this.input) {
        this.input.focus();
      }
    },
    computedValue: function computedValue4() {
      var value2;
      if (this.valueDuringOnChange !== void 0) {
        value2 = this.valueDuringOnChange;
      } else if (this.$props.value !== void 0) {
        value2 = this.$props.value;
      } else if (this.$props.modelValue !== void 0) {
        value2 = this.$props.modelValue;
      } else if (this.currentValue !== void 0) {
        value2 = this.currentValue;
      } else if (this.$props.defaultValue !== void 0) {
        value2 = this.$props.defaultValue;
      }
      return value2 || "";
    },
    rawValue: function rawValue() {
      return this.service.rawValue(this.computedValue());
    },
    validity: function validity5() {
      var maskedValue = this.computedValue();
      var value2 = this.service.validationValue(maskedValue);
      var customError = this.$props.validationMessage !== void 0;
      var valid = this.$props.valid !== void 0 ? this.$props.valid : (!this.$props.required || !!value2) && (!this.$props.maskValidation || !this.$props.prompt || maskedValue.indexOf(this.$props.prompt) === -1);
      return {
        customError,
        valid,
        valueMissing: !value2
      };
    },
    pasteHandler: function pasteHandler(event) {
      var _a5 = event.target, selectionStart = _a5.selectionStart, selectionEnd = _a5.selectionEnd;
      if (selectionEnd === selectionStart) {
        return;
      }
      this.isPasted = true;
      this.currentSelection = [selectionStart || 0, selectionEnd || 0];
    },
    clearClick: function clearClick4(event) {
      this.triggerOnChange("", event);
    },
    onChangeHandler: function onChangeHandler2(event) {
      var input = event.currentTarget;
      var value2 = this.inputValue = input.value;
      var start = this.currentSelection[0] || 0;
      var end = this.currentSelection[1] || 0;
      if (!this.$props.mask) {
        this.isPasted = false;
        this.currentSelection = [null, null];
        this.triggerOnChange(value2, event);
        return;
      }
      var maskedValue = this.computedValue();
      var result;
      if (this.isPasted) {
        this.isPasted = false;
        var rightPart = maskedValue.length - end;
        var to = value2.length - rightPart;
        result = this.service.maskInRange(value2.slice(start, to), maskedValue, start, end);
      } else {
        result = this.service.maskInput(value2, maskedValue, input.selectionStart || 0);
      }
      this.currentSelection = [result.selection, result.selection];
      this.triggerOnChange(result.value, event);
      this.inputValue = void 0;
    },
    focusHandler: function focusHandler(event) {
      if (!this.currentFocused) {
        this.currentFocused = true;
        this.$emit("focus", {
          target: this,
          event
        });
      }
    },
    blurHandler: function blurHandler(event) {
      if (this.currentFocused) {
        this.currentFocused = false;
        this.$emit("blur", {
          target: this,
          event
        });
      }
    },
    triggerOnChange: function triggerOnChange(maskedValue, event) {
      this.currentValue = maskedValue;
      this.valueDuringOnChange = maskedValue;
      this.$emit("change", {
        event,
        selectionStart: this.currentSelection[0],
        selectionEnd: this.currentSelection[1],
        value: this.computedValue(),
        component: this,
        target: {
          name: this.$props.name,
          value: this.computedValue(),
          rawValue: this.rawValue()
        },
        validity: this.validity()
      });
      this.$emit("update:modelValue", this.computedValue());
      this.$emit("update:modelRawValue", this.rawValue());
      this.$emit("changemodel", this.computedValue());
      this.valueDuringOnChange = void 0;
    },
    updateService: function updateService(extra) {
      var config = Object.assign({
        includeLiterals: this.$props.includeLiterals,
        mask: this.$props.mask,
        prompt: this.$props.prompt,
        promptPlaceholder: this.$props.promptPlaceholder,
        rules: this.$props.rules
      }, extra);
      this.service.update(config);
    },
    setValidity: function setValidity5() {
      if (this.element) {
        this.element.setCustomValidity(this.validity().valid ? "" : this.$props.validationMessage || "");
      }
    }
  },
  // @ts-ignore
  render: function render20(createElement) {
    var h = gh33 || createElement;
    var inputId = this.$props.id || this.inputId;
    var _a5 = this.$props, iconName = _a5.iconName, showValidationIcon = _a5.showValidationIcon, showLoadingIcon = _a5.showLoadingIcon, showClearButton = _a5.showClearButton;
    var isValid3 = !this.$props.validityStyles || this.validity().valid;
    var newValue = this.computedValue();
    var inputValue = this.inputValue;
    var inputPrefixTemplate = templateRendering.call(this, this.$props.inputPrefix, getListeners.call(this));
    var inputSuffixTemplate = templateRendering.call(this, this.$props.inputSuffix, getListeners.call(this));
    var inputPrefix = getTemplate.call(this, {
      h,
      template: inputPrefixTemplate,
      additionalProps: {
        value: newValue,
        valid: isValid3
      }
    });
    var inputSuffix = getTemplate.call(this, {
      h,
      template: inputSuffixTemplate,
      additionalProps: {
        value: newValue,
        valid: isValid3
      }
    });
    var wrapper = h("span", {
      dir: this.$props.dir,
      attrs: this.v3 ? void 0 : {
        dir: this.$props.dir
      },
      "class": this.wrapperSpanClass,
      style: !this.$props.label ? {
        width: this.$props.width
      } : void 0
    }, [iconName && h(Icon, {
      name: iconName,
      attrs: this.v3 ? void 0 : {
        name: iconName
      },
      "class": "k-input-icon"
    }), this.$props.inputPrefix && h("span", {
      "class": "k-input-prefix"
    }, [inputPrefix]), h("input", {
      type: this.$props.type,
      attrs: this.v3 ? void 0 : {
        type: this.$props.type,
        autocomplete: "off",
        autocorrect: "off",
        autocapitalize: "off",
        spellcheck: false,
        id: inputId,
        "aria-labelledby": this.$props.ariaLabelledBy,
        "aria-describedby": this.$props.ariaDescribedBy,
        "aria-disabled": this.$props.disabled,
        name: this.$props.name,
        tabindex: getTabIndex(this.$props.tabIndex, this.$props.disabled, true),
        accesskey: this.$props.accessKey,
        title: this.$props.title,
        disabled: this.$props.disabled || void 0,
        readonly: this.$props.readonly || void 0,
        placeholder: this.$props.placeholder,
        "aria-placeholder": this.$props.placeholder,
        required: this.$props.required
      },
      autocomplete: "off",
      autocorrect: "off",
      autocapitalize: "off",
      spellcheck: false,
      "class": this.inputInnerClass,
      value: this.v3 ? newValue : null,
      domProps: this.v3 ? void 0 : {
        "value": newValue
      },
      id: inputId,
      "aria-labelledby": this.$props.ariaLabelledBy,
      "aria-describedby": this.$props.ariaDescribedBy,
      "aria-disabled": this.$props.disabled,
      name: this.$props.name,
      tabindex: getTabIndex(this.$props.tabIndex, this.$props.disabled, true),
      accesskey: this.$props.accessKey,
      title: this.$props.title,
      disabled: this.$props.disabled || void 0,
      readonly: this.$props.readonly || void 0,
      placeholder: this.$props.placeholder,
      "aria-placeholder": this.$props.placeholder,
      required: this.$props.required,
      ref: setRef(this, "input"),
      onInput: this.onChangeHandler,
      on: this.v3 ? void 0 : {
        "input": this.onChangeHandler,
        "paste": this.pasteHandler,
        "focus": this.focusHandler,
        "blur": this.blurHandler,
        "dragstart": returnFalse,
        "drop": returnFalse
      },
      onPaste: this.pasteHandler,
      onFocus: this.focusHandler,
      onBlur: this.blurHandler,
      onDragstart: returnFalse,
      onDrop: returnFalse
    }), this.$props.inputSuffix && h("span", {
      "class": "k-input-suffix"
    }, [inputSuffix]), showValidationIcon && isValid3 && h(Icon, {
      name: "check",
      attrs: this.v3 ? void 0 : {
        name: "check",
        icon: checkIcon
      },
      icon: checkIcon,
      "class": "k-input-validation-icon"
    }), showValidationIcon && !isValid3 && h(Icon, {
      name: "exclamation-circle",
      attrs: this.v3 ? void 0 : {
        name: "exclamation-circle",
        icon: exclamationCircleIcon
      },
      icon: exclamationCircleIcon,
      "class": "k-input-validation-icon"
    }), showLoadingIcon && h(Icon, {
      name: "loading",
      attrs: this.v3 ? void 0 : {
        name: "loading"
      },
      "class": "k-input-loading-icon"
    }), showClearButton && newValue && h("span", {
      onClick: this.clearClick,
      on: this.v3 ? void 0 : {
        "click": this.clearClick
      },
      "class": "k-clear-value"
    }, [h(Icon, {
      name: "x",
      attrs: this.v3 ? void 0 : {
        name: "x",
        icon: xIcon
      },
      icon: xIcon
    })])]);
    return this.$props.label ? h("span", {
      "class": this.spanClassNames,
      dir: this.$props.dir,
      attrs: this.v3 ? void 0 : {
        dir: this.$props.dir
      }
    }, [wrapper, this.$props.label ? inputId ? h("label", {
      "for": inputId,
      attrs: this.v3 ? void 0 : {
        "for": inputId
      },
      "class": "k-label"
    }, [this.$props.label]) : h("span", {
      "class": "k-label"
    }, [this.$props.label]) : null]) : wrapper;
  }
};
var MaskedTextBox = MaskedTextBoxVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/slider/SliderLabel.js
var __assign7 = function() {
  __assign7 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return __assign7.apply(this, arguments);
};
var allVue34 = vue_runtime_esm_bundler_exports;
var gh34 = allVue34.h;
var isV334 = allVue34.version && allVue34.version[0] === "3";
var ref11 = allVue34.ref;
var SLIDER_LABEL_ATTRIBUTE = "data-slider-label";
var SliderLabelVue2 = {
  name: "KendoSliderLabel",
  // @ts-ignore
  emits: {
    click: null
  },
  props: {
    position: Number,
    title: String,
    vertical: Boolean
  },
  data: function data14() {
    return {
      currentDir: "ltr"
    };
  },
  inject: ["kendoMax", "kendoMin", "kendoVertical"],
  mounted: function mounted11() {
    this.sliderLabelRef = this.$refs.sliderLabelRef;
    if (!this.currentDir && window && this.$el) {
      var direction = window.getComputedStyle(this.$el).direction;
      if (direction) {
        this.currentDir = direction;
      }
    }
  },
  // @ts-ignore
  setup: !isV334 ? void 0 : function() {
    var v3 = !!isV334;
    return {
      v3
    };
  },
  // @ts-ignore
  render: function render21(createElement) {
    var _a5;
    var h = gh34 || createElement;
    var dir = this.currentDir;
    var defaultSlot = getDefaultSlots(this);
    var position2 = 100 * (this.$props.position - this.kendoMin) / (this.kendoMax - this.kendoMin);
    var vertical = this.kendoVertical;
    var style = vertical ? {
      bottom: "".concat(position2, "%")
    } : (_a5 = {}, _a5[dir === "rtl" ? "right" : "left"] = "".concat(position2, "%"), _a5);
    return h("li", {
      ref: "sliderLabelRef",
      "class": classNames("k-tick", "k-tick-large", vertical ? "k-tick-vertical" : "k-tick-horizontal"),
      title: this.$props.title,
      attrs: this.v3 ? void 0 : {
        title: this.$props.title
      },
      style: __assign7({
        zIndex: 1,
        position: "absolute"
      }, style)
    }, [h("span", {
      "data-slider-label": true,
      attrs: this.v3 ? void 0 : {
        "data-slider-label": true
      },
      "class": "k-label",
      onClick: this.onClick,
      on: this.v3 ? void 0 : {
        "click": this.onClick
      }
    }, [defaultSlot])]);
  },
  methods: {
    onClick: function onClick(event) {
      this.$emit("click", event);
    }
  }
};
var SliderLabel = SliderLabelVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/slider/Slider.js
var allVue35 = vue_runtime_esm_bundler_exports;
var gh35 = allVue35.h;
var isV335 = allVue35.version && allVue35.version[0] === "3";
var ref12 = allVue35.ref;
var inject4 = allVue35.inject;
var SliderVue2 = {
  name: "KendoSlider",
  model: {
    event: "changemodel"
  },
  // @ts-ignore
  emits: {
    "changemodel": null,
    "update:modelValue": null,
    "change": null,
    "blur": null,
    "focus": null
  },
  props: {
    modelValue: {
      type: Number,
      default: void 0
    },
    defaultValue: {
      type: Number,
      default: void 0
    },
    name: String,
    buttons: Boolean,
    tabIndex: Number,
    disabled: Boolean,
    dir: String,
    step: Number,
    min: {
      type: Number,
      required: true
    },
    max: {
      type: Number,
      required: true
    },
    value: Number,
    vertical: Boolean,
    id: String,
    ariaLabelledBy: String,
    ariaDescribedBy: String
  },
  provide: function provide() {
    return {
      kendoMin: this.$props.min,
      kendoMax: this.$props.max,
      kendoVertical: this.$props.vertical
    };
  },
  inject: {
    kendoLocalizationService: {
      default: null
    }
  },
  data: function data15() {
    return {
      currentValue: void 0,
      currentFocused: false,
      currentDir: "ltr"
    };
  },
  computed: {
    computedValue: function computedValue5() {
      var value2 = this.$props.value !== void 0 ? this.$props.value : this.currentValue;
      var _a5 = this.$props, min = _a5.min, max = _a5.max;
      return value2 === void 0 ? value2 : Math.min(Math.max(value2, min), max);
    },
    sliderTrack: function sliderTrack() {
      return this._sliderTrack;
    }
  },
  created: function created16() {
    validatePackage(packageMetadata);
    if (this.$props.value !== void 0) {
      this.$data.currentValue = this.$props.value;
    } else if (this.$props.modelValue !== void 0) {
      this.$data.currentValue = this.$props.modelValue;
    } else if (this.$props.defaultValue !== void 0) {
      this.$data.currentValue = this.$props.defaultValue;
    } else {
      this.$data.currentValue = this.$props.min;
    }
    this.currentFocused = false;
    this.currentDir = this.$props.dir;
  },
  mounted: function mounted12() {
    this._sliderTrack = this.$refs.sliderTrack;
    if (this.$el) {
      this.draggable = this.$refs.draggable;
    }
    if (!this.currentDir && window && this.$el) {
      var direction = window.getComputedStyle(this.$el).direction;
      if (direction) {
        this.currentDir = direction;
      }
    }
  },
  updated: function updated11() {
    if (this.$el) {
      this.draggable = this.$refs.draggable;
    }
  },
  // @ts-ignore
  setup: !isV335 ? void 0 : function() {
    var v3 = !!isV335;
    var inputRef = ref12(null);
    var kendoLocalizationService = inject4("kendoLocalizationService", {});
    return {
      v3,
      inputRef,
      kendoLocalizationService
    };
  },
  render: function render22(createElement) {
    var _this = this;
    var _a5;
    var h = gh35 || createElement;
    var lS = provideLocalizationService(this);
    var percentValue = (this.computedValue - this.$props.min) / (this.$props.max - this.$props.min) * 100;
    var defaultSlot = getDefaultSlots(this);
    var vertical = this.$props.vertical;
    var increaseSvgArrow = this.currentDir === "rtl" ? vertical ? caretAltUpIcon : caretAltLeftIcon : vertical ? caretAltUpIcon : caretAltRightIcon;
    var decreaseSvgArrow = this.currentDir === "rtl" ? vertical ? caretAltDownIcon : caretAltRightIcon : vertical ? caretAltDownIcon : caretAltLeftIcon;
    var increaseFontArrow = this.currentDir === "rtl" ? vertical ? "caret-alt-up" : "caret-alt-left" : vertical ? "caret-alt-up" : "caret-alt-right";
    var decreaseFontArrow = this.currentDir === "rtl" ? vertical ? "caret-alt-down" : "caret-alt-right" : vertical ? "caret-alt-down" : "caret-alt-left";
    return h("div", {
      dir: this.currentDir,
      attrs: this.v3 ? void 0 : {
        dir: this.currentDir,
        id: this.$props.id
      },
      id: this.$props.id,
      style: this.$props.style,
      onFocus: this.onFocus,
      on: this.v3 ? void 0 : {
        "focus": this.onFocus,
        "blur": this.onBlur,
        "keydown": this.onKeyDown
      },
      onBlur: this.onBlur,
      onKeydown: this.onKeyDown,
      "class": classNames("k-slider", {
        "k-focus": this.currentFocused,
        "k-disabled": this.$props.disabled,
        "k-slider-horizontal": !this.$props.vertical,
        "k-slider-vertical": this.$props.vertical
      }, this.$props.className)
    }, [
      this.$props.buttons && // @ts-ignore
      h(Button, {
        type: "button",
        attrs: this.v3 ? void 0 : {
          type: "button",
          tabindex: -1,
          icon: decreaseFontArrow,
          svgIcon: decreaseSvgArrow,
          rounded: "full",
          title: lS.toLanguageString(sliderDecreaseValue, messages2[sliderDecreaseValue])
        },
        tabindex: -1,
        icon: decreaseFontArrow,
        svgIcon: decreaseSvgArrow,
        style: {
          position: "relative"
        },
        rounded: "full",
        "class": "k-button-decrease",
        title: lS.toLanguageString(sliderDecreaseValue, messages2[sliderDecreaseValue]),
        onClick: this.decrement,
        on: this.v3 ? void 0 : {
          "click": this.decrement
        }
      }),
      // @ts-ignore  function children
      h(Draggable, {
        onDrag: this.dragOver,
        on: this.v3 ? void 0 : {
          "drag": this.dragOver,
          "press": this.dragStart
        },
        onPress: this.dragStart,
        ref: "draggable"
      }, this.v3 ? function() {
        return [h("div", {
          "class": "k-slider-track-wrap",
          style: {
            touchAction: "none"
          }
        }, [defaultSlot && h("ul", {
          "class": "k-reset k-slider-items"
        }, [defaultSlot]), h("div", {
          "class": "k-slider-track",
          ref: "sliderTrack"
        }, [h("div", {
          "class": "k-slider-selection",
          style: _this.$props.vertical ? {
            height: percentValue + "%"
          } : {
            width: percentValue + "%"
          }
        }), h("span", {
          "class": "k-draghandle",
          role: "slider",
          attrs: _this.v3 ? void 0 : {
            role: "slider",
            tabIndex: "0",
            "aria-valuenow": _this.computedValue,
            "aria-valuemin": _this.$props.min,
            "aria-valuemax": _this.$props.max,
            "aria-valuetext": _this.computedValue.toString(),
            "aria-disabled": _this.$props.disabled ? "true" : void 0,
            title: lS.toLanguageString(sliderDragTitle, messages2[sliderDragTitle])
          },
          tabIndex: "0",
          "aria-valuenow": _this.computedValue,
          "aria-valuemin": _this.$props.min,
          "aria-valuemax": _this.$props.max,
          "aria-valuetext": _this.computedValue.toString(),
          "aria-disabled": _this.$props.disabled ? "true" : void 0,
          title: lS.toLanguageString(sliderDragTitle, messages2[sliderDragTitle]),
          style: _this.$props.vertical ? {
            bottom: percentValue + "%",
            zIndex: 1
          } : (_a5 = {}, _a5[_this.currentDir === "rtl" ? "right" : "left"] = percentValue + "%", _a5.zIndex = 1, _a5)
        })])])];
      } : [h("div", {
        "class": "k-slider-track-wrap",
        style: {
          touchAction: "none"
        }
      }, [defaultSlot && h("ul", {
        "class": "k-reset k-slider-items"
      }, [defaultSlot]), h("div", {
        "class": "k-slider-track",
        ref: "sliderTrack"
      }, [h("div", {
        "class": "k-slider-selection",
        style: _this.$props.vertical ? {
          height: percentValue + "%"
        } : {
          width: percentValue + "%"
        }
      }), h("span", {
        "class": "k-draghandle",
        role: "slider",
        attrs: _this.v3 ? void 0 : {
          role: "slider",
          tabIndex: "0",
          "aria-valuenow": _this.computedValue,
          "aria-valuemin": _this.$props.min,
          "aria-valuemax": _this.$props.max,
          "aria-valuetext": _this.computedValue.toString(),
          "aria-disabled": _this.$props.disabled ? "true" : void 0,
          title: lS.toLanguageString(sliderDragTitle, messages2[sliderDragTitle])
        },
        tabIndex: "0",
        "aria-valuenow": _this.computedValue,
        "aria-valuemin": _this.$props.min,
        "aria-valuemax": _this.$props.max,
        "aria-valuetext": _this.computedValue.toString(),
        "aria-disabled": _this.$props.disabled ? "true" : void 0,
        title: lS.toLanguageString(sliderDragTitle, messages2[sliderDragTitle]),
        style: _this.$props.vertical ? {
          bottom: percentValue + "%",
          zIndex: 1
        } : (_a5 = {}, _a5[_this.currentDir === "rtl" ? "right" : "left"] = percentValue + "%", _a5.zIndex = 1, _a5)
      })])])]),
      this.$props.buttons && // @ts-ignore
      h(Button, {
        type: "button",
        attrs: this.v3 ? void 0 : {
          type: "button",
          tabindex: -1,
          icon: increaseFontArrow,
          svgIcon: increaseSvgArrow,
          rounded: "full",
          title: lS.toLanguageString(sliderIncreaseValue, messages2[sliderIncreaseValue])
        },
        tabindex: -1,
        icon: increaseFontArrow,
        svgIcon: increaseSvgArrow,
        rounded: "full",
        style: {
          position: "relative"
        },
        "class": "k-button-increase",
        title: lS.toLanguageString(sliderIncreaseValue, messages2[sliderIncreaseValue]),
        onClick: this.increment,
        on: this.v3 ? void 0 : {
          "click": this.increment
        }
      })
    ]);
  },
  methods: {
    focus: function focus10() {
      if (this.$el) {
        this.$el.focus();
      }
    },
    isLabel: function isLabel(target) {
      var currentTarget = target;
      while (currentTarget) {
        if (Boolean(currentTarget.getAttribute(SLIDER_LABEL_ATTRIBUTE))) {
          return true;
        }
        currentTarget = currentTarget.parentElement;
      }
      return false;
    },
    onFocus: function onFocus5(event) {
      this.currentFocused = true;
      this.$emit("focus", event);
    },
    onBlur: function onBlur5(event) {
      this.currentFocused = false;
      this.$emit("blur", event);
    },
    onKeyDown: function onKeyDown3(e) {
      var newValue = void 0;
      if (e.keyCode === Keys.left || e.keyCode === Keys.down) {
        newValue = this.currentValue - (this.$props.step || 0);
      } else if (e.keyCode === Keys.right || e.keyCode === Keys.up) {
        newValue = this.currentValue + (this.$props.step || 0);
      } else if (e.keyCode === Keys.home) {
        newValue = this.$props.min;
      } else if (e.keyCode === Keys.end) {
        newValue = this.$props.max;
      }
      if (newValue !== void 0) {
        e.preventDefault();
        this.change(e, newValue);
      }
    },
    decrement: function decrement(e) {
      e.preventDefault();
      this.change(e, this.currentValue - (this.$props.step || 0));
    },
    increment: function increment(e) {
      e.preventDefault();
      this.change(e, this.currentValue + (this.$props.step || 0));
    },
    dragStart: function dragStart(e) {
      if (!this.isLabel(e.originalEvent.target)) {
        if (e.isTouch) {
          e.originalEvent.preventDefault();
        }
        this.drag(e);
      }
    },
    dragOver: function dragOver(e) {
      e.originalEvent.preventDefault();
      this.drag(e);
    },
    drag: function drag(e) {
      var computed = this.draggable.element.getBoundingClientRect();
      var distance = this.$props.vertical ? computed.bottom - e.clientY : this.currentDir === "rtl" ? computed.right - e.clientX : e.clientX - computed.left;
      var size2 = this.$props.vertical ? computed.height : computed.width;
      var percentage = distance / size2;
      this.change(e, this.$props.min + percentage * (this.$props.max - this.$props.min));
    },
    change: function change(e, value2) {
      value2 = Math.min(Math.max(value2, this.$props.min), this.$props.max);
      this.currentValue = value2;
      this.$emit("changemodel", value2);
      this.$emit("update:modelValue", value2);
      this.$emit("change", {
        event: e,
        value: value2,
        component: this,
        target: {
          name: this.$props.name,
          value: value2
        }
      });
    }
  }
};
var Slider = SliderVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/range-slider/range-raducer.js
var __assign8 = function() {
  __assign8 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return __assign8.apply(this, arguments);
};
var RANGE_ACTION;
(function(RANGE_ACTION2) {
  RANGE_ACTION2["start"] = "start";
  RANGE_ACTION2["end"] = "end";
  RANGE_ACTION2["min"] = "min";
  RANGE_ACTION2["max"] = "max";
  RANGE_ACTION2["increase"] = "increase";
  RANGE_ACTION2["decrease"] = "decrease";
})(RANGE_ACTION || (RANGE_ACTION = {}));
var rangeReducer = function rangeReducer2(state, action) {
  var newState;
  var newValue;
  switch (action.type) {
    case RANGE_ACTION.start:
      if (action.payload === void 0) {
        return state;
      }
      newState = {
        start: action.payload > state.end ? state.end : Math.max(action.payload, action.min),
        end: state.end
      };
      break;
    case RANGE_ACTION.end:
      if (action.payload === void 0) {
        return state;
      }
      newState = {
        start: state.start,
        end: action.payload < state.start ? state.start : Math.min(action.payload, action.max)
      };
      break;
    case RANGE_ACTION.min:
      if (action.key === "start") {
        newState = __assign8(__assign8({}, state), {
          start: action.min
        });
      } else {
        newState = __assign8(__assign8({}, state), {
          end: Math.max(action.min, state.start)
        });
      }
      break;
    case RANGE_ACTION.max:
      if (action.key === "start") {
        newState = __assign8(__assign8({}, state), {
          start: Math.min(action.max, state.end)
        });
      } else {
        newState = __assign8(__assign8({}, state), {
          end: action.max
        });
      }
      break;
    case RANGE_ACTION.increase:
      if (action.step === void 0 || action.key === void 0) {
        return state;
      }
      newValue = state[action.key] + action.step;
      if (action.key === "start") {
        if (newValue < action.min) {
          newState = __assign8(__assign8({}, state), {
            start: action.min
          });
        } else {
          newState = __assign8(__assign8({}, state), {
            start: Math.min(newValue, state.end)
          });
        }
      } else {
        if (newValue > action.max) {
          newState = __assign8(__assign8({}, state), {
            end: action.max
          });
        } else {
          newState = __assign8(__assign8({}, state), {
            end: Math.max(newValue, state.start)
          });
        }
      }
      break;
    case RANGE_ACTION.decrease:
      if (action.step === void 0 || action.key === void 0) {
        return state;
      }
      newValue = state[action.key] - action.step;
      if (action.key === "start") {
        if (newValue < action.min) {
          newState = __assign8(__assign8({}, state), {
            start: action.min
          });
        } else {
          newState = __assign8(__assign8({}, state), {
            start: Math.min(newValue, state.end)
          });
        }
      } else {
        if (newValue > action.max) {
          newState = __assign8(__assign8({}, state), {
            end: action.max
          });
        } else {
          newState = __assign8(__assign8({}, state), {
            end: Math.max(newValue, state.start)
          });
        }
      }
      break;
    default:
      newState = state;
      break;
  }
  return newState;
};

// node_modules/@progress/kendo-vue-inputs/dist/es/range-slider/RangeSlider.js
var __assign9 = function() {
  __assign9 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return __assign9.apply(this, arguments);
};
var allVue36 = vue_runtime_esm_bundler_exports;
var gh36 = allVue36.h;
var isV336 = allVue36.version && allVue36.version[0] === "3";
var ref13 = allVue36.ref;
var inject5 = allVue36.inject;
var RangeSliderVue2 = {
  name: "KendoRangeSlider",
  model: {
    event: "changemodel"
  },
  props: {
    id: String,
    value: {
      type: Object,
      validator: function validator21(value2) {
        return value2.start <= value2.end;
      }
    },
    defaultValue: {
      type: Object,
      default: function _default13() {
        return {
          start: 0,
          end: 0
        };
      },
      validator: function validator22(value2) {
        return value2.start <= value2.end;
      }
    },
    step: {
      type: Number,
      default: 1
    },
    min: {
      type: Number,
      required: true
    },
    max: {
      type: Number,
      required: true
    },
    vertical: Boolean,
    disabled: Boolean,
    dir: {
      type: String,
      default: "ltr",
      validator: function validator23(value2) {
        return [null, "ltr", "rtl"].includes(value2);
      }
    },
    startTabIndex: Number,
    endTabIndex: Number
  },
  provide: function provide2() {
    return {
      kendoMin: this.$props.min,
      kendoMax: this.$props.max,
      kendoVertical: this.$props.vertical
    };
  },
  inject: {
    kendoLocalizationService: {
      default: null
    }
  },
  created: function created17() {
    validatePackage(packageMetadata);
  },
  data: function data16() {
    return {
      currentValue: this.defaultValue,
      currentDrag: "",
      currentDir: "ltr"
    };
  },
  computed: {
    computedValue: function computedValue6() {
      return this.$props.value !== void 0 ? this.$props.value : this.currentValue;
    },
    percentStart: function percentStart() {
      return (this.computedValue.start - this.min) / (this.max - this.min) * 100;
    },
    percentEnd: function percentEnd() {
      return (this.computedValue.end - this.min) / (this.max - this.min) * 100;
    },
    sliderItemsStyle: function sliderItemsStyle() {
      return this.vertical ? {
        paddingTop: 0,
        height: "100%"
      } : {};
    },
    trackStyles: function trackStyles() {
      return this.vertical ? {
        marginTop: "0.5rem",
        marginBottom: "0.5rem"
      } : {
        marginLeft: "0.5rem",
        marginRight: "0.5rem"
      };
    }
  },
  mounted: function mounted13() {
    this.sliderRef = this.$refs.sliderRef;
    this.sliderSelectionRef = this.$refs.sliderSelectionRef;
    this.startHandle = this.$refs.startHandle;
    this.endHandle = this.$refs.endHandle;
    this.sliderTrackRef = this.$refs.sliderTrackRef;
    this.sliderTrackWrapRef = this.$refs.sliderTrackWrapRef;
    if (!this.currentDir && window && this.$el) {
      var direction = window.getComputedStyle(this.$el).direction;
      if (direction) {
        this.currentDir = direction;
      }
    }
  },
  // @ts-ignore
  setup: !isV336 ? void 0 : function() {
    var v3 = !!isV336;
    var inputRef = ref13(null);
    var kendoLocalizationService = inject5("kendoLocalizationService", {});
    return {
      v3,
      inputRef,
      kendoLocalizationService
    };
  },
  render: function render23(createElement) {
    var _this = this;
    var _a5, _b;
    var h = gh36 || createElement;
    var localization = provideLocalizationService(this);
    var defaultSlot = getDefaultSlots(this);
    var _c = this.$props, id = _c.id, dir = _c.dir;
    return h("div", {
      id,
      attrs: this.v3 ? void 0 : {
        id,
        dir: this.currentDir,
        "aria-labelledby": this.$props.ariaLabelledBy,
        "aria-describedby": this.$props.ariaDescribedBy
      },
      dir: this.currentDir,
      "class": classNames("k-slider", {
        "k-rtl": this.currentDir === "rtl",
        "k-disabled": this.$props.disabled,
        "k-slider-vertical": this.$props.vertical,
        "k-slider-horizontal": !this.$props.vertical
      }, this.$props.class),
      "aria-labelledby": this.$props.ariaLabelledBy,
      "aria-describedby": this.$props.ariaDescribedBy
    }, [
      // @ts-ignore  function children
      h(Draggable, {
        onDrag: this.handleTrackDrag,
        on: this.v3 ? void 0 : {
          "drag": this.handleTrackDrag,
          "press": this.handleTrackPress,
          "release": this.handleTrackRelease
        },
        onPress: this.handleTrackPress,
        onRelease: this.handleTrackRelease,
        ref: "draggable"
      }, this.v3 ? function() {
        return [h("div", {
          ref: "sliderTrackWrapRef",
          "class": "k-slider-track-wrap",
          style: __assign9({
            flexGrow: 1,
            position: "relative",
            touchAction: "none"
          }, _this.trackStyles)
        }, [defaultSlot && h("ul", {
          "class": "k-reset k-slider-items",
          style: __assign9({}, _this.sliderItemsStyle)
        }, [defaultSlot]), h("div", {
          ref: "sliderTrackRef",
          "class": "k-slider-track",
          style: _this.$props.vertical ? {
            bottom: 0,
            height: "100%"
          } : (_a5 = {}, _a5[_this.currentDir === "rtl" ? "right" : "left"] = 0, _a5.width = "100%", _a5)
        }, [_this.percentStart !== null && _this.percentEnd !== null && h("div", {
          "data-selection": true,
          attrs: _this.v3 ? void 0 : {
            "data-selection": true,
            title: "".concat(_this.computedValue.start, " - ").concat(_this.computedValue.end)
          },
          ref: "sliderSelectionRef",
          title: "".concat(_this.computedValue.start, " - ").concat(_this.computedValue.end),
          "class": "k-slider-selection",
          style: _this.vertical ? {
            height: _this.percentEnd - _this.percentStart + "%",
            bottom: _this.percentStart + "%"
          } : (_b = {}, _b[_this.currentDir === "rtl" ? "right" : "left"] = _this.percentStart + "%", _b.width = _this.percentEnd - _this.percentStart + "%", _b)
        }), h("span", {
          ref: "startHandle",
          role: "slider",
          attrs: _this.v3 ? void 0 : {
            role: "slider",
            tabindex: getTabIndex(_this.startTabIndex, _this.$props.disabled, void 0),
            "aria-valuemin": _this.min,
            "aria-valuemax": Math.max(_this.max, _this.computedValue.end),
            "aria-valuenow": _this.computedValue.start,
            "aria-disabled": _this.disabled ? "true" : void 0,
            "aria-valuetext": _this.computedValue.start,
            title: localization.toLanguageString(sliderDragTitle, messages2[sliderDragTitle])
          },
          tabindex: getTabIndex(_this.startTabIndex, _this.$props.disabled, void 0),
          "aria-valuemin": _this.min,
          "aria-valuemax": Math.max(_this.max, _this.computedValue.end),
          "aria-valuenow": _this.computedValue.start,
          "aria-disabled": _this.disabled ? "true" : void 0,
          "aria-valuetext": _this.computedValue.start,
          "class": "k-draghandle",
          title: localization.toLanguageString(sliderDragTitle, messages2[sliderDragTitle]),
          style: _this.vertical ? {
            bottom: "calc(" + _this.percentStart + "%)",
            zIndex: 1
          } : _this.currentDir === "rtl" ? {
            right: "calc(" + _this.percentStart + "% - 13px)",
            zIndex: 1
          } : {
            left: "calc(" + _this.percentStart + "%)",
            zIndex: 1
          },
          onKeydown: _this.handleStartKeyDown,
          on: _this.v3 ? void 0 : {
            "keydown": _this.handleStartKeyDown
          }
        }), h("span", {
          ref: "endHandle",
          role: "slider",
          attrs: _this.v3 ? void 0 : {
            role: "slider",
            tabindex: getTabIndex(_this.endTabIndex, _this.$props.disabled, void 0),
            "aria-valuemin": Math.min(_this.min, _this.computedValue.start),
            "aria-valuemax": _this.max,
            "aria-valuenow": _this.computedValue.end,
            "aria-disabled": _this.disabled ? "true" : void 0,
            "aria-valuetext": _this.computedValue.end,
            title: localization.toLanguageString(sliderDragTitle, messages2[sliderDragTitle])
          },
          tabindex: getTabIndex(_this.endTabIndex, _this.$props.disabled, void 0),
          "aria-valuemin": Math.min(_this.min, _this.computedValue.start),
          "aria-valuemax": _this.max,
          "aria-valuenow": _this.computedValue.end,
          "aria-disabled": _this.disabled ? "true" : void 0,
          "aria-valuetext": _this.computedValue.end,
          "class": "k-draghandle",
          title: localization.toLanguageString(sliderDragTitle, messages2[sliderDragTitle]),
          style: _this.vertical ? {
            bottom: "calc(" + _this.percentEnd + "%)",
            zIndex: 1
          } : _this.currentDir === "rtl" ? {
            right: "calc(" + _this.percentEnd + "% - 13px)",
            zIndex: 1
          } : {
            left: "calc(" + _this.percentEnd + "%)",
            zIndex: 1
          },
          onKeydown: _this.handleEndKeyDown,
          on: _this.v3 ? void 0 : {
            "keydown": _this.handleEndKeyDown
          }
        })])])];
      } : [h("div", {
        ref: "sliderTrackWrapRef",
        "class": "k-slider-track-wrap",
        style: __assign9({
          flexGrow: 1,
          position: "relative",
          touchAction: "none"
        }, _this.trackStyles)
      }, [defaultSlot && h("ul", {
        "class": "k-reset k-slider-items",
        style: __assign9({}, _this.sliderItemsStyle)
      }, [defaultSlot]), h("div", {
        ref: "sliderTrackRef",
        "class": "k-slider-track",
        style: _this.$props.vertical ? {
          bottom: 0,
          height: "100%"
        } : (_a5 = {}, _a5[_this.currentDir === "rtl" ? "right" : "left"] = 0, _a5.width = "100%", _a5)
      }, [_this.percentStart !== null && _this.percentEnd !== null && h("div", {
        "data-selection": true,
        attrs: _this.v3 ? void 0 : {
          "data-selection": true,
          title: "".concat(_this.computedValue.start, " - ").concat(_this.computedValue.end)
        },
        ref: "sliderSelectionRef",
        title: "".concat(_this.computedValue.start, " - ").concat(_this.computedValue.end),
        "class": "k-slider-selection",
        style: _this.vertical ? {
          height: _this.percentEnd - _this.percentStart + "%",
          bottom: _this.percentStart + "%"
        } : (_b = {}, _b[_this.currentDir === "rtl" ? "right" : "left"] = _this.percentStart + "%", _b.width = _this.percentEnd - _this.percentStart + "%", _b)
      }), h("span", {
        ref: "startHandle",
        role: "slider",
        attrs: _this.v3 ? void 0 : {
          role: "slider",
          tabindex: getTabIndex(_this.startTabIndex, _this.$props.disabled, void 0),
          "aria-valuemin": _this.min,
          "aria-valuemax": Math.max(_this.max, _this.computedValue.end),
          "aria-valuenow": _this.computedValue.start,
          "aria-disabled": _this.disabled ? "true" : void 0,
          "aria-valuetext": _this.computedValue.start,
          title: localization.toLanguageString(sliderDragTitle, messages2[sliderDragTitle])
        },
        tabindex: getTabIndex(_this.startTabIndex, _this.$props.disabled, void 0),
        "aria-valuemin": _this.min,
        "aria-valuemax": Math.max(_this.max, _this.computedValue.end),
        "aria-valuenow": _this.computedValue.start,
        "aria-disabled": _this.disabled ? "true" : void 0,
        "aria-valuetext": _this.computedValue.start,
        "class": "k-draghandle",
        title: localization.toLanguageString(sliderDragTitle, messages2[sliderDragTitle]),
        style: _this.vertical ? {
          bottom: "calc(" + _this.percentStart + "%)",
          zIndex: 1
        } : _this.currentDir === "rtl" ? {
          right: "calc(" + _this.percentStart + "% - 13px)",
          zIndex: 1
        } : {
          left: "calc(" + _this.percentStart + "%)",
          zIndex: 1
        },
        onKeydown: _this.handleStartKeyDown,
        on: _this.v3 ? void 0 : {
          "keydown": _this.handleStartKeyDown
        }
      }), h("span", {
        ref: "endHandle",
        role: "slider",
        attrs: _this.v3 ? void 0 : {
          role: "slider",
          tabindex: getTabIndex(_this.endTabIndex, _this.$props.disabled, void 0),
          "aria-valuemin": Math.min(_this.min, _this.computedValue.start),
          "aria-valuemax": _this.max,
          "aria-valuenow": _this.computedValue.end,
          "aria-disabled": _this.disabled ? "true" : void 0,
          "aria-valuetext": _this.computedValue.end,
          title: localization.toLanguageString(sliderDragTitle, messages2[sliderDragTitle])
        },
        tabindex: getTabIndex(_this.endTabIndex, _this.$props.disabled, void 0),
        "aria-valuemin": Math.min(_this.min, _this.computedValue.start),
        "aria-valuemax": _this.max,
        "aria-valuenow": _this.computedValue.end,
        "aria-disabled": _this.disabled ? "true" : void 0,
        "aria-valuetext": _this.computedValue.end,
        "class": "k-draghandle",
        title: localization.toLanguageString(sliderDragTitle, messages2[sliderDragTitle]),
        style: _this.vertical ? {
          bottom: "calc(" + _this.percentEnd + "%)",
          zIndex: 1
        } : _this.currentDir === "rtl" ? {
          right: "calc(" + _this.percentEnd + "% - 13px)",
          zIndex: 1
        } : {
          left: "calc(" + _this.percentEnd + "%)",
          zIndex: 1
        },
        onKeydown: _this.handleEndKeyDown,
        on: _this.v3 ? void 0 : {
          "keydown": _this.handleEndKeyDown
        }
      })])])])
    ]);
  },
  methods: {
    dispatchStateValue: function dispatchStateValue(args) {
      var newState = rangeReducer({
        start: this.computedValue.start,
        end: this.computedValue.end
      }, __assign9(__assign9({}, args), {
        min: this.min,
        max: this.max,
        step: this.step
      }));
      this.currentValue.start = newState.start;
      this.currentValue.end = newState.end;
      this.$emit("change", {
        min: this.min,
        max: this.max,
        step: this.step,
        value: {
          start: newState.start,
          end: newState.end
        }
      });
    },
    focus: function focus11() {
      if (this.startHandle) {
        this.startHandle.focus();
      }
    },
    handleChange: function handleChange3(newValue, event) {
      this.$emit("change", {
        value: newValue,
        //    target: target.current,
        event
      });
    },
    calcNewDistance: function calcNewDistance(event) {
      if (!this.sliderTrackWrapRef) {
        return;
      }
      event.originalEvent.preventDefault();
      var computed = this.sliderTrackWrapRef.getBoundingClientRect();
      var distance = this.$props.vertical ? computed.bottom - event.clientY : this.currentDir === "rtl" ? computed.right - event.clientX : event.clientX - computed.left;
      var size2 = this.$props.vertical ? computed.height : computed.width;
      var percentage = distance / size2;
      var payload = this.min + percentage * (this.max - this.min);
      return payload;
    },
    calcKey: function calcKey(payload) {
      if (payload <= this.computedValue.start) {
        return "start";
      }
      if (payload >= this.computedValue.end) {
        return "end";
      }
      return 2 * payload < this.computedValue.end + this.computedValue.start ? "start" : "end";
    },
    handleStartKeyDown: function handleStartKeyDown(event) {
      switch (event.keyCode) {
        case Keys.right:
          event.preventDefault();
          this.dispatchStateValue({
            type: this.currentDir === "rtl" ? RANGE_ACTION.decrease : RANGE_ACTION.increase,
            key: "start",
            event
          });
          break;
        case Keys.up:
          event.preventDefault();
          this.dispatchStateValue({
            type: RANGE_ACTION.increase,
            key: "start",
            event
          });
          break;
        case Keys.left:
          event.preventDefault();
          this.dispatchStateValue({
            type: this.currentDir === "rtl" ? RANGE_ACTION.increase : RANGE_ACTION.decrease,
            key: "start",
            event
          });
          break;
        case Keys.down:
          event.preventDefault();
          this.dispatchStateValue({
            type: RANGE_ACTION.decrease,
            key: "start",
            event
          });
          break;
        case Keys.home:
          event.preventDefault();
          this.dispatchStateValue({
            type: RANGE_ACTION.min,
            key: "start",
            event
          });
          break;
        case Keys.end:
          event.preventDefault();
          this.dispatchStateValue({
            type: RANGE_ACTION.max,
            key: "start",
            event
          });
          break;
        default:
          break;
      }
    },
    handleEndKeyDown: function handleEndKeyDown(event) {
      switch (event.keyCode) {
        case Keys.right:
          event.preventDefault();
          this.dispatchStateValue({
            type: this.currentDir === "rtl" ? RANGE_ACTION.decrease : RANGE_ACTION.increase,
            key: "end",
            event
          });
          break;
        case Keys.up:
          event.preventDefault();
          this.dispatchStateValue({
            type: RANGE_ACTION.increase,
            key: "end",
            event
          });
          break;
        case Keys.left:
          event.preventDefault();
          this.dispatchStateValue({
            type: this.currentDir === "rtl" ? RANGE_ACTION.increase : RANGE_ACTION.decrease,
            key: "end",
            event
          });
          break;
        case Keys.down:
          event.preventDefault();
          this.dispatchStateValue({
            type: RANGE_ACTION.decrease,
            key: "end",
            event
          });
          break;
        case Keys.home:
          event.preventDefault();
          this.dispatchStateValue({
            type: RANGE_ACTION.min,
            key: "end",
            event
          });
          break;
        case Keys.end:
          event.preventDefault();
          this.dispatchStateValue({
            type: RANGE_ACTION.max,
            key: "end",
            event
          });
          break;
        default:
          break;
      }
    },
    handleTrackPress: function handleTrackPress(event) {
      var payload = this.calcNewDistance(event);
      var key = this.calcKey(payload);
      this.currentDrag = key;
      key === "end" ? this.endHandle.focus() : this.startHandle.focus();
      var action = key === "end" ? RANGE_ACTION.end : RANGE_ACTION.start;
      this.dispatchStateValue({
        type: action,
        payload,
        event
      });
    },
    handleTrackDrag: function handleTrackDrag(event) {
      var payload = this.calcNewDistance(event);
      var action = this.currentDrag === "end" ? RANGE_ACTION.end : RANGE_ACTION.start;
      this.dispatchStateValue({
        type: action,
        payload,
        event
      });
    },
    handleTrackRelease: function handleTrackRelease(event) {
      var payload = this.calcNewDistance(event);
      var action = this.currentDrag === "end" ? RANGE_ACTION.end : RANGE_ACTION.start;
      this.dispatchStateValue({
        type: action,
        payload,
        event
      });
      this.currentDrag = "";
    }
  }
};
var RangeSlider = RangeSliderVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/checkbox/Checkbox.js
var allVue37 = vue_runtime_esm_bundler_exports;
var gh37 = allVue37.h;
var isV337 = allVue37.version && allVue37.version[0] === "3";
var ref14 = allVue37.ref;
var inject6 = allVue37.inject;
var CheckboxVue2 = {
  name: "KendoCheckbox",
  // @ts-ignore
  emits: {
    "changemodel": null,
    "update:modelValue": null,
    change: null,
    focus: null,
    blur: null
  },
  model: {
    event: "changemodel"
  },
  inject: {
    kendoLocalizationService: {
      default: null
    }
  },
  props: {
    checked: {
      type: Boolean,
      default: void 0
    },
    defaultChecked: {
      type: Boolean,
      default: void 0
    },
    defaultValue: {
      type: [String, Boolean],
      default: void 0
    },
    modelValue: {
      type: [String, Boolean],
      default: void 0
    },
    dir: String,
    disabled: Boolean,
    id: String,
    ariaLabelledBy: String,
    ariaDescribedBy: String,
    label: String,
    labelRender: [String, Number, Boolean, Object],
    labelPlacement: String,
    labelOptional: Boolean,
    labelClass: String,
    name: String,
    size: {
      type: String,
      default: "medium",
      validator: function validator24(value2) {
        return [null, "small", "medium", "large"].includes(value2);
      }
    },
    rounded: {
      type: String,
      default: "medium",
      validator: function validator25(value2) {
        return [null, "small", "medium", "large"].includes(value2);
      }
    },
    tabIndex: Number,
    value: {
      type: [String, Boolean],
      default: void 0
    },
    validationMessage: String,
    required: Boolean,
    valid: {
      type: Boolean,
      default: void 0
    },
    validityStyles: {
      type: Boolean,
      default: true
    }
  },
  data: function data17() {
    return {
      valueDuringOnChange: void 0,
      currentDir: "ltr",
      currentChecked: void 0,
      currentValue: void 0
    };
  },
  created: function created18() {
    validatePackage(packageMetadata);
    this.calculatedId = guid();
    if (this.$props.defaultChecked !== void 0) {
      this.currentChecked = this.$props.defaultChecked;
    }
    if (this.$props.defaultValue !== void 0) {
      this.currentValue = this.$props.defaultValue;
    }
    this.currentDir = this.$props.dir;
  },
  computed: {
    valueIsBooleanOrNull: function valueIsBooleanOrNull() {
      var value2 = this.$props.value;
      return typeof value2 === "boolean" || value2 === null;
    },
    isCheckedControlled: function isCheckedControlled() {
      return this.$props.checked !== void 0;
    },
    isValueControlled: function isValueControlled2() {
      return this.$props.value !== void 0 && this.valueIsBooleanOrNull;
    },
    computedValue: function computedValue7() {
      return this.$data.valueDuringOnChange !== void 0 ? this.$data.valueDuringOnChange : this.$props.value !== void 0 ? this.$props.value : this.$props.modelValue !== void 0 ? this.$props.modelValue : this.$data.currentValue;
    },
    computedChecked: function computedChecked() {
      return this.$data.valueDuringOnChange !== void 0 ? this.$data.valueDuringOnChange : this.$props.checked !== void 0 ? this.$props.checked : this.$props.modelValue !== void 0 ? this.$props.modelValue : this.$data.currentChecked;
    },
    useValueAsChecked: function useValueAsChecked() {
      return this.computedChecked === void 0 && this.computedValue;
    },
    checkedProp: function checkedProp() {
      return this.useValueAsChecked ? this.computedValue : this.computedChecked;
    },
    valueProp: function valueProp() {
      var value2 = this.$props.value;
      return this.useValueAsChecked || this.isValueControlled ? value2 === null ? value2 : void 0 : value2 || this.computedValue;
    },
    indeterminateProp: function indeterminateProp() {
      return this.checkedProp === null || this.valueProp === null;
    },
    isValid: function isValid() {
      var valid = this.$props.valid;
      return valid !== void 0 ? valid : !this.$props.required ? true : this.computedChecked ? true : false;
    },
    labelComputedClass: function labelComputedClass() {
      var _a5;
      return _a5 = {
        "k-checkbox-label": true
      }, _a5[this.$props.labelClass] = this.$props.labelClass, _a5;
    }
  },
  mounted: function mounted14() {
    this.input = getRef(this, "input");
    if (!this.currentDir && window && this.$el) {
      var direction = window.getComputedStyle(this.$el).direction;
      if (direction) {
        this.currentDir = direction;
      }
    }
    this.setValidity();
  },
  updated: function updated12() {
    if (!this.input) {
      this.input = getRef(this, "input");
    }
    this.setValidity();
  },
  // @ts-ignore
  setup: !isV337 ? void 0 : function() {
    var v3 = !!isV337;
    var inputRef = ref14(null);
    var kendoLocalizationService = inject6("kendoLocalizationService", {});
    return {
      v3,
      inputRef,
      kendoLocalizationService
    };
  },
  render: function render24(createElement) {
    var _a5;
    var h = gh37 || createElement;
    var _b = this.$props, ariaDescribedBy = _b.ariaDescribedBy, ariaLabelledBy = _b.ariaLabelledBy, disabled = _b.disabled, id = _b.id, label = _b.label, labelRender = _b.labelRender, labelPlacement = _b.labelPlacement, name3 = _b.name, labelOptional = _b.labelOptional, tabIndex = _b.tabIndex, required = _b.required, validityStyles = _b.validityStyles, size2 = _b.size, rounded = _b.rounded;
    var defaultSlot = getDefaultSlots(this);
    var renderedLabel = label;
    this.localizationService = provideLocalizationService(this);
    this.defaultValidationMessage = this.localizeMessage(checkboxValidation);
    this.optionalMessage = this.localizeMessage(checkboxOptionalText);
    var checkboxClasses = classNames({
      "k-checkbox-wrap": true,
      "k-disabled": disabled
    });
    var inputClasses = classNames((_a5 = {
      "k-checkbox": true
    }, _a5["k-checkbox-".concat(kendoThemeMaps.sizeMap[size2])] = size2, _a5["k-rounded-".concat(kendoThemeMaps.roundedMap[rounded])] = rounded, _a5["k-indeterminate"] = this.indeterminateProp, _a5["k-disabled"] = disabled, _a5["k-invalid"] = !this.isValid && validityStyles !== false, _a5));
    var checkboxInput = function checkboxInput2() {
      return h("input", {
        type: "checkbox",
        attrs: this.v3 ? void 0 : {
          type: "checkbox",
          name: name3,
          id: id || this.calculatedId,
          "aria-labelledby": ariaLabelledBy,
          "aria-describedby": ariaDescribedBy,
          disabled,
          tabindex: getTabIndex(tabIndex, disabled),
          role: "checkbox",
          required: required !== void 0 ? required : false,
          "aria-checked": this.computedChecked || this.checkedProp ? true : this.indeterminateProp ? "mixed" : false,
          "aria-disabled": disabled || void 0
        },
        "class": inputClasses,
        name: name3,
        id: id || this.calculatedId,
        ref: setRef(this, "input"),
        "aria-labelledby": ariaLabelledBy,
        "aria-describedby": ariaDescribedBy,
        checked: this.v3 ? Boolean(this.checkedProp) : null,
        domProps: this.v3 ? void 0 : {
          "checked": Boolean(this.checkedProp)
        },
        disabled,
        tabindex: getTabIndex(tabIndex, disabled),
        role: "checkbox",
        required: required !== void 0 ? required : false,
        "aria-checked": this.computedChecked || this.checkedProp ? true : this.indeterminateProp ? "mixed" : false,
        "aria-disabled": disabled || void 0,
        onChange: this.onChangeHandler,
        on: this.v3 ? void 0 : {
          "change": this.onChangeHandler,
          "keydown": this.onKeyDownHandler,
          "focus": this.onFocusHandler,
          "blur": this.onBlurHandler
        },
        onKeydown: this.onKeyDownHandler,
        onFocus: this.onFocusHandler,
        onBlur: this.onBlurHandler
      });
    };
    if (labelRender) {
      var renderTemplate = labelRender ? templateRendering.call(this, labelRender, getListeners.call(this)) : null;
      renderedLabel = getTemplate.call(this, {
        h,
        template: renderTemplate
      });
    }
    var checkboxLabel = function checkboxLabel2() {
      return renderedLabel !== void 0 ? h("label", {
        "class": this.labelComputedClass,
        "for": id || this.calculatedId,
        attrs: this.v3 ? void 0 : {
          "for": id || this.calculatedId
        },
        style: {
          userSelect: "none"
        }
      }, [renderedLabel, labelOptional && h("span", {
        "class": "k-label-optional"
      }, [this.optionalMessage])]) : null;
    };
    return labelPlacement === "before" ? h("span", {
      "class": checkboxClasses,
      dir: "rtl",
      attrs: this.v3 ? void 0 : {
        dir: "rtl"
      }
    }, [checkboxInput.call(this), checkboxLabel.call(this), defaultSlot]) : h("span", {
      "class": checkboxClasses,
      dir: this.currentDir,
      attrs: this.v3 ? void 0 : {
        dir: this.currentDir
      }
    }, [checkboxInput.call(this), checkboxLabel.call(this), defaultSlot]);
  },
  methods: {
    setValidity: function setValidity6() {
      var isValid3 = this.$props.valid !== void 0 ? this.$props.valid : !this.$props.required ? true : this.computedChecked ? true : false;
      if (this.input && this.input.setCustomValidity) {
        this.input.setCustomValidity(isValid3 ? "" : this.$props.validationMessage || this.defaultValidationMessage);
      }
    },
    localizeMessage: function localizeMessage(message) {
      return this.localizationService.toLanguageString(message, messages2[message]);
    },
    focusElement: function focusElement2() {
      if (this.input) {
        this.input.focus();
      }
    },
    setValue: function setValue(e, val) {
      this.$data.valueDuringOnChange = val;
      var that = this;
      this.$nextTick(function() {
        if (!that.isCheckedControlled && !that.isValueControlled && !that.$props.disabled) {
          that.currentValue = val;
          that.currentChecked = val;
        }
        if (!that.$props.disabled) {
          var handle = {
            element: that.$el,
            focus: null
            // focusElement
          };
          that.$emit("changemodel", val);
          that.$emit("update:modelValue", val);
          that.$emit("change", {
            e,
            handle,
            value: val
          });
        }
        this.$data.valueDuringOnChange = void 0;
      });
    },
    onChangeHandler: function onChangeHandler3(e) {
      var newValue = e.target.checked;
      this.setValue(e, newValue);
    },
    onKeyDownHandler: function onKeyDownHandler4(e) {
      if (this.$props.disabled) {
        return;
      }
      var keyCode = e.keyCode;
      var currentVal = e.currentTarget.checked;
      if (keyCode === Keys.space) {
        e.preventDefault();
        e.stopPropagation();
        this.setValue(e, !currentVal);
      }
    },
    onBlurHandler: function onBlurHandler2(e) {
      if (!this.$props.disabled) {
        this.$emit("blur", e);
      }
    },
    onFocusHandler: function onFocusHandler2(e) {
      if (!this.$props.disabled) {
        this.$emit("focus", e);
      }
    }
  }
};
var Checkbox = CheckboxVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/radiobutton/RadioButton.js
var allVue38 = vue_runtime_esm_bundler_exports;
var gh38 = allVue38.h;
var isV338 = allVue38.version && allVue38.version[0] === "3";
var ref15 = allVue38.ref;
var inject7 = allVue38.inject;
var RadioButtonVue2 = {
  name: "KendoRadioButton",
  props: {
    ariaDescribedBy: String,
    checked: Boolean,
    disabled: Boolean,
    className: String,
    content: [String, Number, Boolean, Object],
    dataItem: Object,
    id: String,
    label: String,
    labelRender: [String, Number, Boolean, Object],
    item: [String, Number, Boolean, Object],
    labelPlacement: String,
    name: String,
    index: Number,
    tag: {
      type: String,
      default: "div"
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator26(value2) {
        return [null, "small", "medium", "large"].includes(value2);
      }
    },
    tabIndex: Number,
    value: [String, Number, Object],
    valid: {
      type: Boolean,
      default: void 0
    }
  },
  // @ts-ignore
  emits: {
    change: null,
    focus: null,
    blur: null
  },
  created: function created19() {
    this.calculatedId = guid();
    validatePackage(packageMetadata);
  },
  mounted: function mounted15() {
    this.input = getRef(this, "input");
  },
  computed: {
    inputClassName: function inputClassName() {
      var _a5;
      return _a5 = {
        "k-radio": true
      }, _a5["k-radio-".concat(kendoThemeMaps.sizeMap[this.$props.size])] = this.$props.size, _a5["k-invalid"] = this.$props.valid === false, _a5[this.$props.className] = this.$props.className, _a5;
    }
  },
  methods: {
    focusElement: function focusElement3() {
      if (this.input) {
        this.input.focus();
      }
    },
    handleChange: function handleChange4(event) {
      this.$emit("change", {
        event,
        value: this.$props.value
      });
    },
    handleFocus: function handleFocus4(event) {
      if (!this.$props.disabled) {
        this.$emit("focus", event, void 0);
      }
    },
    handleBlur: function handleBlur4(event) {
      if (!this.$props.disabled) {
        this.$emit("blur", event, void 0);
      }
    }
  },
  // @ts-ignore
  setup: !isV338 ? void 0 : function() {
    var v3 = !!isV338;
    var inputRef = ref15(null);
    return {
      v3,
      inputRef
    };
  },
  render: function render25(createElement) {
    var h = gh38 || createElement;
    var defaultSlot = getDefaultSlots(this);
    var _a5 = this.$props, ariaDescribedBy = _a5.ariaDescribedBy, checked = _a5.checked, disabled = _a5.disabled, id = _a5.id, label = _a5.label, labelRender = _a5.labelRender, labelPlacement = _a5.labelPlacement, name3 = _a5.name, tabIndex = _a5.tabIndex, value2 = _a5.value, tag = _a5.tag;
    var renderedLabel = label;
    if (labelRender) {
      var renderTemplate = labelRender ? templateRendering.call(this, labelRender, getListeners.call(this)) : null;
      renderedLabel = getTemplate.call(this, {
        h,
        template: renderTemplate
      });
    }
    var content = getTemplate.call(this, {
      h,
      template: this.$props.content
    });
    var radioButtonLabel = renderedLabel !== void 0 ? h("label", {
      "class": "k-radio-label",
      "for": id || this.calculatedId,
      attrs: this.v3 ? void 0 : {
        "for": id || this.calculatedId,
        "aria-label": label
      },
      style: {
        userSelect: "none"
      },
      "aria-label": label
    }, [renderedLabel]) : null;
    var radio = h("input", {
      type: "radio",
      attrs: this.v3 ? void 0 : {
        type: "radio",
        id: id || this.calculatedId,
        name: name3,
        disabled,
        tabindex: getTabIndex(tabIndex, disabled),
        "aria-describedby": ariaDescribedBy
      },
      id: id || this.calculatedId,
      name: name3,
      "class": this.inputClassName,
      ref: setRef(this, "input"),
      disabled,
      tabindex: getTabIndex(tabIndex, disabled),
      checked: this.v3 ? checked : null,
      domProps: this.v3 ? void 0 : {
        "checked": checked,
        "value": value2
      },
      style: this.$attrs.style,
      "aria-describedby": ariaDescribedBy,
      value: this.v3 ? value2 : null,
      onChange: this.handleChange,
      on: this.v3 ? void 0 : {
        "change": this.handleChange,
        "focus": this.handleFocus,
        "blur": this.handleBlur
      },
      onFocus: this.handleFocus,
      onBlur: this.handleBlur
    });
    var defaultRendering = labelPlacement === "before" ? h(tag, [radioButtonLabel, radio, content, defaultSlot]) : h(tag, [radio, radioButtonLabel, content, defaultSlot]);
    return getTemplate.call(this, {
      h,
      template: this.$props.item,
      defaultRendering,
      defaultSlots: defaultSlot,
      additionalListeners: {
        change: this.handleChange,
        focus: this.handleFocus,
        blur: this.handleBlur
      },
      additionalProps: {
        dataItem: this.$props.dataItem
      }
    });
  }
};
var RadioButton = RadioButtonVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/radiobutton/RadioGroup.js
var allVue39 = vue_runtime_esm_bundler_exports;
var gh39 = allVue39.h;
var isV339 = allVue39.version && allVue39.version[0] === "3";
var ref16 = allVue39.ref;
var inject8 = allVue39.inject;
var RadioGroupVue2 = {
  name: "KendoRadioGroup",
  props: {
    ariaLabelledBy: String,
    ariaDescribedBy: String,
    dataItems: Array,
    defaultValue: [String, Number, Object],
    dir: String,
    disabled: Boolean,
    labelPlacement: String,
    item: {
      type: String,
      default: void 0
    },
    layout: {
      type: String,
      default: "vertical",
      validator: function validator27(value2) {
        return ["horizontal", "vertical"].includes(value2);
      }
    },
    name: String,
    modelValue: [String, Number, Object],
    value: [String, Number, Object],
    valid: {
      type: Boolean,
      default: void 0
    }
  },
  // @ts-ignore
  emits: {
    "changemodel": null,
    "update:modelValue": null,
    change: null,
    focus: null,
    blur: null
  },
  model: {
    event: "changemodel"
  },
  created: function created20() {
    this.radioGroupName = guid();
    validatePackage(packageMetadata);
    this.stateChecked = this.$props.defaultValue;
  },
  watch: {
    value: function value(newValue) {
      if (newValue === void 0) {
        this.stateChecked = this.$props.defaultValue;
      }
    }
  },
  mounted: function mounted16() {
    this.rtl = isRtl(this.$el);
  },
  computed: {
    radioGroupClasses: function radioGroupClasses() {
      var layout = this.$props.layout;
      return {
        "k-radio-list": true,
        "k-list-horizontal": layout === "horizontal",
        "k-list-vertical": layout === "vertical" || layout === void 0
      };
    },
    checkedRadioValue: function checkedRadioValue() {
      var value2 = this.$props.value;
      return value2 !== void 0 ? value2 : this.$props.modelValue !== void 0 ? this.$props.modelValue : this.stateChecked;
    },
    currentDir: function currentDir() {
      var dir = this.$props.dir;
      return dir ? dir : this.rtl ? "rtl" : void 0;
    }
  },
  data: function data18() {
    return {
      rtl: false,
      stateChecked: void 0
    };
  },
  methods: {
    focusElement: function focusElement4() {
      if (this.$el) {
        focusFirstFocusableChild(this.$el);
      }
    },
    handleChange: function handleChange5(event) {
      var currentValue = event.value;
      if (!(this.$props.value !== void 0) && !this.$props.disabled) {
        this.stateChecked = currentValue;
      }
      if (!this.$props.disabled) {
        this.$emit("changemodel", currentValue);
        this.$emit("update:modelValue", currentValue);
        this.$emit("change", {
          event,
          value: currentValue
        });
      }
    },
    handleFocus: function handleFocus5(event) {
      if (!this.$props.disabled) {
        this.$emit("focus", event);
      }
    },
    handleBlur: function handleBlur5(event) {
      if (!this.$props.disabled) {
        this.$emit("blur", event);
      }
    }
  },
  // @ts-ignore
  setup: !isV339 ? void 0 : function() {
    var v3 = !!isV339;
    var inputRef = ref16(null);
    return {
      v3,
      inputRef
    };
  },
  render: function render26(createElement) {
    var h = gh39 || createElement;
    var _a5 = this.$props, ariaLabelledBy = _a5.ariaLabelledBy, ariaDescribedBy = _a5.ariaDescribedBy, dataItems = _a5.dataItems, disabled = _a5.disabled, name3 = _a5.name, labelPlacement = _a5.labelPlacement, valid = _a5.valid;
    var radioOptions = dataItems && dataItems.map(function(option, index) {
      var isCurrentlyChecked = this.checkedRadioValue === option.value;
      var noOptionChecked = this.checkedRadioValue === null || this.checkedRadioValue === void 0;
      var item = templateRendering.call(this, this.$props.item || option.item, getListeners.call(this));
      return (
        // @ts-ignore function children
        h(RadioButton, {
          "class": classNames("k-radio-item", {
            "k-disabled": option.disabled || disabled
          }),
          style: option.style,
          key: index,
          item,
          attrs: this.v3 ? void 0 : {
            item,
            role: "none",
            tag: "li",
            valid,
            className: option.className,
            label: option.label,
            value: option.value,
            dataItem: option,
            checked: isCurrentlyChecked,
            disabled: option.disabled || disabled ? true : false,
            labelPlacement: option.labelPlacement ? option.labelPlacement : labelPlacement,
            tabIndex: option.tabIndex ? option.tabIndex : noOptionChecked && index === 0 || isCurrentlyChecked ? 0 : -1,
            index,
            name: name3 || option.name || this.radioGroupName
          },
          role: "none",
          tag: "li",
          valid,
          className: option.className,
          label: option.label,
          value: option.value,
          dataItem: option,
          checked: isCurrentlyChecked,
          disabled: option.disabled || disabled ? true : false,
          labelPlacement: option.labelPlacement ? option.labelPlacement : labelPlacement,
          tabIndex: option.tabIndex ? option.tabIndex : noOptionChecked && index === 0 || isCurrentlyChecked ? 0 : -1,
          index,
          name: name3 || option.name || this.radioGroupName,
          onChange: this.handleChange,
          on: this.v3 ? void 0 : {
            "change": this.handleChange,
            "focus": this.handleFocus,
            "blur": this.handleBlur
          },
          onFocus: this.handleFocus,
          onBlur: this.handleBlur
        }, this.v3 ? function() {
          return [option.content];
        } : [option.content])
      );
    }, this);
    return h("ul", {
      role: "radiogroup",
      attrs: this.v3 ? void 0 : {
        role: "radiogroup",
        dir: this.currentDir,
        "aria-labelledby": ariaLabelledBy,
        "aria-describedby": ariaDescribedBy
      },
      "class": this.radioGroupClasses,
      dir: this.currentDir,
      "aria-labelledby": ariaLabelledBy,
      "aria-describedby": ariaDescribedBy
    }, [radioOptions]);
  }
};
var RadioGroup = RadioGroupVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/textarea/TextArea.js
var __assign10 = function() {
  __assign10 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return __assign10.apply(this, arguments);
};
var allVue40 = vue_runtime_esm_bundler_exports;
var gh40 = allVue40.h;
var isV340 = allVue40.version && allVue40.version[0] === "3";
var TextAreaVue2 = {
  name: "KendoTextArea",
  model: {
    event: "changemodel"
  },
  // @ts-ignore
  emits: {
    "input": null,
    "change": null,
    "changemodel": null,
    "update:modelValue": null,
    "focus": null,
    "blur": null
  },
  props: {
    title: String,
    ariaDescribedBy: String,
    ariaLabelledBy: String,
    autoSize: Boolean,
    modelValue: {
      type: [String, Array, Number],
      default: void 0
    },
    defaultValue: [String, Number],
    dir: String,
    disabled: Boolean,
    readOnly: Boolean,
    rows: Number,
    id: String,
    name: String,
    validationMessage: String,
    size: {
      type: String,
      default: "medium",
      validator: function validator28(value2) {
        return [null, "small", "medium", "large"].includes(value2);
      }
    },
    rounded: {
      type: String,
      default: "medium",
      validator: function validator29(value2) {
        return [null, "small", "medium", "large", "full"].includes(value2);
      }
    },
    fillMode: {
      type: String,
      default: "solid",
      validator: function validator30(value2) {
        return [null, "solid", "flat", "outline"].includes(value2);
      }
    },
    required: Boolean,
    placeholder: String,
    tabIndex: Number,
    valid: {
      type: Boolean,
      default: void 0
    },
    value: [String, Array, Number],
    validityStyles: {
      type: Boolean,
      default: true
    },
    iconName: String,
    inputPrefix: templateDefinition,
    inputSuffix: templateDefinition,
    showValidationIcon: Boolean,
    showLoadingIcon: Boolean,
    showClearButton: Boolean,
    inputClass: String,
    wrapperClass: String,
    flow: {
      type: String,
      default: "horizontal",
      validator: function validator31(value2) {
        return ["horizontal", "vertical"].includes(value2);
      }
    },
    resizable: {
      type: String,
      default: "vertical",
      validator: function validator32(value2) {
        return ["both", "horizontal", "vertical", "none"].includes(value2);
      }
    }
  },
  created: function created21() {
    validatePackage(packageMetadata);
    this.calculatedId = guid();
  },
  computed: {
    resizableClass: function resizableClass() {
      var _a5 = this.$props, resizable = _a5.resizable, autoSize = _a5.autoSize;
      return autoSize || resizable === TextAreaResizeEnum.none ? "k-resize-none" : resizable === TextAreaResizeEnum.vertical ? "k-resize-y" : resizable === TextAreaResizeEnum.horizontal ? "k-resize-x" : "k-resize";
    },
    rootClassName: function rootClassName() {
      var _a5;
      var _b = this.$props, size2 = _b.size, fillMode = _b.fillMode, rounded = _b.rounded, required = _b.required, showLoadingIcon = _b.showLoadingIcon;
      var invalid = this.validityStyles === true ? !this.isValid : false;
      return _a5 = {
        "k-input": true,
        "k-textarea": true
      }, _a5["k-input-".concat(kendoThemeMaps.sizeMap[size2] || size2)] = size2, _a5["k-input-".concat(fillMode)] = fillMode, _a5["k-rounded-".concat(kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded, _a5["k-disabled"] = this.$props.disabled, _a5["k-invalid"] = invalid, _a5["k-required"] = required, _a5["k-loading"] = showLoadingIcon, _a5[this.resizableClass] = true, _a5["!k-flex-col"] = this.flow === "vertical", _a5["!k-flex-row"] = this.flow === "horizontal", _a5[this.wrapperClass] = this.wrapperClass, _a5;
    },
    inputInnerClass: function inputInnerClass5() {
      var _a5;
      return _a5 = {
        "k-input-inner": true,
        "!k-resize-none": true,
        "!k-overflow-auto": true,
        "k-flex": true
      }, _a5[this.inputClass] = this.inputClass, _a5;
    },
    prefixRenderClass: function prefixRenderClass() {
      return {
        "k-input-prefix": true,
        "!k-flex-col": this.flow === "horizontal",
        "!k-flex-row": this.flow === "vertical",
        "!k-align-items-start": this.flow === "horizontal"
      };
    },
    suffixRenderClass: function suffixRenderClass() {
      return {
        "k-input-suffix": true,
        "!k-flex-col": this.flow === "horizontal",
        "!k-flex-row": this.flow === "vertical",
        "!k-align-items-start": this.flow === "horizontal"
      };
    },
    suffixIconWrapClass: function suffixIconWrapClass() {
      return {
        "k-flex-wrap": true,
        "!k-align-items-start": true
      };
    },
    computedValue: function computedValue8() {
      return this.$props.value !== void 0 ? this.$props.value : this.$props.modelValue !== void 0 ? this.$props.modelValue : this.currentValue;
    },
    isValid: function isValid2() {
      return this.valid !== void 0 ? this.valid : !this.required ? true : this.computedValue ? true : false;
    }
  },
  data: function data19() {
    return {
      currentValue: this.$props.defaultValue,
      textAreaHeight: "auto",
      currentDir: "ltr"
    };
  },
  watch: {
    size: function size() {
      this.textAreaHeight = "auto";
    },
    computedValue: function computedValue9() {
      this.textAreaHeight = "auto";
    }
  },
  mounted: function mounted17() {
    this.element = this.v3 ? this.elementRef : this.$refs.element;
    this.currentDir = this.$props.dir !== void 0 ? this.$props.dir : isRtl(this.$el) ? "rtl" : "ltr";
    this.setValidity();
  },
  updated: function updated13() {
    this.element = this.v3 ? this.elementRef : this.$refs.element;
    this.setValidity();
  },
  // @ts-ignore
  setup: !isV340 ? void 0 : function() {
    var v3 = !!isV340;
    return {
      v3
    };
  },
  // @ts-ignore
  render: function render27(createElement) {
    var _this = this;
    var h = gh40 || createElement;
    var _a5 = this.$props, ariaDescribedBy = _a5.ariaDescribedBy, ariaLabelledBy = _a5.ariaLabelledBy, autoSize = _a5.autoSize, disabled = _a5.disabled, readOnly = _a5.readOnly, required = _a5.required, rows = _a5.rows, id = _a5.id, name3 = _a5.name, placeholder = _a5.placeholder, tabIndex = _a5.tabIndex, iconName = _a5.iconName, showValidationIcon = _a5.showValidationIcon, showLoadingIcon = _a5.showLoadingIcon, showClearButton = _a5.showClearButton, title = _a5.title;
    var textAreaAttrs = __assign10({
      id: id || this.calculatedId,
      name: name3,
      disabled,
      rows,
      title,
      placeholder,
      readOnly,
      required,
      tabIndex: getTabIndex(tabIndex, disabled),
      "aria-labelledby": ariaLabelledBy,
      "aria-describedby": ariaDescribedBy,
      "aria-multiline": true,
      "aria-disabled": disabled || void 0
    }, this.$attrs);
    var inputPrefixTemplate = templateRendering.call(this, this.$props.inputPrefix, getListeners.call(this));
    var inputSuffixTemplate = templateRendering.call(this, this.$props.inputSuffix, getListeners.call(this));
    var inputPrefix = getTemplate.call(this, {
      h,
      template: inputPrefixTemplate,
      additionalProps: {
        value: this.computedValue,
        valid: this.isValid
      }
    });
    var inputSuffix = getTemplate.call(this, {
      h,
      template: inputSuffixTemplate,
      additionalProps: {
        value: this.computedValue,
        valid: this.isValid
      }
    });
    var textarea = h("textarea", __assign10(__assign10({}, textAreaAttrs), {
      attrs: this.v3 ? void 0 : textAreaAttrs,
      class: this.inputInnerClass,
      ref: this.v3 ? function(el) {
        _this.elementRef = el;
      } : "element",
      style: autoSize ? {
        overflow: "hidden",
        height: this.textAreaHeight
      } : {},
      value: this.v3 ? this.computedValue : null,
      domProps: this.v3 ? void 0 : {
        "value": this.computedValue
      },
      onChange: this.handleChange,
      onInput: this.handleInput,
      on: this.v3 ? void 0 : {
        "change": this.handleChange,
        "focus": this.handleFocus,
        "blur": this.handleBlur,
        input: this.handleInput
      },
      onFocus: this.handleFocus,
      onBlur: this.handleBlur
    }));
    var renderWithIcons = [iconName && h("span", {
      "class": "k-flex-wrap"
    }, [h(Icon, {
      name: iconName,
      attrs: this.v3 ? void 0 : {
        name: iconName
      },
      "class": "k-input-icon"
    })]), textarea, showValidationIcon && this.isValid && h("span", {
      "class": this.suffixIconWrapClass
    }, [h(Icon, {
      name: "check",
      attrs: this.v3 ? void 0 : {
        name: "check"
      },
      "class": "k-input-validation-icon"
    })]), showValidationIcon && !this.isValid && h("span", {
      "class": this.suffixIconWrapClass
    }, [h(Icon, {
      name: "exclamation-circle",
      attrs: this.v3 ? void 0 : {
        name: "exclamation-circle",
        icon: exclamationCircleIcon
      },
      icon: exclamationCircleIcon,
      "class": "k-input-validation-icon"
    })]), showLoadingIcon && h("span", {
      "class": this.suffixIconWrapClass
    }, [h(Icon, {
      name: "loading",
      attrs: this.v3 ? void 0 : {
        name: "loading"
      },
      "class": "k-input-loading-icon"
    })]), showClearButton && this.computedValue && h("span", {
      "class": this.suffixIconWrapClass
    }, [h("span", {
      onClick: this.clearClick,
      on: this.v3 ? void 0 : {
        "click": this.clearClick
      },
      "class": "k-clear-value"
    }, [h(Icon, {
      name: "x",
      attrs: this.v3 ? void 0 : {
        name: "x",
        icon: xIcon
      },
      icon: xIcon
    })])])];
    return h("span", {
      "class": this.rootClassName,
      dir: this.currentDir === "rtl" ? this.currentDir : "",
      attrs: this.v3 ? void 0 : {
        dir: this.currentDir === "rtl" ? this.currentDir : ""
      },
      style: this.$attrs.style
    }, [this.$props.inputPrefix && h("span", {
      "class": this.prefixRenderClass
    }, [inputPrefix]), iconName || showValidationIcon || showLoadingIcon || showClearButton ? h("span", {
      "class": "k-hstack k-flex"
    }, [renderWithIcons]) : renderWithIcons, this.$props.inputSuffix && h("span", {
      "class": this.suffixRenderClass
    }, [inputSuffix])]);
  },
  methods: {
    setValidity: function setValidity7() {
      if (this.element && this.element.setCustomValidity) {
        this.element.setCustomValidity(this.isValid ? "" : this.validationMessage || "");
      }
      if (this.element) {
        this.textAreaHeight = "".concat(this.element.scrollHeight, "px");
      }
    },
    clearClick: function clearClick5(event) {
      this.emitUpdate(event, "change", "");
    },
    focus: function focus12() {
      if (this.element) {
        this.element.focus();
      }
    },
    emitUpdate: function emitUpdate3(event, eventName, value2) {
      var newValue = value2;
      if (!this.$props.disabled) {
        this.currentValue = newValue;
      }
      if (!this.$props.disabled) {
        this.$emit("changemodel", newValue);
        this.$emit("update:modelValue", newValue);
        this.$emit(eventName, {
          event,
          component: this,
          name: this.element.name,
          value: newValue
        });
      }
    },
    handleChange: function handleChange6(event) {
      this.emitUpdate(event, "change", event.target.value);
    },
    handleInput: function handleInput3(event) {
      this.emitUpdate(event, "input", event.target.value);
    },
    handleFocus: function handleFocus6(event) {
      if (!this.$props.disabled) {
        this.$emit("focus", {
          event,
          component: this,
          name: this.element.name
        });
      }
    },
    handleBlur: function handleBlur6(event) {
      if (!this.$props.disabled) {
        this.$emit("blur", {
          event,
          component: this,
          name: this.element.name
        });
      }
    }
  }
};
var TextArea = TextAreaVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/textarea/interfaces/TextAreaResize.js
var TextAreaResizeEnum;
(function(TextAreaResizeEnum2) {
  TextAreaResizeEnum2["both"] = "both";
  TextAreaResizeEnum2["horizontal"] = "horizontal";
  TextAreaResizeEnum2["vertical"] = "vertical";
  TextAreaResizeEnum2["none"] = "none";
})(TextAreaResizeEnum || (TextAreaResizeEnum = {}));

// node_modules/@progress/kendo-vue-dialogs/dist/es/DialogTitleBar.js
var allVue41 = vue_runtime_esm_bundler_exports;
var gh41 = allVue41.h;
var isV341 = allVue41.version && allVue41.version[0] === "3";
var DialogTitleBarVue2 = {
  props: {
    id: String,
    closeIcon: {
      type: Boolean,
      default: true
    },
    title: String,
    titleRender: [String, Function, Object]
  },
  // @ts-ignore
  setup: !isV341 ? void 0 : function() {
    var v3 = !!isV341;
    return {
      v3
    };
  },
  methods: {
    onCloseButtonClick: function onCloseButtonClick(e) {
      this.$emit("closebuttonclick", e);
    }
  },
  // @ts-ignore
  render: function render28(createElement) {
    var h = gh41 || createElement;
    var _a5 = this.$props, id = _a5.id, closeIcon = _a5.closeIcon, titleRender = _a5.titleRender, title = _a5.title;
    var titleElement;
    titleElement = getTemplate.call(this, {
      h,
      template: titleRender,
      defaultRendering: title
    });
    return h("div", {
      "class": "k-window-titlebar k-dialog-titlebar",
      id,
      attrs: this.v3 ? void 0 : {
        id
      }
    }, [h("span", {
      "class": "k-window-title k-dialog-title"
    }, [titleElement]), h("div", {
      "class": "k-window-titlebar-actions k-dialog-titlebar-actions"
    }, [closeIcon && // @ts-ignore
    h(Button, {
      type: "button",
      attrs: this.v3 ? void 0 : {
        type: "button",
        fillMode: "flat",
        "aria-label": "Close",
        icon: "x",
        svgIcon: xIcon
      },
      fillMode: "flat",
      "aria-label": "Close",
      icon: "x",
      svgIcon: xIcon,
      onClick: this.onCloseButtonClick,
      on: this.v3 ? void 0 : {
        "click": this.onCloseButtonClick
      },
      "class": "k-window-titlebar-action k-dialog-titlebar-action"
    })])]);
  }
};
var DialogTitleBar = DialogTitleBarVue2;

// node_modules/@progress/kendo-vue-dialogs/dist/es/package-metadata.js
var packageMetadata4 = {
  name: "@progress/kendo-vue-dialogs",
  productName: "Kendo UI for Vue",
  productCodes: ["KENDOUIVUE", "KENDOUICOMPLETE"],
  publishDate: 1714476862,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-vue-ui/my-license/?utm_medium=product&utm_source=kendovue&utm_campaign=kendo-ui-vue-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-vue-dialogs/dist/es/constants.js
var DEFAULT_DIALOGS_ZINDEX = 10002;

// node_modules/@progress/kendo-vue-dialogs/dist/es/Dialog.js
var allVue42 = vue_runtime_esm_bundler_exports;
var gh42 = allVue42.h;
var isV342 = allVue42.version && allVue42.version[0] === "3";
var DialogVue2 = {
  name: "KendoDialog",
  // @ts-ignore
  emits: {
    close: null,
    overlayclick: null
  },
  props: {
    appendTo: String,
    title: String,
    titleRender: templateDefinition,
    id: String,
    wrapperId: String,
    dir: String,
    closeIcon: {
      type: Boolean,
      default: true
    },
    width: [String, Number],
    height: [String, Number],
    minWidth: [String, Number],
    dialogClass: String,
    themeColor: {
      type: String,
      validator: function validator33(value2) {
        return ["primary", "dark", "light"].includes(value2);
      }
    },
    onClose: Function
  },
  provide: function provide3() {
    return {
      kCurrentZIndex: DEFAULT_DIALOGS_ZINDEX
    };
  },
  data: function data20() {
    return {
      showLicenseWatermark: false
    };
  },
  created: function created22() {
    validatePackage(packageMetadata4);
    this.showLicenseWatermark = shouldShowValidationUI(packageMetadata4);
    this.titleId = this.generateTitleId();
    this.contentId = this.generateContentId();
  },
  // @ts-ignore
  setup: !isV342 ? void 0 : function() {
    var v3 = !!isV342;
    return {
      v3
    };
  },
  computed: {
    dialogElementClass: function dialogElementClass() {
      var _a5;
      var _b = this.$props, dialogClass = _b.dialogClass, themeColor = _b.themeColor;
      return _a5 = {
        "k-window": true,
        "k-dialog": true
      }, _a5[dialogClass] = dialogClass, _a5["k-window-".concat(themeColor)] = themeColor, _a5;
    }
  },
  mounted: function mounted18() {
    if (this.$props.appendTo) {
      var body = document.querySelector(this.$props.appendTo);
      this.windowElement = this.$refs.wrapper;
      body.append(this.windowElement);
    }
  },
  beforeDestroy: !!isV342 ? void 0 : function() {
    if (this.$props.appendTo) {
      this.windowElement.remove();
    }
  },
  // @ts-ignore
  beforeUnmount: function beforeUnmount() {
    if (this.$props.appendTo) {
      this.windowElement.remove();
    }
  },
  methods: {
    handleCloseDialog: function handleCloseDialog(event) {
      event.preventDefault();
      this.$emit("close", {
        event,
        target: this
      });
    },
    handleKeyDown: function handleKeyDown2(event) {
      if (event.keyCode === Keys.esc && hasListener.call(this, "close")) {
        event.preventDefault();
        this.handleCloseDialog(event);
      }
    },
    transformDimesion: function transformDimesion(initialValue) {
      return typeof initialValue === "string" ? initialValue.endsWith("px") || initialValue.endsWith("%") ? initialValue : initialValue + "px" : initialValue + "px";
    },
    getActionBarIndex: function getActionBarIndex(children) {
      var actionBarIndex = children.findIndex(function(child) {
        return child && child.tag && child.tag.toLowerCase().indexOf("dialogactionsbar") !== -1 || child.componentOptions && child.componentOptions.tag && child.componentOptions.tag.toLowerCase().indexOf("actions-bar") !== -1 || child.type && child.type.name && child.type.name.toLowerCase().indexOf("dialogactionsbar") !== -1;
      });
      return actionBarIndex;
    },
    generateTitleId: function generateTitleId() {
      return "dialog-title" + guid();
    },
    generateContentId: function generateContentId() {
      return "dialog-content" + guid();
    },
    handleClick: function handleClick3(e) {
      this.$emit("overlayclick", e);
    }
  },
  // @ts-ignore
  render: function render29(createElement) {
    var h = gh42 || createElement;
    var id = this.$props.id !== void 0 ? this.$props.id : this.titleId;
    var _a5 = this.$props, title = _a5.title, width = _a5.width, height = _a5.height, minWidth = _a5.minWidth, dir = _a5.dir, contentStyle = _a5.contentStyle, wrapperId = _a5.wrapperId;
    var titleRender = this.$props.titleRender ? templateRendering.call(this, this.$props.titleRender, getListeners.call(this)) : null;
    var defaultSlot = getDefaultSlots(this);
    var content = defaultSlot || [];
    width = this.transformDimesion(width);
    height = this.transformDimesion(height);
    minWidth = this.transformDimesion(minWidth);
    var watermark = this.showLicenseWatermark ? h(WatermarkOverlay) : null;
    var actionBarIndex = this.getActionBarIndex(content);
    var actions;
    if (actionBarIndex !== -1) {
      actions = content[actionBarIndex];
      content.splice(actionBarIndex, 1);
    }
    var closeIcon = this.$props.closeIcon !== void 0 ? this.$props.closeIcon : true;
    var dialog = h("div", {
      ref: "wrapper",
      "class": "k-dialog-wrapper",
      onKeydown: this.handleKeyDown,
      on: this.v3 ? void 0 : {
        "keydown": this.handleKeyDown
      },
      tabindex: 0,
      attrs: this.v3 ? void 0 : {
        tabindex: 0,
        id: wrapperId,
        dir
      },
      id: wrapperId,
      dir
    }, [h("div", {
      "class": "k-overlay",
      onClick: this.handleClick,
      on: this.v3 ? void 0 : {
        "click": this.handleClick
      }
    }), h("div", {
      "aria-labelledby": title || titleRender ? id : void 0,
      attrs: this.v3 ? void 0 : {
        "aria-labelledby": title || titleRender ? id : void 0,
        "aria-describedby": this.contentId,
        "aria-modal": true,
        role: "dialog"
      },
      "aria-describedby": this.contentId,
      "aria-modal": true,
      "class": this.dialogElementClass,
      role: "dialog",
      style: {
        width,
        height,
        minWidth
      }
    }, [(title || titleRender) && // @ts-ignore
    h(DialogTitleBar, {
      closeIcon,
      attrs: this.v3 ? void 0 : {
        closeIcon,
        id,
        title,
        titleRender
      },
      onClosebuttonclick: this.handleCloseDialog,
      on: this.v3 ? void 0 : {
        "closebuttonclick": this.handleCloseDialog
      },
      id,
      title,
      titleRender
    }), h("div", {
      "class": "k-window-content k-dialog-content",
      style: contentStyle,
      id: this.contentId,
      attrs: this.v3 ? void 0 : {
        id: this.contentId
      }
    }, [content]), actions, watermark])]);
    return this.$props.appendTo ? h("div", [dialog]) : dialog;
  }
};
var Dialog = DialogVue2;

// node_modules/@progress/kendo-vue-dialogs/dist/es/DialogActionsBar.js
var allVue43 = vue_runtime_esm_bundler_exports;
var gh43 = allVue43.h;
var isV343 = allVue43.version && allVue43.version[0] === "3";

// node_modules/@progress/kendo-vue-dialogs/dist/es/StageEnum.js
var windowStage;
(function(windowStage2) {
  windowStage2["DEFAULT"] = "DEFAULT";
  windowStage2["FULLSCREEN"] = "FULLSCREEN";
  windowStage2["MINIMIZED"] = "MINIMIZED";
})(windowStage || (windowStage = {}));

// node_modules/@progress/kendo-vue-dialogs/dist/es/messages/main.js
var _a3;
var dialogsWindowMaximizeButton = "dialogs.windowMaximizeButton";
var dialogsWindowMinimizeButton = "dialogs.windowMinimizeButton";
var dialogsWindowRestoreButton = "dialogs.windowRestoreButton";
var dialogsWindowCloseButton = "dialogs.windowCloseButton";
var messages3 = (_a3 = {}, _a3[dialogsWindowMaximizeButton] = "maximize", _a3[dialogsWindowMinimizeButton] = "minimize", _a3[dialogsWindowRestoreButton] = "restore", _a3[dialogsWindowCloseButton] = "close", _a3);

// node_modules/@progress/kendo-vue-dialogs/dist/es/WindowTitlebar.js
var allVue44 = vue_runtime_esm_bundler_exports;
var gh44 = allVue44.h;
var isV344 = allVue44.version && allVue44.version[0] === "3";

// node_modules/@progress/kendo-vue-dialogs/dist/es/WindowResizeHandlers.js
var allVue45 = vue_runtime_esm_bundler_exports;
var gh45 = allVue45.h;
var isV345 = allVue45.version && allVue45.version[0] === "3";

// node_modules/@progress/kendo-vue-dialogs/dist/es/Window.js
var allVue46 = vue_runtime_esm_bundler_exports;
var gh46 = allVue46.h;
var isV346 = allVue46.version && allVue46.version[0] === "3";

// node_modules/@progress/kendo-vue-inputs/dist/es/signature/SignatureBottomActions.js
var allVue47 = vue_runtime_esm_bundler_exports;
var gh47 = allVue47.h;
var isV347 = allVue47.version && allVue47.version[0] === "3";
var SignatureBottomActionsVue2 = {
  name: "KendoSignatureBottomActions",
  // @ts-ignore
  emits: {
    clear: null
  },
  props: {
    showClear: Boolean,
    size: String,
    title: String
  },
  methods: {
    onClear: function onClear(e) {
      this.$emit("clear", e);
    }
  },
  // @ts-ignore
  setup: !isV347 ? void 0 : function() {
    var v3 = !!isV347;
    return {
      v3
    };
  },
  render: function render30(createElement) {
    var h = gh47 || createElement;
    var _a5 = this.$props, showClear = _a5.showClear, title = _a5.title, size2 = _a5.size;
    return h("div", {
      "class": "k-signature-actions k-signature-actions-bottom"
    }, [showClear && // @ts-ignore
    h(Button, {
      "class": "k-signature-action k-signature-clear",
      icon: "x",
      attrs: this.v3 ? void 0 : {
        icon: "x",
        svgIcon: xIcon,
        shape: null,
        fillMode: "flat",
        size: size2,
        "aria-label": title,
        title
      },
      svgIcon: xIcon,
      shape: null,
      fillMode: "flat",
      size: size2,
      onClick: this.onClear,
      on: this.v3 ? void 0 : {
        "click": this.onClear
      },
      "aria-label": title,
      title
    })]);
  }
};
var SignatureBottomActions = SignatureBottomActionsVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/signature/SignatureLine.js
var allVue48 = vue_runtime_esm_bundler_exports;
var gh48 = allVue48.h;
var isV348 = allVue48.version && allVue48.version[0] === "3";
var SignatureLineVue2 = {
  name: "KendoSignatureLine",
  // @ts-ignore
  setup: !isV348 ? void 0 : function() {
    var v3 = !!isV348;
    return {
      v3
    };
  },
  render: function render31(createElement) {
    var h = gh48 || createElement;
    return h("div", {
      "class": "k-signature-line",
      style: {
        zIndex: 2,
        pointerEvents: "none"
      }
    });
  }
};
var SignatureLine = SignatureLineVue2;

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/parsing/result.js
var ResultType2;
(function(ResultType3) {
  ResultType3[ResultType3["Literal"] = 0] = "Literal";
  ResultType3[ResultType3["Mask"] = 1] = "Mask";
  ResultType3[ResultType3["Undefined"] = 2] = "Undefined";
})(ResultType2 || (ResultType2 = {}));
var Result2 = (
  /** @class */
  function() {
    function Result3(value2, rest, type) {
      if (type === void 0) {
        type = ResultType2.Undefined;
      }
      this.value = value2;
      this.rest = rest;
      this.type = type;
    }
    Result3.prototype.map = function(fn) {
      return new Result3(fn(this.value), this.rest);
    };
    Result3.prototype.chain = function(fn) {
      return fn(this.value, this.rest);
    };
    Result3.prototype.fold = function(s, _) {
      return s(this.value, this.rest);
    };
    Result3.prototype.concat = function(r) {
      return this.map(function(vs, _) {
        return r.chain(function(v, __) {
          return vs.concat([v]);
        });
      });
    };
    Result3.prototype.toString = function() {
      return "Result({ value: '".concat(this.value, "', rest: ").concat(this.rest, " })");
    };
    return Result3;
  }()
);

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/parsing/stream.js
var Stream2 = (
  /** @class */
  function() {
    function Stream3(input, control) {
      if (input === void 0) {
        input = [];
      }
      if (control === void 0) {
        control = [];
      }
      this.input = input;
      this.control = control;
      this.inputCursor = 0;
      this.controlCursor = 0;
    }
    Stream3.prototype.eof = function() {
      return this.inputCursor >= this.input.length;
    };
    Stream3.prototype.next = function() {
      return {
        char: this.input[this.inputCursor++],
        control: this.control[this.controlCursor++]
      };
    };
    Stream3.prototype.peek = function() {
      return {
        char: this.input[this.inputCursor],
        control: this.control[this.controlCursor]
      };
    };
    Stream3.prototype.eat_input = function() {
      this.inputCursor++;
    };
    Stream3.prototype.eat_control = function() {
      this.controlCursor++;
    };
    Stream3.prototype.eat = function() {
      this.inputCursor++;
      this.controlCursor++;
    };
    return Stream3;
  }()
);

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/parsing/parsers.js
var toArray2 = function(value2) {
  return (value2 || "").split("");
};
var ESCAPE_CHARACTER2 = "\\";
var Parser2 = (
  /** @class */
  function() {
    function Parser3(parse) {
      this.parse = parse;
    }
    Parser3.prototype.run = function(input, control) {
      if (control === void 0) {
        control = "";
      }
      if (input instanceof Stream2) {
        return this.parse(input);
      } else {
        return this.parse(new Stream2(toArray2(input), toArray2(control)));
      }
    };
    Parser3.prototype.map = function(f) {
      var _this = this;
      return new Parser3(function(stream) {
        return _this.parse(stream).map(f);
      });
    };
    Parser3.prototype.chain = function(f) {
      var _this = this;
      return new Parser3(function(stream) {
        return _this.parse(stream).chain(function(v, s) {
          return f(v).run(s);
        });
      });
    };
    Parser3.prototype.isLiteral = function(c) {
      return this.run(c).type === ResultType2.Literal;
    };
    return Parser3;
  }()
);
var mask3 = function(_a5) {
  var prompt2 = _a5.prompt, promptPlaceholder2 = _a5.promptPlaceholder;
  return function(rule) {
    return new Parser2(function(stream) {
      while (!stream.eof()) {
        var _a6 = stream.peek(), char = _a6.char, control = _a6.control;
        if (char === control && control === prompt2) {
          stream.eat();
          return new Result2(prompt2, stream, ResultType2.Mask);
        }
        if (rule.test(char)) {
          stream.eat();
          return new Result2(char, stream, ResultType2.Mask);
        }
        if (char === promptPlaceholder2) {
          stream.eat();
          return new Result2(prompt2, stream, ResultType2.Mask);
        }
        stream.eat_input();
      }
      stream.eat();
      return new Result2(prompt2, stream, ResultType2.Mask);
    });
  };
};
var literal2 = function(_token) {
  return new Parser2(function(stream) {
    var char = stream.peek().char;
    if (char === _token) {
      stream.eat();
      return new Result2(_token, stream, ResultType2.Literal);
    }
    return new Result2(_token, stream, ResultType2.Literal);
  });
};
var unmask2 = function(prompt2) {
  return function(rule) {
    return new Parser2(function(stream) {
      while (!stream.eof()) {
        var _a5 = stream.peek(), char = _a5.char, control = _a5.control;
        if (char === prompt2 && control === prompt2) {
          stream.eat();
          return new Result2(char, stream);
        }
        if (rule.test(char)) {
          stream.eat();
          return new Result2(char, stream);
        }
        stream.eat_input();
      }
      stream.eat();
      return new Result2("", stream);
    });
  };
};
var unliteral2 = function(_token) {
  return new Parser2(function(stream) {
    if (stream.eof()) {
      return new Result2("", stream);
    }
    var char = stream.peek().char;
    if (char === _token) {
      stream.eat();
    }
    return new Result2(_token, stream);
  });
};
var token2 = function(rules2, creator) {
  return new Parser2(function(stream) {
    var char = stream.next().char;
    var rule = rules2[char];
    if (char === ESCAPE_CHARACTER2) {
      char = stream.next().char;
      return new Result2(creator.literal(char), stream);
    }
    if (!rule) {
      return new Result2(creator.literal(char), stream);
    }
    return new Result2(creator.mask(rule), stream);
  });
};
var rawMask2 = function(_a5) {
  var prompt2 = _a5.prompt, promptPlaceholder2 = _a5.promptPlaceholder;
  return new Parser2(function(stream) {
    var char = stream.next().char;
    if (char === prompt2) {
      return new Result2(promptPlaceholder2, stream);
    }
    return new Result2(char, stream);
  });
};
var rawLiteral2 = function(includeLiterals2) {
  return new Parser2(function(stream) {
    var char = stream.next().char;
    if (includeLiterals2) {
      return new Result2(char, stream);
    }
    return new Result2("", stream);
  });
};

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/parsing/combinators.js
var always2 = function(value2) {
  return new Parser2(function(stream) {
    return new Result2(value2, stream);
  });
};
var append3 = function(p1, p2) {
  return p1.chain(function(vs) {
    return p2.map(function(v) {
      return vs.concat([v]);
    });
  });
};
var sequence2 = function(list) {
  return list.reduce(function(acc, parser) {
    return append3(acc, parser);
  }, always2([]));
};
var greedy2 = function(parser) {
  return new Parser2(function(stream) {
    var result = new Result2([], stream);
    while (!stream.eof()) {
      result = result.concat(parser.run(stream));
    }
    return result;
  });
};

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/masking.service.js
var MaskingService2 = (
  /** @class */
  function() {
    function MaskingService3() {
      this.rules = {};
      this.prompt = "_";
      this.mask = "";
      this.promptPlaceholder = " ";
      this.includeLiterals = false;
      this.maskTokens = [];
      this.unmaskTokens = [];
      this.rawTokens = [];
      this.validationTokens = [];
    }
    MaskingService3.prototype.update = function(_a5) {
      var _b = _a5.mask, mask4 = _b === void 0 ? "" : _b, _c = _a5.prompt, prompt2 = _c === void 0 ? "" : _c, _d = _a5.promptPlaceholder, promptPlaceholder2 = _d === void 0 ? " " : _d, _e = _a5.rules, rules2 = _e === void 0 ? {} : _e, _f = _a5.includeLiterals, includeLiterals2 = _f === void 0 ? false : _f;
      this.mask = mask4;
      this.prompt = prompt2;
      this.promptPlaceholder = promptPlaceholder2;
      this.rules = rules2;
      this.includeLiterals = includeLiterals2;
      this.tokenize();
    };
    MaskingService3.prototype.validationValue = function(maskedValue) {
      if (maskedValue === void 0) {
        maskedValue = "";
      }
      var value2 = maskedValue;
      sequence2(this.validationTokens).run(maskedValue).fold(function(unmasked) {
        value2 = unmasked.join("");
      });
      return value2;
    };
    MaskingService3.prototype.rawValue = function(maskedValue) {
      if (maskedValue === void 0) {
        maskedValue = "";
      }
      var value2 = maskedValue;
      if (!this.rawTokens.length) {
        return value2;
      }
      sequence2(this.rawTokens).run(maskedValue).fold(function(unmasked) {
        value2 = unmasked.join("");
      });
      return value2;
    };
    MaskingService3.prototype.maskRaw = function(rawValue2) {
      if (rawValue2 === void 0) {
        rawValue2 = "";
      }
      var value2 = rawValue2;
      if (!this.maskTokens.length) {
        return value2;
      }
      sequence2(this.maskTokens).run(rawValue2).fold(function(masked) {
        value2 = masked.join("");
      });
      return value2;
    };
    MaskingService3.prototype.maskInput = function(input, control, splitPoint) {
      if (input.length < control.length) {
        return this.maskRemoved(input, control, splitPoint);
      }
      return this.maskInserted(input, control, splitPoint);
    };
    MaskingService3.prototype.maskInRange = function(pasted, oldValue, start, end) {
      var value2 = "";
      var selection2 = end;
      var beforeChange = oldValue.split("").slice(0, start);
      var afterChange = oldValue.split("").slice(end);
      sequence2(this.maskTokens.slice(start, end)).run(pasted).fold(function(masked) {
        value2 = beforeChange.concat(masked).concat(afterChange).join("");
      });
      return {
        selection: selection2,
        value: value2
      };
    };
    MaskingService3.prototype.maskRemoved = function(input, control, splitPoint) {
      var _this = this;
      var value2 = "";
      var selection2 = splitPoint;
      var unchanged = input.split("").slice(splitPoint);
      var changed = input.split("").slice(0, splitPoint).join("");
      var take = this.maskTokens.length - (input.length - splitPoint);
      sequence2(this.maskTokens.slice(0, take)).run(changed, control).fold(function(masked) {
        selection2 = _this.adjustPosition(masked, selection2);
        value2 = masked.concat(unchanged).join("");
      });
      return {
        selection: selection2,
        value: value2
      };
    };
    MaskingService3.prototype.adjustPosition = function(input, selection2) {
      var caretChar = input[selection2];
      var isLiteral = this.maskTokens[selection2].isLiteral(caretChar);
      if (!isLiteral && caretChar !== this.prompt) {
        return selection2 + 1;
      }
      return selection2;
    };
    MaskingService3.prototype.maskInserted = function(input, control, splitPoint) {
      var _this = this;
      var value2 = "";
      var selection2 = splitPoint;
      var changed = input.slice(0, splitPoint);
      sequence2(this.unmaskTokens).run(changed, control).chain(function(unmasked) {
        selection2 = unmasked.join("").length;
        var unchanged = control.slice(selection2);
        return sequence2(_this.maskTokens).run(unmasked.join("") + unchanged, control);
      }).fold(function(masked) {
        value2 = masked.join("");
      });
      return {
        selection: selection2,
        value: value2
      };
    };
    Object.defineProperty(MaskingService3.prototype, "maskTokenCreator", {
      get: function() {
        var _a5 = this, prompt2 = _a5.prompt, promptPlaceholder2 = _a5.promptPlaceholder;
        return {
          literal: function(rule) {
            return literal2(rule);
          },
          mask: function(rule) {
            return mask3({ prompt: prompt2, promptPlaceholder: promptPlaceholder2 })(rule);
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MaskingService3.prototype, "unmaskTokenCreator", {
      get: function() {
        var _this = this;
        return {
          literal: function(rule) {
            return unliteral2(rule);
          },
          mask: function(rule) {
            return unmask2(_this.prompt)(rule);
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MaskingService3.prototype, "rawTokenCreator", {
      get: function() {
        var _a5 = this, prompt2 = _a5.prompt, promptPlaceholder2 = _a5.promptPlaceholder, includeLiterals2 = _a5.includeLiterals;
        return {
          literal: function(_) {
            return rawLiteral2(includeLiterals2);
          },
          mask: function(_) {
            return rawMask2({ prompt: prompt2, promptPlaceholder: promptPlaceholder2 });
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MaskingService3.prototype, "validationTokenCreator", {
      get: function() {
        var prompt2 = this.prompt;
        return {
          literal: function(_) {
            return rawLiteral2(false);
          },
          mask: function(_) {
            return rawMask2({ prompt: prompt2, promptPlaceholder: "" });
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MaskingService3.prototype.tokenize = function() {
      var _this = this;
      greedy2(token2(this.rules, this.maskTokenCreator)).run(this.mask).fold(function(tokens, _) {
        _this.maskTokens = tokens;
      });
      greedy2(token2(this.rules, this.unmaskTokenCreator)).run(this.mask).fold(function(tokens, _) {
        _this.unmaskTokens = tokens;
      });
      greedy2(token2(this.rules, this.rawTokenCreator)).run(this.mask).fold(function(tokens, _) {
        _this.rawTokens = tokens;
      });
      greedy2(token2(this.rules, this.validationTokenCreator)).run(this.mask).fold(function(tokens, _) {
        _this.validationTokens = tokens;
      });
    };
    return MaskingService3;
  }()
);

// node_modules/@progress/kendo-inputs-common/dist/es/common/drawing-utils.js
var _a4 = drawing_exports.util;
var elementOffset2 = _a4.elementOffset;
var limitValue2 = _a4.limitValue;

// node_modules/@progress/kendo-inputs-common/dist/es/signature/signature-pad.js
var Point2 = geometry_exports.Point;
var Rect3 = geometry_exports.Rect;
var transform2 = geometry_exports.transform;
var noop2 = function() {
};
var DECIMAL_DIGITS = 3;
var DEFAULT_COLOR = "#000";
var DEFAULT_BACKGROUND_COLOR = "#fff";
var DEFAULT_PRECISION = 1;
var DEFAULT_SAMPLING_RATE = 200;
var DEFAULT_STROKE_WIDTH = 1;
var DEFAULT_WIDTH = 750;
var DEFAULT_HEIGHT = 250;
var DEFAULT_SCALE = 1;
var DEFAULT_EXPORT_SCALE = 6;
var SignaturePad = (
  /** @class */
  function() {
    function SignaturePad2(element2, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      this.element = element2;
      this.lastMoveTime = 0;
      this.resolveColors(options2);
      this.options = Object.assign({
        scale: DEFAULT_SCALE,
        precision: DEFAULT_PRECISION,
        samplingRate: DEFAULT_SAMPLING_RATE,
        smooth: options2.smooth !== false,
        color: DEFAULT_COLOR,
        backgroundColor: DEFAULT_BACKGROUND_COLOR,
        strokeWidth: DEFAULT_STROKE_WIDTH,
        onChange: noop2,
        onDraw: noop2,
        onDrawEnd: noop2
      }, options2, {
        color: this.color,
        backgroundColor: this.backgroundColor
      });
      this.pathOptions = {
        stroke: {
          color: this.options.color,
          width: this.options.strokeWidth,
          lineCap: "round",
          lineJoin: "round"
        }
      };
      this.initSurface();
      this.attachEvents();
    }
    SignaturePad2.prototype.destroy = function() {
      this.detachEvents();
    };
    SignaturePad2.prototype.clear = function() {
      this.rootGroup.clear();
      this.path = null;
    };
    SignaturePad2.prototype.readThemeColors = function() {
      var themeColor;
      var themeBackgroundColor;
      if (typeof document !== "undefined") {
        var themeElement = this.element.closest(".k-signature") || this.element;
        var computedStyle = themeElement.ownerDocument.defaultView.getComputedStyle(themeElement);
        themeColor = computedStyle.color;
        themeBackgroundColor = computedStyle.backgroundColor;
      }
      this.themeColor = themeColor || this.themeColor || DEFAULT_COLOR;
      this.themeBackgroundColor = themeBackgroundColor || this.themeBackgroundColor || DEFAULT_BACKGROUND_COLOR;
    };
    SignaturePad2.prototype.resolveColors = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      this.readThemeColors();
      this.color = options2.color || (this.options || {}).color || this.themeColor;
      this.backgroundColor = options2.backgroundColor || (this.options || {}).backgroundColor || this.themeBackgroundColor;
    };
    Object.defineProperty(SignaturePad2.prototype, "isDrawing", {
      /* eslint-enable @typescript-eslint/no-explicit-any */
      get: function() {
        return Boolean(this.points);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SignaturePad2.prototype, "pathData", {
      get: function() {
        var _a5;
        return (_a5 = this.path) === null || _a5 === void 0 ? void 0 : _a5.toString(DECIMAL_DIGITS);
      },
      set: function(value2) {
        this.clear();
        this.path = MultiPath.parse(value2, this.pathOptions);
        this.rootGroup.append(this.path);
      },
      enumerable: false,
      configurable: true
    });
    SignaturePad2.prototype.loadImage = function(data23, size2) {
      if (size2 === void 0) {
        size2 = [];
      }
      if (!data23) {
        this.clear();
        return;
      }
      var _a5 = this.size, width = _a5[0], height = _a5[1];
      var contentWidth = width / this.options.scale;
      var contentHeight = height / this.options.scale;
      var importWidth = size2[0] || contentWidth * DEFAULT_EXPORT_SCALE;
      var importHeight = size2[1] || contentHeight * DEFAULT_EXPORT_SCALE;
      var scaleX = contentWidth / importWidth;
      var scaleY = contentHeight / importHeight;
      var scale = Math.min(scaleX, scaleY);
      var img = new image_default(data23, new geometry_exports.Rect([0, 0], [importWidth, importHeight]));
      img.transform(transform2().scale(scale, scale));
      this.clear();
      this.rootGroup.append(img);
    };
    SignaturePad2.prototype.exportImage = function(options2) {
      var _a5;
      var _b = this.size, width = _b[0], height = _b[1];
      var contentWidth = width / this.options.scale;
      var contentHeight = height / this.options.scale;
      var exportWidth = (options2 === null || options2 === void 0 ? void 0 : options2.width) || contentWidth * DEFAULT_EXPORT_SCALE;
      var exportHeight = (options2 === null || options2 === void 0 ? void 0 : options2.height) || contentHeight * DEFAULT_EXPORT_SCALE;
      var scaleX = exportWidth / contentWidth;
      var scaleY = exportHeight / contentHeight;
      var scale = Math.min(scaleX, scaleY);
      var exportRect = new Rect3([0, 0], [exportWidth, exportHeight]);
      var exportGroup2 = new group_default({
        clip: Path.fromRect(exportRect)
      });
      var contentGroup = new group_default({
        transform: transform2().scale(scale, scale)
      });
      var frame = Path.fromRect(exportRect, {
        fill: {
          color: this.options.backgroundColor
        }
      });
      exportGroup2.append(frame);
      exportGroup2.append(contentGroup);
      (_a5 = contentGroup.children).push.apply(_a5, this.rootGroup.children);
      return exportImage(exportGroup2, Object.assign({
        width: exportWidth,
        height: exportHeight
      }, options2));
    };
    SignaturePad2.prototype.resize = function() {
      this.surface.resize(true);
    };
    SignaturePad2.prototype.setOptions = function(options2) {
      this.resolveColors(options2);
      Object.assign(this.options, options2, {
        color: this.color,
        backgroundColor: this.backgroundColor
      });
      this.pathOptions.stroke.color = this.options.color;
      this.pathOptions.stroke.width = this.options.strokeWidth;
      if (this.path) {
        this.path.options.set("stroke.color", this.options.color);
        this.path.options.set("stroke.width", this.options.strokeWidth);
      }
      this.background.options.set("fill.color", this.options.backgroundColor);
    };
    SignaturePad2.prototype.initSurface = function() {
      this.surface = surface_default4.create(this.element, { type: "canvas" });
      this.element.style.touchAction = "none";
      var scale = this.options.scale;
      this.rootGroup = new group_default({
        transform: transform2().scale(scale, scale)
      });
      var width = this.element.offsetWidth || DEFAULT_WIDTH;
      var height = this.element.offsetHeight || DEFAULT_HEIGHT;
      this.size = [width, height];
      this.background = Path.fromRect(new Rect3([0, 0], this.size), {
        fill: {
          color: this.options.backgroundColor
        }
      });
      this.surface.draw(this.background);
      this.surface.draw(this.rootGroup);
    };
    SignaturePad2.prototype.attachEvents = function() {
      this.onPointerDown = this.onPointerDown.bind(this);
      this.onPointerMove = this.onPointerMove.bind(this);
      this.onPointerUp = this.onPointerUp.bind(this);
      this.onDragStart = this.onDragStart.bind(this);
      this.element.addEventListener("pointerdown", this.onPointerDown);
      this.element.addEventListener("pointerup", this.onPointerUp);
      this.element.addEventListener("dragstart", this.onDragStart);
    };
    SignaturePad2.prototype.detachEvents = function() {
      this.element.removeEventListener("pointerdown", this.onPointerDown);
      this.detachPointerMove();
      this.element.removeEventListener("pointerup", this.onPointerUp);
      this.element.removeEventListener("dragstart", this.onDragStart);
    };
    SignaturePad2.prototype.attachPointerMove = function() {
      this.element.addEventListener("pointermove", this.onPointerMove);
    };
    SignaturePad2.prototype.detachPointerMove = function() {
      this.element.removeEventListener("pointermove", this.onPointerMove);
    };
    SignaturePad2.prototype.touchPoint = function(e) {
      var offset = elementOffset2(this.element);
      var pageX = e.pageX;
      var pageY = e.pageY;
      var scale = 1 / this.options.scale;
      return new Point2(pageX - offset.left, pageY - offset.top).scale(scale, scale);
    };
    SignaturePad2.prototype.onDragStart = function(e) {
      e.preventDefault();
    };
    SignaturePad2.prototype.onPointerDown = function(e) {
      if (this.options.readonly || !e.isPrimary || !isMainButton(e)) {
        return;
      }
      this.detachPointerMove();
      this.attachPointerMove();
      if (!this.path) {
        this.path = new MultiPath(this.pathOptions);
        this.rootGroup.append(this.path);
      }
      this.options.onDraw();
      this.element.setPointerCapture(e.pointerId);
      var point2 = this.touchPoint(e);
      this.points = [point2];
      this.path.moveTo(point2);
    };
    SignaturePad2.prototype.onPointerMove = function(e) {
      if (!this.points || !this.path || !e.isPrimary) {
        return;
      }
      var now2 = (/* @__PURE__ */ new Date()).getTime();
      var elapsed = now2 - this.lastMoveTime;
      var minTimeDelta = 1e3 / limitValue2(this.options.samplingRate, 1, 1e4);
      if (elapsed < minTimeDelta) {
        return;
      } else {
        this.lastMoveTime = now2;
      }
      var point2 = this.touchPoint(e);
      var lastPoint = this.points[this.points.length - 1];
      var minDelta = 1 / limitValue2(this.options.precision, 0.01, 100);
      if (point2.distanceTo(lastPoint) < minDelta) {
        return;
      }
      this.points.push(point2);
      this.path.lineTo(point2);
    };
    SignaturePad2.prototype.onPointerUp = function(e) {
      if (!e.isPrimary || !this.path || !this.points || this.options.readonly) {
        return;
      }
      this.detachPointerMove();
      if (this.options.smooth) {
        var segments = Path.curveFromPoints(this.points);
        this.path.paths.splice(this.path.paths.length - 1, 1, segments);
      }
      this.points = null;
      this.options.onDrawEnd();
      this.options.onChange(this.pathData);
    };
    return SignaturePad2;
  }()
);
function isMainButton(e) {
  return typeof e.button !== "number" || e.button === 0;
}

// node_modules/@progress/kendo-vue-inputs/dist/es/signature/SignatureCanvas.js
var allVue49 = vue_runtime_esm_bundler_exports;
var gh49 = allVue49.h;
var isV349 = allVue49.version && allVue49.version[0] === "3";
var ref17 = allVue49.ref;
var setOptions = function setOptions2() {
  if (this.instance) {
    this.instance.setOptions(this.getOptions());
  }
};
var SignatureCanvasVue2 = {
  name: "KendoSignatureCanvas",
  // @ts-ignore
  emits: {
    change: null,
    draw: null,
    drawend: null
  },
  inject: {
    kendoIntlService: {
      default: null
    }
  },
  props: {
    strokeWidth: Number,
    popupScale: Number,
    scale: Number,
    name: String,
    value: String,
    tabIndex: Number,
    disabled: Boolean,
    readOnly: Boolean,
    color: String,
    backgroundColor: String,
    elementSize: Function,
    smooth: Boolean
  },
  watch: {
    color: setOptions,
    backgroundColor: setOptions,
    smooth: setOptions,
    strokeWidth: setOptions,
    readOnly: setOptions
  },
  mounted: function mounted19() {
    this.canvas = this.$el;
    var pad = new SignaturePad(this.canvas, this.getOptions());
    if (this.value) {
      pad.loadImage(this.value);
    }
    this.instance = pad;
    this.instance.setOptions({
      onChange: this.onValueChange,
      onDraw: this.onDraw,
      onDrawEnd: this.onDrawEnd
    });
  },
  destroyed: !!isV349 ? void 0 : function() {
    if (this.instance) {
      this.instance.destroy();
    }
  },
  // @ts-ignore
  unmounted: function unmounted() {
    if (this.instance) {
      this.instance.destroy();
    }
  },
  // @ts-ignore
  setup: !isV349 ? void 0 : function() {
    var v3 = !!isV349;
    return {
      v3
    };
  },
  render: function render32(createElement) {
    var h = gh49 || createElement;
    return h("div", {
      "class": "k-signature-canvas",
      tabIndex: getTabIndex(this.$props.tabIndex, this.$props.disabled),
      attrs: this.v3 ? void 0 : {
        tabIndex: getTabIndex(this.$props.tabIndex, this.$props.disabled),
        role: "img",
        id: this.$props.id,
        name: this.$props.name,
        "aria-label": this.$props.ariaLabel,
        "aria-labelledby": this.$props.ariaLabelledBy,
        "aria-describedby": this.$props.ariaDescribedBy,
        "aria-disabled": this.$props.disabled ? "true" : void 0
      },
      role: "img",
      id: this.$props.id,
      name: this.$props.name,
      "aria-label": this.$props.ariaLabel,
      "aria-labelledby": this.$props.ariaLabelledBy,
      "aria-describedby": this.$props.ariaDescribedBy,
      "aria-disabled": this.$props.disabled ? "true" : void 0
    });
  },
  methods: {
    onValueChange: function onValueChange() {
      var that = this;
      this.exportImage(this.elementSize()).then(function(nextValue) {
        that.$emit("change", nextValue);
      });
    },
    onDraw: function onDraw() {
      this.$emit("draw");
    },
    onDrawEnd: function onDrawEnd() {
      this.$emit("drawend");
    },
    loadImage: function loadImage(newLocale) {
      this.instance.loadImage(newLocale);
    },
    clear: function clear() {
      this.instance.clear();
    },
    getOptions: function getOptions() {
      return {
        scale: this.popupScale,
        color: this.color,
        backgroundColor: this.backgroundColor,
        strokeWidth: this.$props.strokeWidth,
        smooth: this.$props.smooth,
        readonly: this.$props.readOnly
      };
    },
    exportImage: function exportImage2(exportSize) {
      var _a5;
      var width = exportSize.width, height = exportSize.height;
      return (_a5 = this.instance) === null || _a5 === void 0 ? void 0 : _a5.exportImage({
        width: width * this.scale,
        height: height * this.scale
      });
    }
  }
};
var SignatureCanvas = SignatureCanvasVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/signature/SignatureDialog.js
var allVue50 = vue_runtime_esm_bundler_exports;
var gh50 = allVue50.h;
var isV350 = allVue50.version && allVue50.version[0] === "3";
var SignatureDialogVue2 = {
  name: "KendoSignatureDialog",
  // @ts-ignore
  emits: {
    change: null,
    clear: null,
    close: null,
    focus: null,
    blur: null,
    overlayclick: null,
    draw: null,
    drawend: null
  },
  props: {
    openWrapperClass: Object,
    size: String,
    dir: String,
    popupWidth: Number,
    popupHeight: Number,
    showClear: Boolean,
    strokeWidth: Number,
    popupScale: Number,
    scale: Number,
    value: String,
    tabIndex: Number,
    disabled: Boolean,
    readOnly: Boolean,
    color: String,
    backgroundColor: String,
    elementSize: Function,
    smooth: Boolean
  },
  inject: {
    kendoLocalizationService: {
      default: null
    }
  },
  data: function data21() {
    return {
      isDrawing: false
    };
  },
  mounted: function mounted20() {
    this.openCanvas = getRef(this, "openCanvas");
  },
  // @ts-ignore
  setup: !isV350 ? void 0 : function() {
    var v3 = !!isV350;
    return {
      v3
    };
  },
  render: function render33(createElement) {
    var _this = this;
    var h = gh50 || createElement;
    var _a5 = this.$props, showClear = _a5.showClear, popupWidth = _a5.popupWidth, popupHeight = _a5.popupHeight, dir = _a5.dir, size2 = _a5.size, value2 = _a5.value, tabIndex = _a5.tabIndex, disabled = _a5.disabled, readOnly = _a5.readOnly, color = _a5.color, backgroundColor = _a5.backgroundColor, strokeWidth = _a5.strokeWidth, smooth = _a5.smooth, popupScale = _a5.popupScale, scale = _a5.scale, elementSize3 = _a5.elementSize;
    var ls = provideLocalizationService(this);
    var minimizeTitle = ls.toLanguageString(signatureMinimize, messages2[signatureMinimize]);
    var clearTitle = ls.toLanguageString(signatureClear, messages2[signatureClear]);
    var hideLine = !this.$props.hideLine && h(SignatureLine);
    var bottomActions = h(SignatureBottomActions, {
      showClear,
      attrs: this.v3 ? void 0 : {
        showClear,
        size: size2,
        title: clearTitle
      },
      size: size2,
      onClear: this.onClear,
      on: this.v3 ? void 0 : {
        "clear": this.onClear
      },
      title: clearTitle
    });
    var dialog = (
      // @ts-ignore function children
      h(Dialog, {
        ref: setRef(this, "dialog"),
        onOverlayclick: this.onOverlayClick,
        on: this.v3 ? void 0 : {
          "overlayclick": this.onOverlayClick
        }
      }, this.v3 ? function() {
        return [h("div", {
          style: {
            width: popupWidth + "px",
            height: popupHeight + "px"
          },
          dir,
          attrs: _this.v3 ? void 0 : {
            dir
          },
          "class": _this.openWrapperClass,
          onFocus: _this.onFocus,
          on: _this.v3 ? void 0 : {
            "focus": _this.onFocus,
            "blur": _this.onBlur
          },
          onBlur: _this.onBlur
        }, [h(SignatureCanvas, {
          ref: setRef(_this, "openCanvas"),
          value: value2,
          attrs: _this.v3 ? void 0 : {
            value: value2,
            tabIndex,
            disabled,
            readOnly,
            color,
            backgroundColor,
            strokeWidth,
            smooth,
            popupScale,
            scale,
            elementSize: elementSize3
          },
          tabIndex,
          disabled,
          readOnly,
          color,
          backgroundColor,
          strokeWidth,
          smooth,
          popupScale,
          scale,
          onChange: _this.onValueChange,
          on: _this.v3 ? void 0 : {
            "change": _this.onValueChange,
            "draw": _this.onDraw,
            "drawend": _this.onDrawEnd
          },
          elementSize: elementSize3,
          onDraw: _this.onDraw,
          onDrawend: _this.onDrawEnd
        }), h("div", {
          "class": "k-signature-actions k-signature-actions-top"
        }, [!_this.isDrawing && // @ts-ignore
        h(Button, {
          "class": "k-signature-action k-signature-minimize k-rotate-180",
          ref: setRef(_this, "minimizeButton"),
          icon: "hyperlink-open",
          attrs: _this.v3 ? void 0 : {
            icon: "hyperlink-open",
            svgIcon: hyperlinkOpenIcon,
            shape: null,
            fillMode: "flat",
            size: _this.$props.size,
            "aria-label": minimizeTitle,
            title: minimizeTitle
          },
          svgIcon: hyperlinkOpenIcon,
          shape: null,
          fillMode: "flat",
          size: _this.$props.size,
          onClick: _this.onMinimizeClick,
          on: _this.v3 ? void 0 : {
            "click": _this.onMinimizeClick
          },
          "aria-label": minimizeTitle,
          title: minimizeTitle
        })]), hideLine, bottomActions])];
      } : [h("div", {
        style: {
          width: popupWidth + "px",
          height: popupHeight + "px"
        },
        dir,
        attrs: _this.v3 ? void 0 : {
          dir
        },
        "class": _this.openWrapperClass,
        onFocus: _this.onFocus,
        on: _this.v3 ? void 0 : {
          "focus": _this.onFocus,
          "blur": _this.onBlur
        },
        onBlur: _this.onBlur
      }, [h(SignatureCanvas, {
        ref: setRef(_this, "openCanvas"),
        value: value2,
        attrs: _this.v3 ? void 0 : {
          value: value2,
          tabIndex,
          disabled,
          readOnly,
          color,
          backgroundColor,
          strokeWidth,
          smooth,
          popupScale,
          scale,
          elementSize: elementSize3
        },
        tabIndex,
        disabled,
        readOnly,
        color,
        backgroundColor,
        strokeWidth,
        smooth,
        popupScale,
        scale,
        onChange: _this.onValueChange,
        on: _this.v3 ? void 0 : {
          "change": _this.onValueChange,
          "draw": _this.onDraw,
          "drawend": _this.onDrawEnd
        },
        elementSize: elementSize3,
        onDraw: _this.onDraw,
        onDrawend: _this.onDrawEnd
      }), h("div", {
        "class": "k-signature-actions k-signature-actions-top"
      }, [!_this.isDrawing && h(Button, {
        "class": "k-signature-action k-signature-minimize k-rotate-180",
        ref: setRef(_this, "minimizeButton"),
        icon: "hyperlink-open",
        attrs: _this.v3 ? void 0 : {
          icon: "hyperlink-open",
          svgIcon: hyperlinkOpenIcon,
          shape: null,
          fillMode: "flat",
          size: _this.$props.size,
          "aria-label": minimizeTitle,
          title: minimizeTitle
        },
        svgIcon: hyperlinkOpenIcon,
        shape: null,
        fillMode: "flat",
        size: _this.$props.size,
        onClick: _this.onMinimizeClick,
        on: _this.v3 ? void 0 : {
          "click": _this.onMinimizeClick
        },
        "aria-label": minimizeTitle,
        title: minimizeTitle
      })]), hideLine, bottomActions])])
    );
    return dialog;
  },
  methods: {
    onDraw: function onDraw2() {
      this.isDrawing = true;
      this.$emit("draw");
    },
    onDrawEnd: function onDrawEnd2() {
      this.isDrawing = false;
      this.$emit("drawend");
    },
    onValueChange: function onValueChange2(nextValue) {
      this.$emit("change", nextValue);
    },
    onClear: function onClear2() {
      this.$emit("clear");
    },
    onMinimizeClick: function onMinimizeClick() {
      this.$emit("close");
    },
    onFocus: function onFocus6(e) {
      this.$emit("focus", e);
    },
    onBlur: function onBlur6(e) {
      this.$emit("blur", e);
    },
    onOverlayClick: function onOverlayClick(e) {
      this.$emit("overlayclick", e);
    }
  }
};
var SignatureDialog = SignatureDialogVue2;

// node_modules/@progress/kendo-vue-inputs/dist/es/signature/utils/main.js
function hasParent(element2, parent) {
  var current = element2;
  while (current && current !== parent) {
    current = current.parentNode;
  }
  return current ? true : false;
}

// node_modules/@progress/kendo-vue-inputs/dist/es/signature/Signature.js
var __assign11 = function() {
  __assign11 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return __assign11.apply(this, arguments);
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  }, f, y, t, g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var allVue51 = vue_runtime_esm_bundler_exports;
var gh51 = allVue51.h;
var isV351 = allVue51.version && allVue51.version[0] === "3";
var ref18 = allVue51.ref;
var DEFAULT_WIDTH2 = 250;
var DEFAULT_HEIGHT2 = 84;
var DEFAULT_POPUP_SCALE = 3;
var DEFAULT_EXPORT_SCALE2 = 2;
var DEFAULT_COLOR2 = "#000000";
var DEFAULT_BACKGROUND_COLOR2 = "#ffffff";
var SignatureVue2 = {
  name: "KendoSignature",
  model: {
    event: "changemodel"
  },
  // @ts-ignore
  emits: {
    change: null,
    focus: null,
    blur: null,
    open: null,
    close: null,
    "changemodel": null,
    "update:modelValue": null
  },
  inject: {
    kendoLocalizationService: {
      default: null
    }
  },
  props: {
    strokeWidth: {
      type: Number,
      default: 1
    },
    smooth: Boolean,
    popupScale: {
      type: Number,
      default: DEFAULT_POPUP_SCALE
    },
    exportScale: {
      type: Number,
      default: DEFAULT_EXPORT_SCALE2
    },
    modelValue: String,
    name: String,
    value: String,
    tabIndex: Number,
    dir: String,
    ariaDescribedBy: String,
    ariaLabelledBy: String,
    ariaLabel: String,
    hideLine: Boolean,
    open: {
      type: Boolean,
      default: void 0
    },
    readOnly: Boolean,
    disabled: Boolean,
    validationMessage: String,
    maximizable: {
      type: Boolean,
      default: true
    },
    color: String,
    backgroundColor: String,
    validityStyles: {
      type: Boolean,
      default: true
    },
    required: {
      type: Boolean,
      default: false
    },
    valid: {
      type: Boolean,
      default: void 0
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator34(value2) {
        return [null, "small", "medium", "large"].includes(value2);
      }
    },
    rounded: {
      type: String,
      default: "medium",
      validator: function validator35(value2) {
        return [null, "small", "medium", "large"].includes(value2);
      }
    },
    fillMode: {
      type: String,
      default: "solid",
      validator: function validator36(value2) {
        return [null, "solid", "flat", "outline"].includes(value2);
      }
    }
  },
  created: function created23() {
    validatePackage(packageMetadata);
  },
  computed: {
    wrapperClass: function wrapperClass() {
      return __assign11(__assign11({}, this.openWrapperClass), {
        "k-signature-maximized": false
      });
    },
    openWrapperClass: function openWrapperClass() {
      var _a5;
      var isValid3 = !this.validityStyles || this.validityGetter().valid;
      return _a5 = {
        "k-input": true,
        "k-signature": true,
        "k-signature-maximized": true
      }, _a5["k-signature-".concat(kendoThemeMaps.sizeMap[this.$props.size] || this.$props.size)] = this.$props.size, _a5["k-input-".concat(this.$props.fillMode)] = this.$props.fillMode, _a5["k-rounded-".concat(kendoThemeMaps.roundedMap[this.$props.rounded] || this.$props.rounded)] = this.$props.rounded, _a5["k-invalid"] = !isValid3, _a5["k-required"] = this.$props.required, _a5["k-disabled"] = this.$props.disabled, _a5["k-focus"] = this.focused, _a5;
    },
    computedValue: function computedValue10() {
      return this.value !== void 0 ? this.value : this.$props.modelValue !== void 0 ? this.$props.modelValue : this.currentValue;
    },
    computedOpen: function computedOpen2() {
      return this.open !== void 0 ? this.open : this.currentOpen;
    },
    computedColor: function computedColor2() {
      var defaultColor2 = DEFAULT_COLOR2;
      if (!this.$props.color && typeof document !== "undefined" && this.$el) {
        defaultColor2 = getComputedStyle(this.$el).color;
      }
      return this.$props.color || defaultColor2;
    },
    computedBgColor: function computedBgColor2() {
      var defaultBackgroundColor = DEFAULT_BACKGROUND_COLOR2;
      if (!this.$props.backgroundColor && typeof document !== "undefined" && this.$el) {
        defaultBackgroundColor = getComputedStyle(this.$el).backgroundColor;
      }
      return this.$props.backgroundColor || defaultBackgroundColor;
    }
  },
  watch: {
    computedValue: function computedValue11(newValue) {
      if (newValue !== this.currentValue) {
        this.loadImage(newValue);
      }
    },
    computedOpen: function computedOpen3() {
      this.loadImage(this.computedValue);
    }
  },
  data: function data22() {
    return {
      focused: false,
      isDrawing: false,
      currentValue: void 0,
      popupValue: void 0,
      currentOpen: false
    };
  },
  mounted: function mounted21() {
    this.setRefs();
  },
  updated: function updated14() {
    this.setRefs();
  },
  // @ts-ignore
  setup: !isV351 ? void 0 : function() {
    var v3 = !!isV351;
    var inputRef = ref18(null);
    return {
      v3,
      inputRef
    };
  },
  render: function render34(createElement) {
    var h = gh51 || createElement;
    var ls = provideLocalizationService(this);
    var showMaximize = !(this.computedOpen || this.isDrawing || !this.$props.maximizable || this.$props.disabled);
    var isEmpty = !this.computedValue;
    var showClear = !(isEmpty || this.isDrawing || this.$props.readOnly || this.$props.disabled);
    var maximizeTitle = ls.toLanguageString(signatureMaximize, messages2[signatureMaximize]);
    var clearTitle = ls.toLanguageString(signatureClear, messages2[signatureClear]);
    var actions = h("div", {
      "class": "k-signature-actions k-signature-actions-top"
    }, [showMaximize && // @ts-ignore
    h(Button, {
      "class": "k-signature-action k-signature-maximize",
      ref: setRef(this, "maximizeButton"),
      icon: "hyperlink-open",
      attrs: this.v3 ? void 0 : {
        icon: "hyperlink-open",
        svgIcon: hyperlinkOpenIcon,
        shape: null,
        fillMode: "flat",
        size: this.$props.size,
        "aria-label": maximizeTitle,
        title: maximizeTitle
      },
      svgIcon: hyperlinkOpenIcon,
      shape: null,
      fillMode: "flat",
      size: this.$props.size,
      onClick: this.onMaximizeClick,
      on: this.v3 ? void 0 : {
        "click": this.onMaximizeClick
      },
      "aria-label": maximizeTitle,
      title: maximizeTitle
    })]);
    var hideLine = !this.$props.hideLine && h(SignatureLine);
    var bottomActions = h(SignatureBottomActions, {
      showClear,
      attrs: this.v3 ? void 0 : {
        showClear,
        size: this.size,
        title: clearTitle
      },
      size: this.size,
      onClear: this.onClear,
      on: this.v3 ? void 0 : {
        "clear": this.onClear
      },
      title: clearTitle
    });
    return h("div", {
      dir: this.$props.dir,
      attrs: this.v3 ? void 0 : {
        dir: this.$props.dir
      },
      "class": this.wrapperClass,
      onFocus: this.onFocus,
      on: this.v3 ? void 0 : {
        "focus": this.onFocus,
        "blur": this.onBlur
      },
      onBlur: this.onBlur
    }, [h(SignatureCanvas, {
      ref: setRef(this, "canvas"),
      name: this.name,
      attrs: this.v3 ? void 0 : {
        name: this.name,
        value: this.computedValue,
        tabIndex: this.tabIndex,
        disabled: this.disabled,
        readOnly: this.readOnly,
        color: this.computedColor,
        backgroundColor: this.computedBgColor,
        strokeWidth: this.strokeWidth,
        smooth: this.smooth,
        popupScale: 1,
        scale: this.exportScale,
        elementSize: this.elementSize
      },
      value: this.computedValue,
      tabIndex: this.tabIndex,
      disabled: this.disabled,
      readOnly: this.readOnly,
      color: this.computedColor,
      backgroundColor: this.computedBgColor,
      strokeWidth: this.strokeWidth,
      smooth: this.smooth,
      popupScale: 1,
      scale: this.exportScale,
      onChange: this.onValueChange,
      on: this.v3 ? void 0 : {
        "change": this.onValueChange,
        "draw": this.onDraw,
        "drawend": this.onDrawEnd
      },
      elementSize: this.elementSize,
      onDraw: this.onDraw,
      onDrawend: this.onDrawEnd
    }), actions, hideLine, bottomActions, this.computedOpen && h(SignatureDialog, {
      ref: setRef(this, "dialog"),
      openWrapperClass: this.openWrapperClass,
      attrs: this.v3 ? void 0 : {
        openWrapperClass: this.openWrapperClass,
        popupWidth: this.popupWidth,
        popupHeight: this.popupHeight,
        showClear,
        value: this.computedValue,
        tabIndex: this.tabIndex,
        disabled: this.disabled,
        readOnly: this.readOnly,
        color: this.computedColor,
        backgroundColor: this.computedBgColor,
        strokeWidth: this.strokeWidth,
        smooth: this.smooth,
        popupScale: this.$props.popupScale,
        scale: 1 / this.popupScale * this.exportScale,
        elementSize: this.elementSize
      },
      popupWidth: this.popupWidth,
      popupHeight: this.popupHeight,
      showClear,
      onClose: this.onMinimizeClick,
      on: this.v3 ? void 0 : {
        "close": this.onMinimizeClick,
        "clear": this.onClear,
        "overlayclick": this.onOverlayClick,
        "focus": this.onFocus,
        "blur": this.onBlur,
        "change": this.onValueChange,
        "draw": this.onDraw,
        "drawend": this.onDrawEnd
      },
      onClear: this.onClear,
      onOverlayclick: this.onOverlayClick,
      onFocus: this.onFocus,
      onBlur: this.onBlur,
      value: this.computedValue,
      tabIndex: this.tabIndex,
      disabled: this.disabled,
      readOnly: this.readOnly,
      color: this.computedColor,
      backgroundColor: this.computedBgColor,
      strokeWidth: this.strokeWidth,
      smooth: this.smooth,
      popupScale: this.$props.popupScale,
      scale: 1 / this.popupScale * this.exportScale,
      onChange: this.onValueChange,
      elementSize: this.elementSize,
      onDraw: this.onDraw,
      onDrawend: this.onDrawEnd
    })]);
  },
  methods: {
    setRefs: function setRefs() {
      this.canvas = getRef(this, "canvas");
      this.minimizeButton = getRef(this, "minimizeButton");
      this.maximizeButton = getRef(this, "maximizeButton");
      this.dialog = getRef(this, "dialog");
      this.popupWidth = this.popupSize().width;
      this.popupHeight = this.popupSize().height;
    },
    onOverlayClick: function onOverlayClick2() {
      this.currentOpen = false;
    },
    onValueChange: function onValueChange3(nextValue) {
      this.currentValue = nextValue;
      this.$emit("changemodel", nextValue);
      this.$emit("update:modelValue", nextValue);
      this.$emit("change", {
        value: nextValue
      });
    },
    onDialogChange: function onDialogChange(e) {
      this.onValueChange(e.value);
    },
    reset: function reset() {
      this.clear();
      this.onValueChange();
    },
    clear: function clear2() {
      if (this.canvas) {
        this.canvas.clear();
      }
      if (this.dialog && this.dialog.openCanvas) {
        this.dialog.openCanvas.clear();
      }
    },
    loadImage: function loadImage2(value2) {
      if (this.canvas) {
        this.canvas.loadImage(value2);
      }
      if (this.dialog && this.dialog.openCanvas) {
        this.dialog.openCanvas.loadImage(value2);
      }
    },
    onDialogClose: function onDialogClose(event) {
      var _a5;
      this.onMinimizeClick(event);
      (_a5 = this.maximizeButton || this.canvas.$el) === null || _a5 === void 0 ? void 0 : _a5.focus();
    },
    exportImage: function exportImage3(exportSize) {
      var _a5;
      var width = exportSize.width, height = exportSize.height;
      return (_a5 = this.canvas.instance) === null || _a5 === void 0 ? void 0 : _a5.exportImage({
        width: width * this.exportScale,
        height: height * this.exportScale
      });
    },
    validityGetter: function validityGetter() {
      var customError = this.$props.validationMessage !== void 0;
      var currentValue = this.computedValue;
      var valueMissing = !currentValue;
      var valid = this.$props.valid !== void 0 ? this.$props.valid : !this.required || !valueMissing;
      return {
        customError,
        valid,
        valueMissing
      };
    },
    focusElement: function focusElement5() {
      this.canvas.$el.focus();
    },
    getImperativeHandle: function getImperativeHandle() {
      var _this = this;
      var options2 = {
        element: this.$el,
        focus: this.focusElement()
      };
      Object.defineProperty(options2, "name", {
        get: function get10() {
          return _this.name;
        }
      });
      Object.defineProperty(options2, "value", {
        get: function get10() {
          return _this.computedValue;
        }
      });
      Object.defineProperty(options2, "validity", {
        get: function get10() {
          return _this.validityGetter();
        }
      });
      Object.defineProperty(options2, "validityStyles", {
        get: function get10() {
          return _this.validityStyles;
        }
      });
      Object.defineProperty(options2, "required", {
        get: function get10() {
          return _this.required;
        }
      });
      Object.defineProperty(options2, "color", {
        get: function get10() {
          return _this.computedColor;
        }
      });
      Object.defineProperty(options2, "backgroundColor", {
        get: function get10() {
          return _this.computedBgColor;
        }
      });
      return options2;
    },
    onFocus: function onFocus7(event) {
      if (this.focused || this.computedOpen) {
        return;
      }
      this.focused(true);
      this.$emit("focus", __assign11({
        event
      }, this.getImperativeHandle()));
    },
    onBlur: function onBlur7(event) {
      var insideWrapper = hasParent(event.relatedTarget, this.$el);
      if (insideWrapper) {
        return;
      }
      this.focused = false;
      this.$emit("blur", __assign11({
        event
      }, this.getImperativeHandle()));
    },
    onMaximizeClick: function onMaximizeClick(event) {
      return __awaiter(this, void 0, void 0, function() {
        var that;
        return __generator(this, function(_a5) {
          that = this;
          this.exportImage(this.popupSize()).then(function(newValue) {
            that.currentValue = newValue;
          });
          this.currentOpen = true;
          this.$emit("open", __assign11({
            event
          }, this.getImperativeHandle()));
          return [
            2
            /*return*/
          ];
        });
      });
    },
    onMinimizeClick: function onMinimizeClick2(event) {
      this.currentOpen = false;
      this.$emit("close", __assign11({
        event
      }, this.getImperativeHandle()));
    },
    onClear: function onClear3() {
      this.reset();
      this.focusElement();
    },
    elementSize: function elementSize2() {
      var width = this.$props.width || this.$el && this.$el.offsetWidth || DEFAULT_WIDTH2;
      var height = this.$props.height || this.$el && this.$el.offsetHeight || DEFAULT_HEIGHT2;
      return {
        width,
        height
      };
    },
    popupSize: function popupSize() {
      var _a5 = this.elementSize(), width = _a5.width, height = _a5.height;
      return {
        width: width * this.popupScale,
        height: height * this.popupScale
      };
    },
    onDraw: function onDraw3() {
      this.isDrawing = true;
    },
    onDrawEnd: function onDrawEnd3() {
      this.isDrawing = false;
    }
  }
};
var Signature = SignatureVue2;
export {
  Checkbox,
  CheckboxVue2,
  ColorGradient,
  ColorPalette,
  ColorPicker,
  ColorPickerVue2,
  FlatColorPicker,
  FlatColorPickerVue2,
  Input,
  InputSeparator,
  InputSeparatorVue2,
  InputVue2,
  MaskedTextBox,
  MaskedTextBoxVue2,
  NumericTextBox,
  NumericTextBoxVue2,
  RadioButton,
  RadioButtonVue2,
  RadioGroup,
  RadioGroupVue2,
  RangeSlider,
  RangeSliderVue2,
  SLIDER_LABEL_ATTRIBUTE,
  Signature,
  SignatureVue2,
  Slider,
  SliderLabel,
  SliderLabelVue2,
  SliderVue2,
  Switch,
  SwitchVue2,
  TextArea,
  TextAreaResizeEnum,
  TextAreaVue2,
  TextBox,
  TextBoxVue2
};
//# sourceMappingURL=@progress_kendo-vue-inputs.js.map
